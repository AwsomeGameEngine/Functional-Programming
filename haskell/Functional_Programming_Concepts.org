#+TITLE:  Functional Programming Concepts
#+AUTHOR: Caio Rodrigues Soares Silva
#+EMAIL: <caiorss.rodrigues@gmail.com>
#+DESCRIPTION: Functional programming concepts, examples, algorithms and ideas.

* Concepts
** Overview

*Functional Programming*

Functional Programming is all about programming with functions.

*Functional Programming Features*

 - Pure Functions / Referential Transparency / No side effect
 - Function Composition
 - Lambda Functions/ Anonymous Functions
 - High Order Functions
 - Currying/ Partial Function Application
 - Closure - Returning functions from functions
 - Data Immutability
 - Pattern Matching
 - Lists are the fundamental data Structure

Non Essential Features:

 - Static Typing
 - Type Inferencing
 - Algebraic Data Types

*Functional Programming Design Patterns*

 - Curry/ Partial function application  - Creating new functions by holding a parameter constant
 - Closure - Return functions from functions
 - Pure Functions: separate pure code from impure code.
 - Function composition
 - Composable functions
 - High Order Functions
 - MapReduce Algorithms - Split computation in multiple computers cores.
 - Lazy Evaluation ( aka Delayed evaluation)
 - Pattern Matching
 - Monads

** Evaluation Strategy / Parameter Passing 
*** Call-by-value

Call-by-value (aka pass-by-value, eager evaluation, strict evaluation or
applicative-order evaluation) Evaluation at the point of call, before
the function application application. This evaluation strategy is used
by most programming languages like Python, Scheme, Ocaml and others.


#+BEGIN_SRC 
let add2xy x y = x + x + y 

add2xy (3 * 4) ( 2 + 3) 
add2xy 12 5 
=  12 + 12 + 5 
=  29

#+END_SRC

Example in Python:

#+BEGIN_SRC python
>>> def add(x, y):
...   sum = x + y
...   x = sum 
...   return (x, sum)
... 
>>> 


>>> x = 10
>>> y = 20

# In call-by-value strategy. The function doesn't change its arguments. 
# 
>>> add(x, y)
(30, 30)

# They remain unchanged.
#
>>> x
10
>>> y
20

# Arguments are evaluated before the function invocation.
#
# add((10 + 20), (3 * 3))
# add(30, 9)
# (39, 39)
#
>>> add((10 + 20),(3 * 3))
(39, 39)
>>> 
>>> add((10 + 20),(3 / 0))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 

#+END_SRC

*** Call-by-name

Call-by-name (aka pass-by-name): It is a _non-memoized lazy_
_evaluation_. Arguments are passed non evaluated, they are only
evaluated when it is needed. The arguments are substituted in the
function. This evaluation strategy can be inefficient when the
arguments are evaluated many times.

Example: 

#+BEGIN_SRC
// Each use of x y and replaced in the function by (3 * 4) and (2 + 3)
// respectively. The arguments are evaluated after substituted 
// in the function

let add2xy x y = x + x + y
let add2xy (3 * 4) (2 + 3) 
= (3 * 4) + (3 * 4) + (2 + 3)
= 12 + 12 + 5
= 29
#+END_SRC



Call-by-name can be simulated using thunks (functions without arguments).

Example in Python: 

#+BEGIN_SRC python
>>> def add2xy (x, y):
...     return x() + x() + y()
... 
>>> add2xy (lambda : (3 * 4), lambda: (2 + 3))
29
>>> 

#+END_SRC

Example in Scheme:

#+BEGIN_SRC scheme
>  (define (add2xy x y) (+ (x) (x) (y))) 
> 
;; The parameter is evaluated every time it is used. 
;;
> (define (displayln msg) 
      (display msg)
      (newline))


> (add2xy (lambda () (displayln "Eval x") (* 3 4))  
          (lambda () (displayln "Eval y") (+ 2 3))
  )               
Eval x
Eval x
Eval y
29
> 
#+END_SRC

*** Call-by-need 

Call-by-need_ (aka lazy evaluation, non-strict evaluation or
normal-order evaluation): _Memoized lazy-evaluation_. It is a 
memoized version of call-by-name, after its argument is evaluated,
the values are stored for further computations. When the argument
evaluation has no side-effects, in other words, always yields the
same output when evaluated many times it produces the same result
as call-by-name. This strategy is used in Haskell.

Example: In Haskell the parameters are not evaluated at the point they
are passed to the function. They are only evaluated when needed.

#+BEGIN_SRC haskell
> let add_xy x y z = x + y
> 
> :t add_xy
add_xy :: Num a => a -> a -> t -> a
>

-- The parameter z: (3 / 0) is not evaluated 
-- because it is not needed.
-- 
> add_xy 3 4 (3 / 0)
7
> 

-- The infinite list is not fully evaluated 
--
> let ones = 1:ones

> take 10 ones
[1,1,1,1,1,1,1,1,1,1]
> 
> take 20 ones
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
> 
#+END_SRC

*** Call-by-reference 

 - _Call-by-reference_ (aka pass-by-reference): The function changes
   the value of the argument. Supported in: C++, Pascal, Python
   Objects.

Example in C:

#+BEGIN_SRC C
// The function add10 changes it argument.
//
#include <stdio.h>

void add10(int * x){
  *x = *x + 10 ;
}

void main (){
  
  int x = 5;
  add10(&x);
  printf("x = %d\n", x);  
}

#+END_SRC

Test:

#+BEGIN_SRC 
$ gcc /tmp/test.c
$ ./a.out 
x = 15

$ tcc -run /tmp/test.c
x = 15
#+END_SRC

*** References

  - [[http://www.lix.polytechnique.fr/~catuscia/teaching/cg428/02Spring/lecture_notes/L07.1.html][CSE 428: Lecture Notes 8]]
  - [[http://users-cs.au.dk/danvy/dProgSprog12/Lecture-notes/parameter-passing-strategies.html][Parameter-passing strategies â€” dProgSprog 2012 Lecture Notes]]
  - [[http://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/lazyevaluation.html][CPS 343/543 Lecture notes: Lazy evaluation and thunks]]
  - [[https://en.wikipedia.org/wiki/Evaluation_strategy#Strict_evaluation][Evaluation strategy - Wikipedia, the free encyclopedia]]
  - [[http://www.lix.polytechnique.fr/~catuscia/teaching/cg428/02Spring/lecture_notes/L07.1.html][CSE 428: Lecture Notes 8 - Procedures and Functions]] 

** First-Class Function 

Functions can be passed as arguments to another functions, returned
from functions, stored in variables and data structures and built at
run time. The majority of languages supports first-class functions
like Scheme, Javascript, Python, Haskell, ML, OCaml and many others
some exceptions are C, Java, Matlab and Forth.

Examples:

 - Python:

The function f is passed as argument to the derivate function that
returns a new function named _, that computes the derivate of f at x.

#+BEGIN_SRC python
def derivate (f, dx=1e-5):
    def _(x):
        return (f(x+dx) - f(x))/dx
    return _
    
 #  Algebraic derivate:
 #
 #  df(x) = 2*x - 3
 #    
>>> def f(x): return x**2 - 3*x + 4
... 

 # Numerical derivate of f
>>> df = derivate(f)
>>> 

  # Algebraic derivate of f
>>> def dfa (x): return 2*x - 3
... 
>>> 

 ;; Functions can be stored in variables
>>> func = f
>>> func(5)
14
>>> 

>>> df = derivate(f)
>>> df(3)
3.000009999887254
>>> df(4)
5.000009999633903
>>> 

>>> dfa(3)
3
>>> dfa(4)
5
>>> 


>>> f(3)
4
>>> f(10)
74
>>> 
#+END_SRC

See also: 

Many examples of first class functions in several languages. 

 - [[http://rosettacode.org/wiki/First-class_functions#C][First-class functions - Rosetta Code]]

 - [[http://slidegur.com/doc/1814324/first-class-functions-in-scientific-programming][First-class Functions in Scientific Programming]]

 - [[http://adv-r.had.co.nz/Functional-programming.html][Functional programming in R]]

** Pure Functions

Pure functions:

 - Are functions without side effects, like mathematical functions. 
 - For the same input the functions always returns the same output.
 - The result of any function call is fully determined by its arguments. 
 - Pure functions don't rely on global variable and don't have internal states.
 - They don't do IO, i.e .:. don't print, don't write a file ...
 - Pure functions are stateless
 - Pure functions are deterministic

Why Pure Functions:

 - Composability, one function can be connected to another.
 - Can run in parallel, multi threading, multi core, GPU and distributed systems.
 - Better debugging and testing.
 - Predictability

*Example of pure functions*

#+BEGIN_SRC python
def min(x, y):
    if x < y:
        return x
    else:
        return y
#+END_SRC


*Example of impure function*

 - Impure functions doesn't have always the same output for the same
 - Impure functions does IO or has Hidden State or Global Variables

#+BEGIN_SRC python
exponent = 2

def powers(L):
    for i in range(len(L)):
        L[i] = L[i]**exponent
    return L
#+END_SRC
The function min is pure. It always produces the same result given 
the same inputs and it does not affect any external variable.

The function powers is impure because it not always gives the same output
for the same input, it depends on the global variable exponent:

#+BEGIN_SRC python

>>> exponent = 2
>>> 
>>> def powers(L):
...     for i in range(len(L)):
...         L[i] = L[i]**exponent
...     return L
... 
>>> powers([1, 2, 3])
[1, 4, 9]
>>> exponent = 4 
>>> powers([1, 2, 3])  # (It is impure since it doesn't give the same result )
[1, 16, 81]
>>> 
#+END_SRC

Another example, purifying an impure Language:

#+BEGIN_SRC python

>>> lst = [1, 2, 3, 4]  # An pure function doesn't modify its arguments.
>>>                     # therefore lst reverse is impure
>>> x = lst.reverse()
>>> x
>>> lst
[4, 3, 2, 1]

>>> lst.reverse()
>>> lst
[1, 2, 3, 4]
#+END_SRC

Reverse list function purified:

#+BEGIN_SRC python

>>> lst = [1, 2, 3, 4]
>>>
>>> def reverse(lst):
...     ls = lst.copy()
...     ls.reverse()
...     return ls
... 
>>> 
>>> reverse(lst)
[4, 3, 2, 1]
>>> lst
[1, 2, 3, 4]
>>> reverse(lst)
[4, 3, 2, 1]
>>> lst
[1, 2, 3, 4]

#+END_SRC

** Closure

Closure is a function that remembers the environment at which it was created.

#+BEGIN_SRC python

>>> x = 10

 # The function adder remembers the environment at which it was created
 # it remembers the value of x
 #
def make_adder(x):
    def adder(y):
        return x + y
    return adder

>>> add5 = make_adder(5)
>>> add10 = make_adder(10)
>>> 
>>> add5(4)
9
>>> list(map(add5, [1, 2, 3, 4, 5]))
[6, 7, 8, 9, 10]

>>> x
10
>>> 

>>> list(map(add10, [1, 2, 3, 4, 5]))
[11, 12, 13, 14, 15]

 #
 
def make_printer(msg):
    def printer():
        print(msg)
    return printer

>>> p1 = make_printer ("Hello world")
>>> p2 = make_printer ("FP programming Rocks!!")
>>> 
>>> p1()
Hello world
>>> p2()
FP p

 # Mutable state with closure
 
idx = 100 
 
def make_counter():
    idx = -1    
    def _():
        nonlocal idx
        idx = idx + 1
        return idx    
    return _

>>> idx = 100
>>> counter1 = make_counter()
>>> counter1()
0
>>> counter1()
1
>>> counter1()
2
>>> counter1()
3

>>> idx
100
>>> counter2 = make_counter ()
>>> counter2()
0
>>> counter2()
1
>>> counter2()
2

>>> counter1()
5
>>> 

>>> del make_counter
>>> make_counter
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'make_counter' is not defined
>>> 
>>> counter1()
6
>>> counter1()
7

#+END_SRC

Example of closure in Clojure: 

#+BEGIN_SRC clojure

(defn make-adder [x]
   (fn [y] (+ x y)))

user=> (def add5 (make-adder 5))
#'user/add5
user=> 
user=> (def add10 (make-adder 10))
#'user/add10
user=> 
user=> (add5 10)
15
user=> (add10 20)
30
user=> (map (juxt add5 add10)  [1 2 3 4 5 6])
([6 11] [7 12] [8 13] [9 14] [10 15] [11 16])
user=> 

(defn make-printer [message]
  
  (fn [] (println message)))

user=> (def printer-1 (make-printer "Hello world"))
#'user/printer-1
user=> 
user=> (def printer-2 (make-printer "Hola Mundo"))
#'user/printer-2
user=> 
user=> (printer-1)
Hello world
nil
user=> (printer-2)
Hola Mundo
nil
user=> 

#+END_SRC

Example of closure in F# (F sharp):

#+BEGIN_SRC fsharp 

let make_adder x =
    fun y -> x + y 

val make_adder : x:int -> y:int -> int

> let add5 = make_adder 5 ;;

val add5 : (int -> int)

> let add10 = make_adder 10 ;;

val add10 : (int -> int)

> add5 20 ;;
val it : int = 25
> 
- add10 30 ;;
val it : int = 40
> 
- List.map add5 [1 ; 2; 3; 4; 5; 6] ;;
val it : int list = [6; 7; 8; 9; 10; 11]
> 

//  As F# have currying like OCaml and Haskell 
//  it could be also be done as 
//

- let make_adder x y = x + y ;;

val make_adder : x:int -> y:int -> int

> let add10 = make_adder 10 ;;

val add10 : (int -> int)

> add10 20 ;;
val it : int = 30
> 


#+END_SRC

** Currying and Partial Application
*** Currying

Currying is the decomposition of a function of multiples arguments in
a chained sequence of functions of a single argument. The name
currying comes from the mathematician [[https://en.wikipedia.org/wiki/Haskell_Curry][Haskell Curry]] who developed the
concept of curried functions.

In Haskell, Standard ML, OCaml and F# all functions are curryfied by
default:

#+BEGIN_SRC
    f (x, y) = 10*x - 3*y   
    
    f (4, 3)  = 10* 4 - 3*3 = 40 - 9 = 31
    f (4, 3)  = 31
    
In the curried form becomes:

     g(x) = (x -> y -> 10 * x - 3*y)
     
To evaluate f(4, 3): 

    h(y)  = (x -> y -> 10 * x - 3*y) 4 
          = ( y -> 10 * 4 -  3*y )
          =  y -> 40 - 3*y
          
    h(3)  = (y -> 40 - 3*y) 3
          = 40 - 3*3
          = 31
          
Or:
    (x -> y -> 10 * x - 3*y) 4 3 
      = (x -> (y -> 10 * x - 3*y)) 4 3 
      = ((x -> (y -> 10 * x - 3*y)) 4) 3 
      = (y -> 10 * 4 - 3 * y) 3
      = 10 * 4 - 3 * 3 
      = 31
#+END_SRC
          
The same function h(y) can be reused: applied to another arguments, used in mapping, filtering and another higher order functions.

#+BEGIN_SRC
Ex1
    h(y) = (y -> 40 - 3*y)
    
    h(10) = 40 - 3*10 = 40 - 30 = 10

Ex2    
    map(h, [2, 3, 4])
      = [h 2, h 3, h 4] 
      = [(y -> 40 - 3*y) 2, (y -> 40 - 3*y) 3, (y -> 40 - 3*y) 4]
      = [34, 31, 28]
#+END_SRC

*Example in Haskell GHCI*

#+BEGIN_SRC haskell
> let f x y = 10 * x - 3 * y
> :t f
f :: Num a => a -> a -> a
> 
> f 4 3 
31
> let h_y = f 4
> :t h_y
h_y :: Integer -> Integer
> 
> h_y 3
31
> map h_y [2, 3, 4]
[34,31,28]
> 

> -- It is evaluated as:

> ((f 4) 3)
31
> 

{-
   The function f can be also seen in this way
-}   

> let f' = \x -> \y -> 10 * x - 3 * y 
> 

> :t f'
f' :: Integer -> Integer -> Integer
> 

> f' 4 3
31
> 

> (f' 4 ) 3
31
> 

> let h__x_is_4_of_y = f' 4

> h__x_is_4_of_y 3
31
> 
{-
    (\x -> \y -> 10 * x - 3 * y) 4 3
    =  (\x -> (\y -> 10 * x - 3 * y) 4) 3
    =  (\y -> 10 * 4 - 3 * y) 3
    =  (10 * 4 - 3 * 3)
    =  40 - 9 
    =  31    
-}
> (\x -> \y -> 10 * x - 3 * y) 4 3
31
> 

> ((\x -> (\y -> 10 * x - 3 * y)) 4) 3
31
> 


{-
Curried functions are suitable for composition, pipelining 
(F#, OCaml with the |> operator),  mapping/ filtering operations,
and to create new function from previous defined increasing code reuse.

-}

> map (f 4) [2, 3, 4]
[34,31,28]
> 

> map ((\x -> \y -> 10 * x - 3 * y) 4) [2, 3, 4]
[34,31,28]
> 


> -- ----------------- 

> let f_of_x_y_z x y z = 10 * x + 3 * y + 4 * z
> 

> :t f_of_x_y_z 
f_of_x_y_z :: Num a => a -> a -> a -> a

> f_of_x_y_z 2 3 5
49
> 

> let g_of_y_z = f_of_x_y_z 2

> :t g_of_y_z 
g_of_y_z :: Integer -> Integer -> Integer
> 

> g_of_y_z 3 5
49
> 

> let h_of_z = g_of_y_z 3
> :t h_of_z 
h_of_z :: Integer -> Integer
> 

> h_of_z 5
49
> 

> -- So it is evaluated as 
> (((f_of_x_y_z 2) 3) 5)
49
> 
#+END_SRC

*Example in Python 3*

#+BEGIN_SRC python

 # In Python, the functions are not curried by default as in Haskell, 
 # Standard ML, OCaml and F#
 #
>>> def f(x, y): return 10 * x - 3*y

>>> f(4, 3)
    31

 # However the user can create the curried form of the function f:

>>> curried_f = lambda x: lambda y: 10*x - 3*y

>>> curried_f(4)
    <function __main__.<lambda>.<locals>.<lambda>>

>>> curried_f(4)(3)
    31

>>> h_y = curried_f(4) # x = 4 constant

>>> h_y(3)
    31

>>> h_y(5)
    25

>>> mapl = lambda f_x, xs: list(map(f_x, xs))

>>> mapl(h_y, [2, 3, 4])
    [34, 31, 28]

 # Or 

>>> mapl(curried_f(4), [2, 3, 4])
    [34, 31, 28]

 # Without currying the mapping would be:

>>> mapl(lambda y: f(4, y), [2, 3, 4])
    [34, 31, 28]

   ########################################

>> f_of_x_y_z = lambda x, y, z: 10 * x + 3 * y + 4 * z

 ## Curried form:
 
>>> curried_f_of_x_y_z = lambda x: lambda y: lambda z: 10 * x + 3 * y + 4 * z

>>> f_of_x_y_z (2, 3, 5)
    49

>>> curried_f_of_x_y_z (2)(3)(5)
    49

>>> g_of_y_z = curried_f_of_x_y_z(2)

>>> g_of_y_z
    <function __main__.<lambda>.<locals>.<lambda>>

>>> g_of_y_z (3)(5)
    49


>>> h_of_z = g_of_y_z(3)

>>> h_of_z
    <function __main__.<lambda>.<locals>.<lambda>.<locals>.<lambda>>

>>> h_of_z(5)
    49


#+END_SRC

*Example in Ocaml and F#*

#+BEGIN_SRC ocaml

    # let f x y = 10 * x - 3 * y ;;
    val f : int -> int -> int = <fun>

    # f 4 3 ;;
    - : int = 31

    # f 4 ;;
    - : int -> int = <fun>

    # (f 4) 3 ;;
    - : int = 31
    # 

    # let h_y = f 4 ;;
    val h_y : int -> int = <fun>

    # h_y 3 ;;
    - : int = 31
    # 

    # List.map h_y [2; 3; 4] ;;
    - : int list = [34; 31; 28]
    # 

    # List.map (f 4) [2; 3; 4] ;;
    - : int list = [34; 31; 28]

    # let f' = fun x -> fun y -> 10 * x - 3 * y ;;
    val f' : int -> int -> int = <fun>

    # (f' 4) 3 ;;
    - : int = 31

    # (fun x -> fun y -> 10 * x - 3 * y) 4 3 ;;
    - : int = 31
    # 

    # List.map ((fun x -> fun y -> 10 * x - 3 * y) 4) [2; 3; 4] ;;
    - : int list = [34; 31; 28]

#+END_SRC

*** Partial Application

A function of multiple arguments is converted into a new function that
takes fewer arguments, some arguments are supplied and returns
function with signature consisting of remaining arguments. *Partially
applied** functions must not be confused with **currying*.

Example in Python:

#+BEGIN_SRC python
>>> from functools import partial

>>> def f(x, y, z): return 10 * x + 3 * y + 4 * z

>>> f(2, 3, 5)
    49

>>> f_yz = partial(f, 2) # x = 2
>>> f_yz(3, 5)
    49

>>> f_z = partial(f_yz, 3)

>>> f_z(5)
    49
    
>>> partial(f, 2, 3)(5)
    49
  
>>> list(map(partial(f, 2, 3), [2, 3, 5]))
    [37, 41, 49]

#
# Alternative implementation of partial
#
def partial(f, *xs):
    return lambda x: f( * (tuple(xs) + (x,)))

>>> list(map(partial(f, 2, 3), [2, 3, 5]))
    [37, 41, 49]
>>> 


#+END_SRC

In languages like Haskell, Standard ML, OCaml and F# currying is
similar to partial application.

Example in OCaml:

#+BEGIN_SRC ocaml

    # let f x y z = 10 * x + 3 *y + 4 * z ;;
    val f : int -> int -> int -> int = <fun>
    # 

    # (f 2 3) ;;
    - : int -> int = <fun>
    
    # let f_z = f 2 3 ;;
    val f_z : int -> int = <fun>

    # f_z 5 ;;
    - : int = 49
    #    
    
    (** Write (f 2 3) is the same as write (f 2)(3)  *)
    # List.map (f 2 3) [2; 3; 5] ;;
    - : int list = [37; 41; 49]
    # 
    
#+END_SRC

See also:

 - [[http://www.ibm.com/developerworks/library/j-jn9/][Java.next: Currying and partial application]]
 - [[https://en.wikipedia.org/wiki/Partial_application][Partial application - Wikipedia]]
 - [[https://dzone.com/articles/whats-wrong-java-8-currying-vs][What's Wrong with Java 8: Currying vs Closures]]

** Lazy Evaluation

"Lazy evaluation" means that data structures are computed
incrementally, as they are needed (so the trees never exist in memory
all at once) parts that are never needed are never computed. Haskell
uses lazy evaluation by default.

Example in Haskell: 

#+BEGIN_SRC haskell
> let lazylist = [2..1000000000]
> 
> let f x = x^6 
> 
> take 5 lazylist 
[2,3,4,5,6]
>
>
> {- Only the terms needed are computed. -}
> take 5 ( map f lazylist )
[64,729,4096,15625,46656]
> 
#+END_SRC

Example in Python:

 - Python uses eager evaluation by default. In order to get lazy evaluation in python the programmer must use iterators or generators. The example below uses generator.

#+BEGIN_SRC python

def lazy_list():
    """ Infinite list """
    x = 0 
    while True:
        x += 2
        yield x


>>> gen = lazy_list()
>>> next(gen)
2
>>> next(gen)
4
>>> next(gen)
6
>>> next(gen)
8
>>> next(gen)
10
>>> 

def take(n, iterable):
    return [next(iterable) for i in range(n)]

def mapi(func, iterable):   
    while True:
        yield func(next(iterable))
        
f = lambda x: x**5

>>> take(5, lazy_list())
[2, 4, 6, 8, 10]
>>> take(10, lazy_list())
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
>>> 

>>> take(5, mapi(f, lazy_list()))
[32, 1024, 7776, 32768, 100000]
>>> 
>>> take(6, mapi(f, lazy_list()))
[32, 1024, 7776, 32768, 100000, 248832]
>>> 

#+END_SRC

** Tail Call Optimization and Tail Recursive Functions 
*** Tail Call 

A tail call is a function call which is the last action performerd by
a function.

Examples of _tail calls_ and _non tail calls_: 

Example 1: Tail call 

#+BEGIN_SRC python 
def func1(x):
    return  tail_call_function (x * 2) # It is a tail call 
#+END_SRC


Example 2: Tail recusive call or tail recursive function. 

#+BEGIN_SRC python 
def tail_recursive_call (n, acc);
    if n = 0:
       return acc 
       return tai_recursive_acll (n - 1, n * acc) # Tail recursive call, the 
                                                  # function call is the last
                                                  # thing the function does. 
#+END_SRC

Example 3: Non tail call 

#+BEGIN_SRC python
def non_tail_call_function(x):
    return 1 + non_tail_call_function (x + 3) 
 #+END_SRC

*** Tail Call Optimization  

Tail call optimization - TCO. (aka. tail call elimination - TCE or
tail recursion elimination - TRE) is a optimization that replaces
calls in tail positions with jumps which guarantees that loops
implemented using recursion are executed in constant stack
space.  [fn:martin-odersky-tail-call]

Without tail call optimization each recursive call creates a
new stack frame by growing the execution stack. Eventually the
stack runs out of space and the program has to stop.  To support
iteration by recursion functional languages need tail call
optimization.  [fn:Schwaighofer-2009]

If the language doesn't support TCO it is not possible to perform
recursion safely. A big number of calls will lead to a stack overflow
exception and the program will crash unexpectedly .

Sometimes non tail recursive functions can be changed to tail
recursive by adding a new function with extra parameters
(accumulators) to store partial results (state).

Languages with TCO support: 

 - Scheme
 - Common Lisp 
 - Haskell
 - Ocaml
 - F# (F sharp)
 - C# (C sharp)
 - Scala
 - Erlang 

Languages without TCO support: 

 - Python [fn:python-tco1] [fn:python-tco2]
 - Ruby 
 - Java   (Note: The JVM doesn't support TCO)
 - Clojure
 - JavaScript
 - R [fn:R-tco]
 - Elisp - Emacs Lisp 

*** Examples 

Example of non tail recursive function in Scheme (GNU Guile): 

#+BEGIN_SRC scheme 
(define (factorial n)
    (if (or (= n 0) (= n 1))
        1
        (* n  (factorial (- n 1)))))
        
> (factorial 10)
$1 = 3628800
> 

;;  For a very big number of iterations, non tail recursive functions
;;  will cause a stack overflow.
;;
> (factorial 20000000)
warnings can be silenced by the --no-warnings (-n) option
Aborted (core dumped)

;;
;; This execution requires 5 stack frames
;;
;;  (factorial 5)
;;  (* 5 (factorial 4))
;;  (* 5 (* 4 (factorial 3)))
;;  (* 5 (* 4 (3 * (factorial 2))))
;;  (* 5 (* 4 (* 3 (factorial 2))))
;;  (* 5 (* 4 (* 3 (* 2 (factorial 1)))))
;;
;;  (* 5 (* 4 (* 3 (* 2 1))))
;;  (* 5 (* 4 (* 3 2)))
;;  (* 5 (* 4 6))
;;  (* 5 24)
;;  120
;;
;;
;;
;;
> ,trace (factorial 5)
trace: |  (#<procedure 99450c0> #(#<directory (guile-user) 95c3630> â€¦))
trace: |  #(#<directory (guile-user) 95c3630> factorial)
trace: (#<procedure 9953350 at <current input>:8:7 ()>)
trace: (factorial 5)
trace: |  (factorial 4)
trace: |  |  (factorial 3)
trace: |  |  |  (factorial 2)
trace: |  |  |  |  (factorial 1)
trace: |  |  |  |  1
trace: |  |  |  2
trace: |  |  6
trace: |  24
trace: 120
> 

;;
;; It requires 10 stack frames
;;
;;        
> ,trace (factorial 10)
trace: |  (#<procedure 985cbd0> #(#<directory (guile-user) 95c3630> â€¦))
trace: |  #(#<directory (guile-user) 95c3630> factorial)
trace: (#<procedure 9880800 at <current input>:6:7 ()>)
trace: (factorial 10)
trace: |  (factorial 9)
trace: |  |  (factorial 8)
trace: |  |  |  (factorial 7)
trace: |  |  |  |  (factorial 6)
trace: |  |  |  |  |  (factorial 5)
trace: |  |  |  |  |  |  (factorial 4)
trace: |  |  |  |  |  |  |  (factorial 3)
trace: |  |  |  |  |  |  |  |  (factorial 2)
trace: |  |  |  |  |  |  |  |  |  (factorial 1)
trace: |  |  |  |  |  |  |  |  |  1
trace: |  |  |  |  |  |  |  |  2
trace: |  |  |  |  |  |  |  6
trace: |  |  |  |  |  |  24
trace: |  |  |  |  |  120
trace: |  |  |  |  720
trace: |  |  |  5040
trace: |  |  40320
trace: |  362880
trace: 3628800
>        

#+END_SRC

This function can be converted to a tail recursive function by using
an accumulator:

#+BEGIN_SRC scheme 
(define (factorial-aux n acc)
    (if (or (= n 0) (= n 1))
        acc
        (factorial-aux (- n 1) (* n acc))))

> (factorial-aux 6 1)
$1 = 720

> ,trace (factorial-aux 6 1)
trace: |  (#<procedure 9becf10> #(#<directory (guile-user) 984c630> â€¦))
trace: |  #(#<directory (guile-user) 984c630> factorial-aux)
trace: (#<procedure 9bec320 at <current input>:26:7 ()>)
trace: (factorial-aux 6 1)
trace: (factorial-aux 5 6)
trace: (factorial-aux 4 30)
trace: (factorial-aux 3 120)
trace: (factorial-aux 2 360)
trace: (factorial-aux 1 720)
trace: 720
scheme@(guile-user)> 

> (define (factorial2 n) (factorial-aux n 1))

scheme@(guile-user)> (factorial2 5)
$3 = 120

;; This function could also be implemented in this way:
;;
;;
(define (factorial3 n) 
    (define (factorial-aux n acc)
        (if (or (= n 0) (= n 1))
            acc
            (factorial-aux (- n 1) (* n acc))))        
    (factorial-aux n 1))

> (factorial3 6)
$4 = 720

> (factorial3 5)
$5 = 120

#+END_SRC

Example: Summation of a range of numbers:

#+BEGIN_SRC scheme
;;  Non tail recursive function:
;;
(define (sum-ints a b)
    (if (> a b)
        0
        (+ a (sum-ints (+ a 1) b))))


;;
;; Using the trace command is possible to notice the growing amount of
;; stack frame In this case it requires 11 stack frames.

> ,trace (sum-ints 1 10)
trace: |  (#<procedure 9c42420> #(#<directory (guile-user) 984c630> â€¦))
trace: |  #(#<directory (guile-user) 984c630> sum-ints)
trace: (#<procedure 9c4b8c0 at <current input>:56:7 ()>)
trace: (sum-ints 1 10)
trace: |  (sum-ints 2 10)
trace: |  |  (sum-ints 3 10)
trace: |  |  |  (sum-ints 4 10)
trace: |  |  |  |  (sum-ints 5 10)
trace: |  |  |  |  |  (sum-ints 6 10)
trace: |  |  |  |  |  |  (sum-ints 7 10)
trace: |  |  |  |  |  |  |  (sum-ints 8 10)
trace: |  |  |  |  |  |  |  |  (sum-ints 9 10)
trace: |  |  |  |  |  |  |  |  |  (sum-ints 10 10)
trace: |  |  |  |  |  |  |  |  |  |  (sum-ints 11 10)
trace: |  |  |  |  |  |  |  |  |  |  0
trace: |  |  |  |  |  |  |  |  |  10
trace: |  |  |  |  |  |  |  |  19
trace: |  |  |  |  |  |  |  27
trace: |  |  |  |  |  |  34
trace: |  |  |  |  |  40
trace: |  |  |  |  45
trace: |  |  |  49
trace: |  |  52
trace: |  54
trace: 55


;;  Stack Overflow Error
;;
> (sum-ints 1 10000)
> <unnamed port>:4:13: In procedure sum-ints:
<unnamed port>:4:13: Throw to key `vm-error' with args `(vm-run "VM: Stack overflow" ())'.

;; 
;; Safe summation 
;;
(define (sum-ints-aux a b acc)
    (if (> a b)
        acc
        (sum-ints-aux (+ a 1) b (+ a acc))))
    
(define (sum-ints-aux a b acc)
    (if (> a b)
        acc
        (sum-ints-aux (+ a 1) b (+ a acc))))
    
> (sum-ints-aux 1 10 0)
$4 = 55
> 

> (sum-ints-aux 1 10000 0)
$6 = 50005000

;;
;; It uses only one stack frame each call
;;
> ,trace (sum-ints-aux 1 10 0)
trace: |  (#<procedure 985a270> #(#<directory (guile-user) 93fd630> â€¦))
trace: |  #(#<directory (guile-user) 93fd630> sum-ints-aux)
trace: (#<procedure 98646a0 at <current input>:31:7 ()>)
trace: (sum-ints-aux 1 10 0)
trace: (sum-ints-aux 2 10 1)
trace: (sum-ints-aux 3 10 3)
trace: (sum-ints-aux 4 10 6)
trace: (sum-ints-aux 5 10 10)
trace: (sum-ints-aux 6 10 15)
trace: (sum-ints-aux 7 10 21)
trace: (sum-ints-aux 8 10 28)
trace: (sum-ints-aux 9 10 36)
trace: (sum-ints-aux 10 10 45)
trace: (sum-ints-aux 11 10 55)
trace: 55
> 

;; It can also be implemented in this way:
;; 
(define (sum-ints-safe a b)
    (define (sum-ints-aux a b acc)
        (if (> a b)
            acc
            (sum-ints-aux (+ a 1) b (+ a acc))))    
    (sum-ints-aux a b 0))

> (sum-ints-safe 1 10000)
$7 = 50005000

>  (sum-ints-safe 1 100000)
$8 = 5000050000
scheme@(guile-user)> 


#+END_SRC

Example: Implementing map with tail recursion. 

#+BEGIN_SRC scheme 

(define (map2 f xs)
   (if (null? xs)
       '() 
        (cons  (f (car xs)) 
               (map2 f (cdr xs)))))


(define (inc x) (+ x 1))


;; It will eventually lead to an stack overflow for a big list. 
;;
> ,trace (map2 inc '(1 2 3))
trace: |  (#<procedure 9e14500> #(#<directory (guile-user) 984c630> â€¦))
trace: |  #(#<directory (guile-user) 984c630> map2 inc (1 2 3))
trace: (#<procedure 9e48360 at <current input>:109:7 ()>)
trace: (map2 #<procedure inc (x)> (1 2 3))
trace: |  (inc 1)
trace: |  2
trace: |  (map2 #<procedure inc (x)> (2 3))
trace: |  |  (inc 2)
trace: |  |  3
trace: |  |  (map2 #<procedure inc (x)> (3))
trace: |  |  |  (inc 3)
trace: |  |  |  4
trace: |  |  |  (map2 #<procedure inc (x)> ())
trace: |  |  |  ()
trace: |  |  (4)
trace: |  (3 4)
trace: (2 3 4)



,trace (map2 inc '(1 2 3 4 5 6 7 8 9))
trace: |  (#<procedure 9cdcb00> #(#<directory (guile-user) 984c630> â€¦))
trace: |  #(#<directory (guile-user) 984c630> map2 inc (1 2 3 4 5 6 â€¦))
trace: (#<procedure 9ceebf0 at <current input>:104:7 ()>)
trace: (map2 #<procedure inc (x)> (1 2 3 4 5 6 7 8 9))
trace: |  (inc 1)
trace: |  2
trace: |  (map2 #<procedure inc (x)> (2 3 4 5 6 7 8 9))
trace: |  |  (inc 2)
trace: |  |  3
trace: |  |  (map2 #<procedure inc (x)> (3 4 5 6 7 8 9))
trace: |  |  |  (inc 3)
trace: |  |  |  4
trace: |  |  |  (map2 #<procedure inc (x)> (4 5 6 7 8 9))
trace: |  |  |  |  (inc 4)
trace: |  |  |  |  5
trace: |  |  |  |  (map2 #<procedure inc (x)> (5 6 7 8 9))
trace: |  |  |  |  |  (inc 5)
trace: |  |  |  |  |  6
trace: |  |  |  |  |  (map2 #<procedure inc (x)> (6 7 8 9))
trace: |  |  |  |  |  |  (inc 6)
trace: |  |  |  |  |  |  7
trace: |  |  |  |  |  |  (map2 #<procedure inc (x)> (7 8 9))
trace: |  |  |  |  |  |  |  (inc 7)
trace: |  |  |  |  |  |  |  8
trace: |  |  |  |  |  |  |  (map2 #<procedure inc (x)> (8 9))
trace: |  |  |  |  |  |  |  |  (inc 8)
trace: |  |  |  |  |  |  |  |  9
trace: |  |  |  |  |  |  |  |  (map2 #<procedure inc (x)> (9))
trace: |  |  |  |  |  |  |  |  |  (inc 9)
trace: |  |  |  |  |  |  |  |  |  10
trace: |  |  |  |  |  |  |  |  |  (map2 #<procedure inc (x)> ())
trace: |  |  |  |  |  |  |  |  |  ()
trace: |  |  |  |  |  |  |  |  (10)
trace: |  |  |  |  |  |  |  (9 10)
trace: |  |  |  |  |  |  (8 9 10)
trace: |  |  |  |  |  (7 8 9 10)
trace: |  |  |  |  (6 7 8 9 10)
trace: |  |  |  (5 6 7 8 9 10)
trace: |  |  (4 5 6 7 8 9 10)
trace: |  (3 4 5 6 7 8 9 10)
trace: (2 3 4 5 6 7 8 9 10)


(define (map-aux f xs acc) 

    (if (null? xs)

        (reverse acc)

        (map-aux f 
                 (cdr xs)
                 (cons (f (car xs)) 
                       acc)
        )
      )
     ) 
 
> ,trace (map-aux inc '(1 2 3 4 5) '())
trace: |  (#<procedure 9e0c420> #(#<directory (guile-user) 984c630> â€¦))
trace: |  #(#<directory (guile-user) 984c630> map-aux inc (1 2 3 4 5))
trace: (#<procedure 9e4c070 at <current input>:180:7 ()>)
trace: (map-aux #<procedure inc (x)> (1 2 3 4 5) ())
trace: |  (inc 1)
trace: |  2
trace: (map-aux #<procedure inc (x)> (2 3 4 5) (2))
trace: |  (inc 2)
trace: |  3
trace: (map-aux #<procedure inc (x)> (3 4 5) (3 2))
trace: |  (inc 3)
trace: |  4
trace: (map-aux #<procedure inc (x)> (4 5) (4 3 2))
trace: |  (inc 4)
trace: |  5
trace: (map-aux #<procedure inc (x)> (5) (5 4 3 2))
trace: |  (inc 5)
trace: |  6
trace: (map-aux #<procedure inc (x)> () (6 5 4 3 2))
trace: (reverse (6 5 4 3 2))
trace: (2 3 4 5 6)

;; Finally 
;; 

(define (map-safe f xs)
        (map-aux f xs '()))

> (map-safe inc '(1 2 3 3 4 5))
$14 = (2 3 4 4 5 6)
#+END_SRC

Example in F#:

#+BEGIN_SRC fsharp
> let inc x = x +  1 ;;

val inc : x:int -> int

let rec map_aux f xs acc =
    match xs with 
    | []    ->  List.rev acc 
    | hd::tl ->  map_aux f tl ((f hd)::acc)
;;

val map_aux : f:('a -> 'b) -> xs:'a list -> acc:'b list -> 'b list

> map_aux inc [1; 2; 3; 4; 5] [] ;;
val it : int list = [2; 3; 4; 5; 6]

let map2 f xs = 
    map_aux f xs [] ;;

val map2 : f:('a -> 'b) -> xs:'a list -> 'b list

> map2 inc [1; 2; 3; 4; 5] ;;
val it : int list = [2; 3; 4; 5; 6]
> 

//  map_aux without pattern matching 
// 
let rec map_aux f xs acc =
    if List.isEmpty xs 
    then  List.rev acc 
    else (let hd, tl = (List.head xs, List.tail xs) in 
        map_aux f tl ((f hd)::acc))
;;

val map_aux : f:('a -> 'b) -> xs:'a list -> acc:'b list -> 'b list

>  map2 inc [1; 2; 3; 4; 5] ;;
val it : int list = [2; 3; 4; 5; 6]
> 

//  Another way:
//  
//
let map3  f xs = 
  
    let rec map_aux f xs acc =
        match xs with 
        | []    ->  List.rev acc 
        | hd::tl ->  map_aux f tl ((f hd)::acc)
    
    in map_aux f xs [] 

;;

val map3 : f:('a -> 'b) -> xs:'a list -> 'b list

> map3 inc [1; 2; 3; 4; 5; 6] ;;
val it : int list = [2; 3; 4; 5; 6; 7]
> 

#+END_SRC

Example: Tail recursive filter function.

#+BEGIN_SRC fsharp 

let rec filter_aux f xs acc = 
    match xs with 
    | []      ->  List.rev acc 
    | hd::tl  ->  if (f hd) 
                  then  filter_aux f tl (hd::acc)
                  else  filter_aux f tl acc
;;

val filter_aux : f:('a -> bool) -> xs:'a list -> acc:'a list -> 'a list

> filter_aux (fun x -> x % 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8] [] ;;
val it : int list = [2; 4; 6; 8]
> 

let filter f xs = 
    filter_aux f xs [] 
;;
val filter : f:('a -> bool) -> xs:'a list -> 'a list

> filter (fun x -> x % 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8] ;;    
val it : int list = [2; 4; 6; 8]
> 


#+END_SRC

*** See also 
 
 - [[https://en.wikipedia.org/wiki/Tail_call][Tail call - Wikipedia, the free encyclopedia]]

 - [[https://spin.atomicobject.com/2014/11/05/tail-call-recursion-optimization/][Optimizing Tail Call Recursion]]

 - [[http://raganwald.com/2013/03/28/trampolines-in-javascript.html][Trampolines in JavaScript]]

 - [[https://taylodl.wordpress.com/2013/06/07/functional-javascript-tail-call-optimization-and-trampolines/][Functional JavaScript â€“ Tail Call Optimization and Trampolines | @taylodl's getting IT done]]

 - [[http://stackoverflow.com/questions/3616483/why-does-the-jvm-still-not-support-tail-call-optimization][java - Why does the JVM still not support tail-call optimization? - Stack Overflow]]

 - [[http://scienceblogs.com/goodmath/2006/12/20/tail-recursion-iteration-in-ha-1/][Tail Recursion: Iteration in Haskell â€“ Good Math, Bad Math]]

 - [[http://everything.explained.today/Tail_call/][Tail call explained]]

 - [[http://users.dsic.upv.es/~jsilva/papers/TechReport-iter2rec.pdf][Automatic Transformation of Iterative Loops into Recursive Methods]]

 - [[http://richardminerich.com/2011/02/the-road-to-functional-programming-in-f-from-imperative-to-computation-expressions/][The Road to Functional Programming in F# â€“ From Imperative to Computation Expressions Â« Inviting Epiphany]]

 - [[https://blogs.janestreet.com/optimizing-list-map/][Optimizing List.map - Jane Street Tech Blogs]]

** Fundamental Higher Order Functions 
*** Overview 

The functions map, filter and reduce (fold left) are ubiquitous in
many programming languages and also the most used higher order
functions.

They can be stricted evaluated like in Scheme and Javascript or lazy
evaluated like in Python and Haskell.

*** Map
***** Overview 

The function map applies a function to each element of a sequence:
list, vector, hash map or dictionary and trees. 

#+BEGIN_SRC
    map :: ( a -> b) -> [a] -> [b]                
                |
                |
                |----> f :: a -> b
                
    
    
             f :: a -> b
     a   ------------------------>>>  b
    
    
           map f :: [a] -> [b]                    
    [a] ------------------------->>> [b]
    
    
#+END_SRC

***** Map in Haskell

The function map is lazy evaluated.

#+BEGIN_SRC haskell
> let fun1 x = 3 * x + 1
> fun1 2
7
> map fun1 [1, 2, 3]
[4,7,10]
> 

  -- The sequence 1 to 1000000 is not evaluated at all, 
  --
> take 10 (map fun1 [1..1000000])
[4,7,10,13,16,19,22,25,28,31]

> take 10 (map fun1 [1..10000000000])
[4,7,10,13,16,19,22,25,28,31]
> 
> 



 -- 
 -- When applied to a function without a list, it creates 
 -- another function that operates over lists because all
 -- Haskell functions are curried by default.
 --
 --         f :: (a -> b)
 --  map    :: (a -> b) -> [a] -> [b]
 --
 -- It can be seen as:
 --
 --  When map is applied to f, it will create the function fs
 --  that take list of type a and returns list of type b.
 --
 --  map    :: (a -> b) -> ([a] -> [b])
 --                |            |
 --                |            |------ fs :: [a] -> [b] 
 --                |    
 --                -------------------- f  :: a -> b 
 --
> :t map
map :: (a -> b) -> [a] -> [b]
  
> let f x = 3 * x + 6
> :t f
f :: Num a => a -> a
> 


> map f [1, 2, 3]
[9,12,15]
> 

 -- Note: let is only needed in the REPL
 --
> let fs = map f

> :t fs
fs :: [Integer] -> [Integer]

> fs [1, 2, 3]
[9,12,15]
> 
#+END_SRC

***** Map in Python

In Python 3 map and filter are lazy evaluated, they return a
generator. 

#+BEGIN_SRC python
>>> def fun1 (x):
    return 3*x + 6
... 
>>> g = map(fun1, [1, 2, 3])
>>> g
<map object at 0xb6b4a76c>
>>> next (g)
9
>>> next (g)
12
>>> next (g)
15
>>> next (g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> g
<map object at 0xb6b4a76c>
>>> 

 # Force the evaluation: 
 #
 >>> list(map(fun1, [1, 2, 3]))
 [9, 12, 15]


 # Strict Version of map
 # 
 # s_ stands for strict map.

def s_map (f, xs):
    return list(map(f, xs))
 
>>> s_map (fun1, [1, 2, 3])
[9, 12, 15]
>>> 

 # Due to python doesn't have tail call optimization
 # recusion must be avoided, a higher number of iterations
 # can lead to a stack overflow.
 
def strict_map (f, xs):
    return [f (x) for x in xs]
    
>>> strict_map (fun1, [1, 2, 3])
[9, 12, 15]
>>> strict_map (fun1, range(5))
[6, 9, 12, 15, 18]
>>> 

  # Lazy map implementation:
  # Note: the python native map is implemented in C, so
  # it is faster.
  #
  
def lazy_map (f, xs):
    for x in xs:
        yield x
        
>>> g = lazy_map (fun1, [1, 2, 3])
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> list(lazy_map (fun1, [1, 2, 3]))
[1, 2, 3]
>>>           

 #
 # To the map function work like in Haskell and ML 
 # it is need to be curried.   
 #

curry2 = lambda f: lambda x: lambda y: f(x, y)

 # The function curry2 currify a function of two arguments
 #
>>> strict_map_c = curry2(strict_map) 

>>> strict_map_c(fun1)
<function <lambda>.<locals>.<lambda>.<locals>.<lambda> at 0xb6afc0bc>

>>> strict_map_c(fun1)([1, 2, 3, 4])
[9, 12, 15, 18]
>>> 

>>> fun1_xs = strict_map_c(fun1)
>>> fun1_xs ([1, 2, 3, 4])
[9, 12, 15, 18]
>>>  
#+END_SRC

***** Map in Dynamic Typed Languages 

In dynamic typed languages like Python, Clojure and Scheme the function map
can take multiple arguments. In typed languages the function 
takes only one argument.

Map in Python:

#+BEGIN_SRC python 

>>> list(map (lambda a, b, c: 100 * a + 10 * b + c, [1, 2, 3, 4, 5], [8, 9, 10, 11, 12], [3, 4, 7, 8, 10]))
[183, 294, 407, 518, 630]
>>> 

#+END_SRC


Map in Scheme: 

#+BEGIN_SRC scheme 
(map (lambda (a b c) (+ (* 100 a) (* 10 b) c)) 
      '(1 2 3 4 5) 
      '(8 9 10 11 12) 
      '(3 4 7 8 10))

$1 = (183 294 407 518 630)
#+END_SRC

Map in Clojure:

#+BEGIN_SRC clojure

;; f a b c = 100 * a + 10 * b + c
;; 
;; 183 = f 1 8 3 
;; 294 = f 2 9 4 
;; ...
;; 630 = f 6 3 0
;;
user=> (map (fn [a b c] (+ (* 100 a) (* 10 b) c)) [1 2 3 4 5] [8 9 10 11 12] [3 4 7 8 10])
(183 294 407 518 630)
user=> 

;;
;; The clojure map is Polymorphic it can be applied to any collection 
;; of seq abstraction like lists, vectors and hash maps.
;;

;; Map applied to a list  
;;
user=> (map inc '(1 2 3 4 5 6))
(2 3 4 5 6 7)
user=> 

;; Map applied to a vector 
;;
user=> (map inc [1 2 3 4 5 6])
(2 3 4 5 6 7)
user=> 

;; Map applied to a hash map 
;;
user=> (map identity {:a 10 :b 20 :c "hello world"})
([:a 10] [:b 20] [:c "hello world"])
user=> 

;; The function mapv is similar to map, but returns a vector: 
;;
user=> (mapv identity {:a 10 :b 20 :c "hello world"})
[[:a 10] [:b 20] [:c "hello world"]]
user=> 


;; Clojure also have destructuring 
;;
user=> (map (fn [[[a b] c]] (+ (* 100 a ) (* 10 b) c))  [[[1 2] 3] [[3 4] 5] [[1 2] 4]])
(123 345 124)
user=>


#+END_SRC

*** Filter

*Python*

#+BEGIN_SRC python

 ;;; Filter returns by default a 
>>> g = filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8])
>>> g
<filter object at 0xb6b4a58c>
>>> [x for x in g]
[20, 40, 14]
>>> [x for x in g]
[]
>>> list(filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8]))
[20, 40, 14]
>>> 

  # Stritct Version of filter function
  #
>>> _filter = lambda f, xs: list(filter(f, xs))
>>> 
>>> _filter (lambda x: x > 10,  [1, 20, 3, 40, 4, 14, 8])
[20, 40, 14]
>>> 

  # Filter implementation without recursion:
  #

def strict_filter (f, xs):
    result = []
    for x in xs:
        if f(x):
            result.append(x)
    return result

def lazy_filter (f, xs):
    for x in xs:
        if f(x):
            yield x

>>> strict_filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8])
[20, 40, 14]

>>> lazy_filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8])
<generator object lazy_filter at 0xb6b0f1bc>

>>> g = lazy_filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8])
>>> g
<generator object lazy_filter at 0xb6b0f194>
>>> next(g)
20
>>> next(g)
40
>>> next(g)
14
>>> next(g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> 

>>> list(lazy_filter (lambda x: x > 10, [1, 20, 3, 40, 4, 14, 8]))
[20, 40, 14]
>>> 
  
#+END_SRC

*** Reduce or Fold
**** Overview 

*Fold Left*

The  function fold left is tail recursive, whereas the function fold
right is not. This functions is also known as reduce or inject (in
Ruby). The function fold left is often called just _fold_ like in F#
or _reduce_ (Python, Javascript, Clojure) and also Inject (Ruby).

=foldl :: (State -> x -> State) -> State -> [x] -> State=
=foldl (f :: S -> x -> S)  S [x]=


#+BEGIN_SRC
Sn = foldl f S0 [x0, x1, x2, x3 ... xn-1]

S1   = f S0 x0
S2   = f S1 x1     = f (f S0 x0) x1
S3   = f S2 x2     = f (f (f S0 x0) x1) x2
S4   = f S3 x3     = f (f (f (f S0 x0) x1) x2) x3
...
Sn-1 = f Sn-2 Xn-2 = ...
Sn   = f Sn-1 Xn-1 = f ...(f (f (f (f S0 x0) x1) x2) x3 ... xn

  ;;; -> Result
#+END_SRC


*Fold Right*

=foldr :: (x -> acc -> acc) -> acc -> [x] -> acc=

#+BEGIN_SRC 
S1   = f xn-1 S0
S2   = f xn-2 S1     = f xn-2 (f xn-1 S0)
S3   = f xn-3 S2     = f xn-3 (f xn-2 (f xn-1 S0))
S4   = f xn-4 S3     = f xn-4 (f xn-3 (f xn-2 (f xn-1 S0)))
....
Sn-1 = f x1   Sn-2   = ...
Sn   = f x0   Sn-1   = f x0 (f x1 ... (f xn-2 (f xn-1 S0)))
#+END_SRC

**** Haskell

See also: 

  * [[https://en.wikipedia.org/wiki/Fold_(higher-order_function][Fold (higher-order function) - Wikipedia, the free encyclopedia]])
  * [[http://www.cs.nott.ac.uk/~pszgmh/fold.pdf][A tutorial on the universality and expressiveness of fold. GRAHAM HUTTON]]
  * [[http://www.cantab.net/users/antoni.diller/haskell/units/unit06.html][Haskell unit 6: The higher-order fold functions | Antoni Diller]]



Fold Left:

#+BEGIN_SRC
 foldl :: (acc -> x -> acc) -> acc -> [x] -> acc
 
                  |             |      |       | 
                  |             |      |       |---> Returns the accumulated 
                  |             |      |             value
                  |             |      |----- xs 
                  |             |                  
                  |             |     Inital Value of accumulator
                  |             |---  acc0
                  |
                  |-----------------  f :: acc -> x -> acc
                                                  |
                                                  |--- Element of list 

 foldl :: (b -> a -> b) -> b -> [a] -> b
 foldl f z []     = z
 foldl f z (x:xs) = foldl f (f z x) xs
#+END_SRC


#+BEGIN_SRC haskell

> :t foldl
foldl :: (a -> b -> a) -> a -> [b] -> a
> 
> foldl (\acc x -> 10 * acc + x) 0 [1, 2, 3, 4, 5] 
12345
> 

#+END_SRC

It is equivalent to:

#+BEGIN_SRC haskell
> let f acc x = 10 * acc + x
> 
> (f 0 1)
1
> (f (f 0 1) 2)
12
> (f (f (f 0 1) 2) 3)
123
> 
> (f (f (f (f 0 1) 2) 3) 4)
1234
> (f (f (f (f (f 0 1) 2) 3) 4) 5)
12345
> 
#+END_SRC

Evaluation of Fold left:


#+BEGIN_SRC
> foldl (\acc x -> 10 * acc + x ) 0 [1, 2, 3, 4, 5]
12345

S0 = 0

f = \acc x -> 10 * acc + x

                 x  acc
S1 = f S0 x0 = f 0   1 = 10 * 0  + 1 = 1
S2 = f S1 x1 = f 10  2 = 10 * 1    + 2 = 12
S3 = f S2 x2 = f 12  3 = 10 * 12   + 3 = 123
S4 = f S3 x3 = f 123 4 = 10 * 123  + 4 = 1234
S5 = f S3 x3 = f 123 4 = 10 * 1234 + 5 = 12345
#+END_SRC



*Fold right*

#+BEGIN_SRC
 foldr :: (x -> acc -> acc) -> acc -> [x] -> acc

 foldr :: (a -> b -> b) -> b -> [a] -> b
 foldr f z []     = z
 foldr f z (x:xs) = f x (foldr f z xs)
#+END_SRC

#+BEGIN_SRC haskell
> foldr (\x acc -> 10 * acc + x) 0 [1, 2, 3, 4, 5] 
54321

> (f 0 5)
5
> (f (f 0 5) 4)
54
> (f (f (f 0 5) 4) 3)
543
> (f (f (f (f 0 5) 4) 3) 2)
5432
> (f (f (f (f (f 0 5) 4) 3) 2) 1)
54321
> 

 --
 -- Derive fold_right from foldl (fold left)
 -- 

> let fold_right f acc xs = foldl (\x acc -> f acc x) acc (reverse xs)
> 
> :t fold_right
fold_right :: (b -> a -> a) -> a -> [b] -> a
> 
> 
> fold_right (\x acc -> 10 * acc + x) 0 [1, 2, 3, 4, 5]
54321
> 


#+END_SRC

Evaluation of Fold Right:

#+BEGIN_SRC 
Example:

> foldr (\x acc -> 10 * acc + x ) 0 [1, 2, 3, 4, 5]
54321
>

f  = \x acc -> 10 * acc + x
S0 = 0
n = 5
                       x acc
S1   = f x4 S0     = f 5  0    = 10 * 0    + 5 = 5
S2   = f x3 S1     = f 4  5    = 10 * 5    + 4 = 54
S3   = f x2 S2     = f 3  54   = 10 * 54   + 3 = 543
S4   = f x1 S3     = f 2  543  = 10 * 543  + 2 = 5432
S5   = f x0 S4     = f 1  5432 = 10 * 5432 + 1 = 54321
#+END_SRC

**** Python

In Python 3 the function reduce is not default anymore, however it can
be found in the native library functools, that has a lot of built-in
functions for functional programming. The function reduce is equivalent
to Haskell function foldl (fold left) which is tail recursive.

#+BEGIN_SRC
reduce(function, sequence[, initial]) -> value

reduce :: (acc -> x -> acc) -> [x] ?acc0  -> acc
#+END_SRC

#+BEGIN_SRC python
>>> from functools import reduce
>>> 

>>> reduce (lambda acc, x: 10 *  acc + x , [1, 2, 3, 4, 5], 0)
12345
>>> 

>>> f = lambda acc, x: 10 *  acc + x
>>> 
>>> f(0, 1)
1
>>> f( f(0, 1), 2)
12
>>> f( f( f(0, 1), 2), 3)
123
>>> f( f( f( f(0, 1), 2), 3), 4)
1234
>>> f( f( f( f( f(0, 1), 2), 3), 4), 5)
12345
>>> 

def my_reduce (f, xs, acc0=None):
    "Non recursive implementation of reduce (fold_left)
     with optional initial accumulator value.
    "

    if acc0 is None:
        acc = xs[0]   
        xss = xs[1:]
    else:
        acc = acc0
        xss = xs
        
    for x in xss:
        acc = f (acc, x)
        
    return acc


>>> 
>>> my_reduce(lambda acc, x: 10 * acc + x, [1, 2, 3, 4, 5], 0)
12345
>>> my_reduce(lambda acc, x: 10 * acc + x, [1, 2, 3, 4, 5])
12345
>>> my_reduce(lambda acc, x:  acc + x, [1, 2, 3, 4, 5], 0)
15
>>> my_reduce(lambda acc, x:  acc * x, [1, 2, 3, 4, 5], 1)
120
>>> 
 
 #
 # Implementation without recursion.
 #

def fold_left (f_acc_x_to_acc, acc0, xs):
    "Haskell-like fold left function
    
    fold_left :: (acc -> x -> acc) -> acc -> [x]
    "
    acc = acc0
    
    for x in xs:
        acc = f_acc_x_to_acc (acc, x)
        
    return acc
      
>>> fold_left (lambda acc, x: 10 * acc + x, 0, [1, 2, 3, 4, 5])
12345
>>>       


def fold_right (f, acc0, xs):
    return fold_left ((lambda acc, x: f(x, acc)), acc0, reversed(xs))

>>> fold_right (lambda x, acc: 10 * acc + x, 0, [1, 2, 3, 4, 5])
54321
>>>

def fold_right2 (f, acc0, xs):
    acc = acc0
    
    for x in reversed(xs):
        acc = f(x, acc)
        
    return acc

>>> fold_right2 (lambda x, acc: 10 * acc + x, 0, [1, 2, 3, 4, 5])
54321
>>>     

#+END_SRC

*Usefulness of Fold*

Many functions and recursive algorithms can be implemented using the
fold function, including map, filter, sum, product and others.

It is based in the paper:  

   - [[http://www.cs.nott.ac.uk/~pszgmh/fold.pdf][A tutorial on the universality and expressiveness of fold. GRAHAM HUTTON]]

In the paper was used fold right, here was used fold left. 

#+BEGIN_SRC python 

def fold_left (f_acc_x_to_acc, acc0, xs):
    "Haskell-like fold left function
    
    fold_left :: (acc -> x -> acc) -> acc -> [x]
    "
    acc = acc0
    
    for x in xs:
        acc = f_acc_x_to_acc (acc, x)
        
    return acc
    
    
    ;;; Function fold in curried form 
    
curry3 = lambda f: lambda x: lambda y: lambda z: f(x, y, z)

fold = curry3(fold_left)

>>> summation = fold(lambda acc, x: acc + x)(0)
>>> 
>>> summation([1, 2, 3, 4, 5, 6])
21
>>> 

>>> product = fold(lambda acc, x: acc * x)(1)
>>> product([1, 2, 3, 4, 5])
120
>>> 

>>> f_or = fold(lambda acc, x: acc or x)(False)
>>> f_or([False, False, False])
False
>>> 
>>> f_or([False, False, True])
True
>>> 

>>> f_and = fold(lambda acc, x: acc and x)(True)
>>> 
>>> f_and([False, True, True])
False
>>> f_and([True, True, True])
True
>>> 

>>> length = fold(lambda acc, x: acc + 1)(0)
>>> length ([1, 2, 3, 4, 5])
5

>>> _map = lambda f, xs: fold(lambda acc, x: acc + [f(x)] )([])(xs)
>>> _map (lambda x: x * 3, [1, 2, 3, 4])
[3, 6, 9, 12]
>>> 

>>> _filter = lambda p, xs: fold(lambda acc, x: (acc + [x]) if p(x) else  acc )([])(xs)
>>> 
>>> _filter(lambda x: x > 10, [10, 3, 8, 2, 20, 30])
[20, 30]
>>> 


 #
 # Function composition
 # 
 #  (f3 (f2 (f1 (f0 x))))
 #
 #  (f3 . f2 . f1 . f0) x
 #
 #  or using, forward composition:
 # 
 #  (f0 >> f2 >> f1 >> f0) x
 #
 
>>> f1 = lambda x: 3 * x
>>> f2 = lambda x: 5 + x
>>> f3 = lambda x: 2 ** x


>>> _fcomp = lambda functions: lambda x: fold(lambda acc, f: f(acc)) (x) (functions)

>>> _fcomp([f1, f2, f3])(3)
16384

>>> (f3 (f2 (f1 (3))))
16384
>>>  
#+END_SRC

**** Clojure

The function reduce is similar to Haskell _fold left_ and Python
reduce. This function is Polymorphic. It works on any collection of
seq abstraction: lists, vectors and hash maps. 

Signature:

#+BEGIN_SRC 
(reduce f coll)      -> reduce :: (f :: acc -> x -> acc) -> [x]

Or 

(reduce f val coll)  -> reduce :: (f :: acc -> x -> acc) -> acc -> [x] 

f :: acc -> x -> acc 
#+END_SRC


#+BEGIN_SRC clojure

;; Applying fold/reduce to a list 
;;
;;
user=> (reduce (fn [acc x] (+ (* 10 acc) x)) 0 '(1 2 3 4 5))
12345


;; Applying fold/reduce to a vector 
;;
user=> (reduce (fn [acc x] (+ (* 10 acc) x))  0 [1 2 3 4 5])
12345
user=> 

user=> (reduce (fn [acc x] (+ (* 10 acc) x)) 0 [])
0

;; Applyind fold/reduce to a Hash map 
;;
user=> (reduce (fn [acc x] (cons x  acc )) '()  { :a 10 :b 20 :c 30 })
([:c 30] [:b 20] [:a 10])
user=>

;; Without Initial value of accumulator it will fail on a empty list. 
;; 
user=> (reduce (fn [acc x] (+ (* 10 acc) x)) [1 2 3 4 5])
12345

user=> (reduce (fn [acc x] (+ (* 10 acc) x)) [])
ArityException Wrong number of args (0) passed to: user/eval44/fn--45  clojure.lang.AFn.throwArity (AFn.java:429)
user=> 

;; Implementing fold right  
;;
(defn foldr 
   ([f xs]       (reduce (fn [acc x] (f x acc))     (reverse xs)))
   ([f acc xs]   (reduce (fn [acc x] (f x acc)) acc (reverse xs)))
  )

user=> (foldr (fn [x acc] (+ (* 10 acc) x)) 0 [1 2 3 4 5])
54321


;; Clojure has destructuring 
;;
user=> (reduce (fn [acc [a b]] (conj acc (+ (* 10 a) b) )) '[] [[1 2] [3 4] [5 8]] )
[12 34 58]
user=> 

;; Implementing map with fold left (reduce)
;;
user=> (defn map2 [f xs] 
          (reverse (reduce (fn [acc x] (cons (f x) acc)) 
                        () 
                        xs)))
#'user/map2
user=> 
user=> (map2 inc '(1 2 3 3 4 5))
(2 3 4 4 5 6)
user=> 

;; Implementing map with fold right 
;;
;;

(defn map2 [f xs] 
   (foldr (fn [x acc] (cons (f x) acc)) 
          ()
          xs
   ))

user=> (map2 inc '(1 2 3 4 5 6))
(2 3 4 5 6 7)
user=> 


#+END_SRC 

**** Fsharp 

#+BEGIN_SRC fsharp 
// Fold left for Lists 
//
//

// List.fold (acc -> 'x -> 'acc) -> acc -> 'x list -> 'acc
//
- List.fold ;;  
val it : (('a -> 'b -> 'a) -> 'a -> 'b list -> 'a) 

- List.fold (fun acc x -> 10 * acc + x) 0 [1; 2; 3; 4; 5]  ;;
val it : int = 12345
>

// Array.fold 
// 
//
- Array.fold ;;  
val it : (('a -> 'b -> 'a) -> 'a -> 'b [] -> 'a) 
> 

- Array.fold (fun acc x -> 10 * acc + x) 0 [| 1; 2; 3; 4; 5 |]  ;;
val it : int = 12345
> 

// Fold left for Arrays 

#+END_SRC


Example: Implementing Higher Order Functions and recursive functions
with fold.

#+BEGIN_SRC fsharp 

// Implementing fold_left for lists 
//
let rec fold_left f xs acc =
    match xs with 
    | []      ->   acc 
    | hd::tl  ->   fold_left f tl (f acc hd)
;;

val fold_left : f:('a -> 'b -> 'a) -> xs:'b list -> acc:'a -> 'a

- fold_left (fun acc x -> 10 * acc + x) [1; 2; 3; 4 ; 5] 0 ;; 
val it : int = 12345
> 

let length xs = fold_left (fun acc x -> acc + 1) xs 0

> length ["a"; "b"; "c"; "d" ] ;;
val it : int = 4
> length [ ] ;;                  
val it : int = 0
> 

- let sum xs  = fold_left (fun acc x -> acc + x) xs 0 ;;

> sum [1; 2; 3; 4; 5; 6] ;;                             
val it : int = 21
> 

> let product xs = fold_left (fun acc x -> acc * x) xs 1 ;;  

val product : xs:int list -> int

> product [1; 2; 3; 4; 5; 6] ;;
val it : int = 720
> 

- let reverse xs = fold_left (fun acc x -> x :: acc) xs []
- ;;

val reverse : xs:'a list -> 'a list

> reverse [1; 2; 3; 4; 5 ] ;;
val it : int list = [5; 4; 3; 2; 1]
> 

let fold_right f xs acc =
  fold_left (fun acc x -> f x acc) (reverse xs) acc
;;
     
val fold_right : f:('a -> 'b -> 'b) -> xs:'a list -> acc:'b -> 'b

- fold_right (fun x acc -> 10 * acc + x) [1; 2; 3; 4; 5] 0 ;;
val it : int = 54321
> 

// Reverse map 
//
- let rev_map f xs = fold_left (fun acc x -> (f x)::acc) xs [] ;;  

val rev_map : f:('a -> 'b) -> xs:'a list -> 'b list

- rev_map (fun x -> x * 2) [1; 2; 3; 4; 5; 6] ;;
val it : int list = [12; 10; 8; 6; 4; 2]
> 

- let map f xs = reverse ( fold_left (fun acc x -> (f x)::acc) xs [] ) ;;

val map : f:('a -> 'b) -> xs:'a list -> 'b list

- map (fun x -> x * 2) [1; 2; 3; 4; 5; 6] ;;
val it : int list = [2; 4; 6; 8; 10; 12]
> 

// Or 
// 
let rev_fold_left f  xs acc = reverse (fold_left f xs acc) ;;

val rev_fold_left :
  f:('a list -> 'b -> 'a list) -> xs:'b list -> acc:'a list -> 'a list

// Map with fold left and reverse 
//
//
> let map f xs = rev_fold_left (fun acc x -> (f x)::acc) xs [] ;;

val map : f:('a -> 'b) -> xs:'b list -> 'b list

- map (fun x -> x * 2) [1; 2; 3; 4; 5; 6] ;;
val it : int list = [2; 4; 6; 8; 10; 12]
> 

// Map with fold right 
//
> let map f xs = fold_right (fun x acc -> (f x)::acc) xs [] ;;

val map : f:('a -> 'b) -> xs:'a list -> 'b list

> map (fun x -> x * 2) [1; 2; 3; 4; 5; 6] ;;
val it : int list = [2; 4; 6; 8; 10; 12]
> 

// Filter with fold left and reverse
//
let filter f xs = rev_fold_left (fun acc x -> if (f x) then (x::acc) else acc) xs [] ;;

val filter : f:('a -> bool) -> xs:'a list -> 'a list

- filter (fun x -> x % 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8; 9 ] ;; 
val it : int list = [2; 4; 6; 8]
> 

// Filter with fold right 
//
let filter f xs =
  fold_right (fun x acc ->  if (f x)
                            then x::acc
                            else acc
             )
             xs
             []
             ;;

-  filter (fun x -> x % 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8; 9 ] ;; 
val it : int list = [2; 4; 6; 8]
> 



let take n xs =
  let _, result = 
    fold_left (fun acc x -> let (c, xss) = acc in
                            if c = 0
                            then  (0, xss)
                            else  (c - 1, x::xss))
              xs
              (n, [])

  in reverse result 

            ;;

- take ;;
val it : (int -> 'a list -> 'a list) = <fun:clo@202-3>
> 


> take 3 [1; 2; 3 ; 4; 5; 6; 7; 8] ;;               
val it : int list = [1; 2; 3]
> 

- take 18 [1; 2; 3 ; 4; 5; 6; 7; 8] ;;
val it : int list = [1; 2; 3; 4; 5; 6; 7; 8]
> 

// drop with fold left 
// 
let drop n xs =
  let _, result = 
    fold_left (fun acc x -> let (c, xss) = acc in
                            if c = 0
                            then  (0, x::xss)
                            else  (c - 1, xss))
              xs
              (n, [])

  in reverse result 

            ;;

val drop : n:int -> xs:'a list -> 'a list


- drop 3 [1; 2; 3 ; 4; 5; 6; 7; 8] ;;              
val it : int list = [4; 5; 6; 7; 8]
> 
- drop 13 [1; 2; 3 ; 4; 5; 6; 7; 8] ;;
val it : int list = []
> 

let take_while f xs =
  fold_right   (fun x acc ->  if (f x)
                              then  x::acc
                              else  acc )

               xs
               []
;;


let take_while f xs =
  fold_right   (fun x acc ->  if (f x)
                              then  x::acc
                              else  match acc with
                                    |  []     -> []
                                    |  _::tl -> tl
               )

               xs
               []
;;
val take_while : f:('a -> bool) -> xs:'a list -> 'a list

> take_while (fun x -> x < 10) [2; 8 ; 9 ; 26 ; 7; 10; 53] ;;
val it : int list = [2; 8; 9]
> 



let find f xs =
  fold_left (fun acc x -> if (f x)
                          then Some x
                          else None 
            )
            xs
            None
;;
  
val find : f:('a -> bool) -> xs:'a list -> 'a option

- find (fun x -> x * x > 40) [1; 2; 6; 5; 4; 8; 10; 20 ; 9 ] ;;
val it : int option = Some 9
> 

- find (fun x -> x * x > 400) [1; 2; 6; 5; 4; 8; 10; 20 ; 9 ] ;;
val it : int option = None
> 


// Map with side-effect 
//
let for_each f xs =
  fold_left (fun acc x -> f x)
            xs
            ()
            ;;

val for_each : f:('a -> unit) -> xs:'a list -> unit

> for_each (fun x -> printfn "x = %d" x) [2; 3; 4; 5; 6] ;;
x = 2
x = 3
x = 4
x = 5
x = 6
val it : unit = ()
> 

// Filter map - fusion / optimization  
//
// (Eliminate intermediate data structure )
//

let filter_map f_filter f_map xs = 
  fold_right (fun x acc ->  if (f_filter x)
                            then (f_map x)::acc
                            else acc
             )
             xs
             []
;;
             
val filter_map :
  f_filter:('a -> bool) -> f_map:('a -> 'b) -> xs:'a list -> 'b list

- filter_map (fun x -> x % 2 = 0) (fun x -> x + 3) [1; 5; 2; 6; 8; 7]
- ;;             
val it : int list = [5; 9; 11]
> 


 // Without optimization
- map (fun x -> x + 3) (filter (fun x -> x % 2 = 0) [1; 5; 2; 6; 8; 7]) ;;
val it : int list = [5; 9; 11]
> 
- 


#+END_SRC

*** For Each, Impure map 

For each is an _impure higher order function_ which performs
side-effect on each element of a list, array or sequence. Unlike map
this function neither have a standard name or return anything.

*Scheme*

#+BEGIN_SRC scheme
> (for-each (lambda (i) (display i) (newline))  '(1 2 3 4 5 6))
1
2
3
4
5
6
>

> (for-each
   (lambda (a b c)
      (display a) (display b) (display c)
      (newline)
    )
   '(a b c d e f)
   '(1 2 3 4 5 6)
   '("x" "y" "z" "w" "h" "k"))
a1x
b2y
c3z
d4w
e5h
f6k


#+END_SRC

*Common Lisp*

#+BEGIN_SRC lisp
> (mapc #'print '(1 2 3 3 4))

1
2
3
3
4

#+END_SRC

*Scala*

#+BEGIN_SRC scala 
scala> var xs = List(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)
xs: List[Double] = List(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)

scala> xs.foreach(println)
1.0
2.0
3.0
4.0
5.0
6.0

scala> xs.foreach(x => println( "x = %.3f".format(x)))
x = 1,000
x = 2,000
x = 3,000
x = 4,000
x = 5,000
x = 6,000
#+END_SRC

*Ocaml*

#+BEGIN_SRC
> List.iter ;;
- : ('a -> unit) -> 'a list -> unit = <fun>

> List.iter (fun x -> print_int x ; print_string "\n") [1 ; 2; 3; 4; 5] ;;
1
2
3
4
5
- : unit = ()
#+END_SRC


*F#*

#+BEGIN_SRC
> List.iter ;;
val it : (('a -> unit) -> 'a list -> unit) = <fun:clo@1>

> List.iter (fun x -> printfn "x = %d" x) [1; 2; 3; 4; 5] ;;
x = 1
x = 2
x = 3
x = 4
x = 5
val it : unit = ()
>

> List.iter2 ;;
val it : (('a -> 'b -> unit) -> 'a list -> 'b list -> unit) = <fun:clo@1>
> 

- List.iter2 (fun a b -> printfn "a = %d b = %d" a b) [2; 3; 4; 5] [1; 2; 3; 4] - ;;
a = 2 b = 1
a = 3 b = 2
a = 4 b = 3
a = 5 b = 4
val it : unit = ()
> 

- Array.iter ;; 
val it : (('a -> unit) -> 'a [] -> unit) = <fun:it@6-4>
> 
- 

- Array.iter (fun x -> printfn "x = %d" x) [| 1; 2; 3; 4 |] ;;
x = 1
x = 2
x = 3
x = 4
val it : unit = ()
> 

#+END_SRC

*Python*

This function is not in Python standard library however, it can be
defined as this.

#+BEGIN_SRC python
def for_each(f, * xss):
    for xs in zip(* xss):
        f(*xs)

>>> for_each (print, [1, 2, 4, 5, 6])
1
2
4
5
6

>>> for_each (lambda a, b: print (a, b), [1, 2, 3, 4, 5, 6], ["a", "b", "c", "d", "e", "f"])
1 a
2 b
3 c
4 d
5 e
6 f

#+END_SRC

*Clojure* 

#+BEGIN_SRC clojure 

user=> (defn f [a b] (println (format "a = %s , b = %s" a b)))
#'user/f


(defn for-each [f & xss]
   (doseq [args (apply map vector xss)]  (apply f args)))


user=> (for-each println [1 2 3 4])
1
2
3
4
nil


user=> (for-each f [1 2 3 4] [3 4 5 6])
a = 1 , b = 3
a = 2 , b = 4
a = 3 , b = 5
a = 4 , b = 6
nil
user=> 

#+END_SRC
 
*** Apply 

The function _apply_ applies a function to a list or array of
arguments. It is common in dynamic languages like Lisp, Scheme,
Clojure, Javascript and Python.

See also: [[https://en.wikipedia.org/w/index.php?title%3DApply&oldid%3D674998740][Apply Higher Oder Function - Wikipedia]]

Example:

*Scheme*

#+BEGIN_SRC scheme 

> (define (f1 x y z) (+ (* 2 x) (* 3 y) z))

> (apply f1 '(1 2 3))
$1 = 11

> (apply f1 1 2 '(3))
$2 = 11

> (apply f1 1 '(2 3))
$3 = 11

> (apply + '(1 2 3 4 5))
$1 = 15

;;; The function apply can be used to transform a function of
;;; multiple arguments into a function of a single argument that
;;; takes a list of arguments
;;;

(define (f-apply f) 
   (lambda (xs) (apply f xs)))

> (map (f-apply f1) '((1 2 3) (3 4 5) (6 7 8)) )
$2 = (11 23 41)

;;  It can be also used to create a function that  maps a function 
;;  of multiple arguments over a list of arguments.
;;
(define (map-apply f xss)
   (map (lambda (xs) (apply f xs)) xss))

> (map-apply f1  '((1 2 3) (3 4 5) (6 7 8)))
$1 = (11 23 41)

#+END_SRC

*Clojure*

#+BEGIN_SRC clojure

user=> (defn f1 [x y z] (+ (* 2 x) (* 3 y) z))
#'user/f1
user=> 

;; The higher order function apply is polymorphic.
;;
user=> (apply f1 '(1 2 3))
11
user=> (apply f1 [1 2 3])
11
user=> (apply f1 1 [2 3])
11
user=> (apply f1 1 2 [ 3])
11
user=> (apply f1 1 2 3 [ ])
11

user=> (apply + [1 2 3 4 5])
15

user=> (defn map-apply [f xss]
              (map (fn [xs] (apply f xs)) xss))
#'user/map-apply
user=> 


user=> (map-apply f1 [[1 2 3] [3 4 5] [6 7 8]])
(11 23 41)
user=> 
#+END_SRC

*Python*

#+BEGIN_SRC python

# In Python the * asterisk notation is used to expand
# a list into function arguments.
#
>>> f1 = lambda x, y, z: 2 * x + 3 * y + z
>>> 
>>> f1(1, 2, 3)
11
>>> f1(*[1, 2, 3])
11
>>> 

>>> def apply (f, xs): return f(*xs)
... 
>>> 

>>> apply (f1, [1, 2, 3])
11


#
# The function apply can also be defined  as:
#

def apply2 (f, * args):    
    return f(*(tuple(args[:-1]) + tuple(args[-1])))
    
>>> apply2 (f1, [1, 2, 3])
11
>>> apply2 (f1, 1, [2, 3])
11
>>> apply2 (f1, 1, 2, [3])
11
>>> apply2 (f1, 1, 2, 3, [])
11
>>> 

>>> f_apply = lambda f: lambda xs: f(*xs)
>>> 

>>> list(map (f_apply(f1), [[1, 2, 3], [3, 4, 5], [6, 7, 8]]))
[11, 23, 41]
>>> 

def map_apply (f, xss):
    return map(lambda xs: f(*xs), xss)

>>> map_apply(f1, [[1, 2, 3], [3, 4, 5], [6, 7, 8]])
<map object at 0xb6daaaac>
>>> 
>>> list(map_apply(f1, [[1, 2, 3], [3, 4, 5], [6, 7, 8]]))
[11, 23, 41]
>>> 


#+END_SRC

** Function Composition 
*** Overview

Function composition promotes shorter code, code reuse and higher
modularity by creating new functions from previous defined ones. They
also allow optimization of functional code when there is many
maps. Only pure functions can be composed, function composition works
like math functions, the output of one function is the input of
another function.  Haskell, ML, Ocaml and F# has features that makes
easier to use function composition, like a lightweight syntax,
currying, partially applied functions, static typing and composition
operators that are built in to the language.  In Haskell the operator
(.) dot is used for composing functions.

See also: [[http://en.wikipedia.org/wiki/Function_composition_%28computer_science%29][Function composition (computer science)]]

*** Function Composition in Haskell

#+BEGIN_SRC
(.) :: (b -> c) -> (a -> b) -> a -> c

Given:
    
    f :: b -> c
    g :: a -> b

(f . g ) x = f (g x)

    h = f . g
    h :: a -> c
#+END_SRC

Function Composition Block Diagram

#+BEGIN_SRC haskell
                f . g
        ................................
        . /------\        /------\     . 
a -->   . |  g   |  -->   |  f   | --> .---> c
        . \------/   b    \------/  c  . 
        ................................
           g :: a -> b   f :: b -> c
    
    (.) :: (b -> c) -> (a -> b) -> a -> c
#+END_SRC


Composition Law

#+BEGIN_SRC
id . f = f                  Left  identity law
f . id = f                  Right identity law
(f . g) . h = f . (g . h)   Associativity


Constant Function Composition
f       . const a = const (f a)
const a . f       = const a

dentity function            -->  id x = x 
const - Constant Function   --> const a b =  a   
#+END_SRC

Simplifying Code with function composition:

#+BEGIN_SRC
    h( f ( g( x)))  ==>  (h . f . g ) x   OR  h . f . g  $ x 
OR   
    h $ f $ g x     ==>   h . f . g $ x    

                                 Point Free Style
composed x = h . f . g $ x ==>   composed = h . f . g 
#+END_SRC

Function Composition with Map


#+BEGIN_SRC  
    (map g (map f xs) == (map g . map f) xs = (map g . f) xs

OR
    map g . map f  == map (g . f)
        
Generalizing
    
    map f1 (map f2 (map f3 (map f4 xs))) 
    = (map f1)
    =  map (f1 . f2 . f3 . f4)  xs     
    =  f xs
    
Where f = map $ f1 . f2 . f3 . f4

Example:

    > map  (+3) [1, 2, 3, 4]
    [4,5,6,7]
    > map  (*2) [4, 5, 6, 7]
    [8,10,12,14]
    > 
    > map  (*2) (map (+3)  [1, 2, 3, 4])
    [8,10,12,14]
    > 
    > map  (*2) . map (+3) $  [1, 2, 3, 4]
    [8,10,12,14]
    > 

    > map ((*2) . (+3)) [1, 2, 3, 4]
    [8,10,12,14]

    > let f = map $ (*2) . (+3)
    > f [1, 2, 3, 4]
    [8,10,12,14]

#+END_SRC


#+BEGIN_SRC
h :: c -> [a]
f :: a -> b

map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]


map     f (h c) = map    f . h $ c
filter  f (h c) = filter f . h $ c
#+END_SRC

Inverting Predicate Functions

#+BEGIN_SRC
inverted_predicate == not . predicate
#+END_SRC

#+BEGIN_SRC haskell
> not True
False
> not False
True
> 

> (>5) 10
True
> (>5) 3
False

> not . (>5) $ 10
False
> not . (>5) $ 3
True
> 

> let f = not . (>5)
> f 10
False
> f 5
True

> import Data.List
> 
> filter ( isPrefixOf "a" ) ["a","ab","cd","abcd","xyz"]
["a","ab","abcd"]
> 
> filter ( not . isPrefixOf "a" ) ["a","ab","cd","abcd","xyz"]
["cd","xyz"]
> 


#+END_SRC


Example:

#+BEGIN_SRC haskell
> let f = (+4)
> let g = (*3)
> 
> 
> f (g 6) -- (+4) ((*3) 6) = (+4) 18 = 22
22
> 
> (f . g) 6
22
> 
> (.) f g 6
22
> 
> let h = f . g
> 
> h 6
22
>  

> id 10
10
> id 3
3
> 
> id Nothing
Nothing
> id 'a'
'a'
> id (Just 10)
Just 10
> 


> (f . id) 10
14
> (id . f) 10
14
> 

> const 10 20
10
> const 10 3
10
> 

> (f . (const 10)) 4
14
> (f . (const 10)) 3
14
> const 10 . f $ 7
10
> const 10 . f $ 3
10
> 

{- Avoiding Parenthesis with composition -}
> let g x = x * 2
> let f x = x + 10
> let h x = x - 5
> 
> h (f (g 3))
11
> h $ f $ g 3
11
> 
> (h . f . g ) 3
11
> h . f . g $ 3
11
> 

{- Function Composition with curried functions -}

> let f1 x y = 10*x + 4*y
> let f2 a b c = 4*a -3*b + 2*c
> let f3 x = 3*x

> (f1 3 ( f3 5))
90
> 
> f1 3 $ f3 5
90
> 
> f1 3 . f3 $ 5
90
> 
> let f = f1 3 . f3 
> 
> f 5
90
> f 8
126
> 


> (f1 4 (f2 5 6 (f3 5)))
168
> 
> f1 4 $ f2 5 6 $ f3 5
168
> 
> f1 4 . f2 5 6 . f3 $ 5
168
> 
> let g = f1 4 . f2 5 6 . f3 {- You can also create new functions -}
> :t g
g :: Integer -> Integer
> g 5
168
> g 10
288
> 

{- Function Composition with Map and Filter -}

> import Data.Char

> :t ord
ord :: Char -> Int

> :t ordStr
ordStr :: [Char] -> [Int]
> 

> ordStr "curry"
[99,117,114,114,121]
> 
> let r x= x + 30
> 
> map r (ordStr "curry")
[129,147,144,144,151]
> 
> map r $ ordStr "curry"
[129,147,144,144,151]
> 
> map r . ordStr $ "curry"
[129,147,144,144,151]
> 
> sum . map r . ordStr $ "curry"
715
> 

> let s =  map r . ordStr
> s "curry"
[129,147,144,144,151]
> s "haskell"
[134,127,145,137,131,138,138]
> 

let sum_ord = sum . map r . ordStr 

> sum_s "curry"
715
> sum_s "haskell"
950
> 
> sum_ord "curry"
715
> sum_ord "haskell"
950
> 


> map ord (map toUpper "haskell")
[72,65,83,75,69,76,76]
> 
> map ord . map toUpper $ "haskell"
[72,65,83,75,69,76,76]
> 

> map (flip (-) 10) . map ord . map toUpper $ "haskell"
[62,55,73,65,59,66,66]
> 

> map chr . map (flip (-) 10) . map ord . map toUpper $ "haskell"
">7IA;BB"
> 

{- The function f is in point free style -}

> let f = map chr . map (flip (-) 10) . map ord . map toUpper
> 
> f "haskell"
">7IA;BB"
> 

#+END_SRC

*** Function Composition in Python

#+BEGIN_SRC python

def compose(funclist):   
    
    def _(x):
        y = x 
        
        for f in reversed(funclist):
            y = f(y)
        return y
    
    return _

>>> add10 = lambda x: x + 10

>>> mul3 = lambda x: x * 3

>>> x = 3
>>> a = add10(x)
>>> a
    13
>>> b = mul3(a)
>>> b
    39


>>> def f_without_composition (x):
 ...    a = add10(x)
 ...    b = mul3(a)
 ...    return b
 ...

>>> f_without_composition(3)
    39

>>> f_without_composition(4)
    42

 # It will create the function f = (mul3 Â° add10)(x)
 # The flow is from right to left
 #
 #                   
 #     (mul3 . add10) 3 
 #   =  mul3 (add10 3) 
 #   =  mul3 13 
 #   =  39 
 #
>>> f = compose ([mul3, add10])  

>>> f(3)
    39

>>> f(4)
    42

>>> f
    <function __main__.compose.<locals>._>

>>> compose ([add10, mul3])(3)
    39

>>> compose ([add10, mul3])(4)
    42

 #
 # Composition is more intuitive when the flow is from
 # left to right, the functions in the left side are
 # executed first. 
 #
 #

 # Compose Forward
def composef (funclist):   
    
    def _(x):
        y = x         
        for f in funclist:
            y = f(y)
        return y
    
    return _

 #
 #   The symbol (>>) from F# will be used to mean forward composition
 #   here
 #
 #      (add10 >> mul3) 3 
 #    = mul3 (add10 3) 
 #    = mul3 13 
 #    = 39
 #                          add10 >> mul3
 #    Input  .................................................  Output
 #           .    |----------|           |---------|         .   39
 #   3  ---> .--> |  add10   | --------> |   mul3  | ------->.  ------->  
 #           .  3 |----------| 13 =(10+3)|---------|  39     .
 #           .                                39 = 3 * 13    .
 #           .................................................        
 #       
 #  The execution flow is from left to right, in the same order as the
 #  functions are written in the code.
 #
 
>>> g = composef ([add10, mul3])

>>> g(3)
    39

>>> g(4)
    42


>>> ### A more useful example: parse the following table:

text = """
 12.23,30.23,892.2323
 23.23,90.23,1000.23
 3563.23,100.23,45.23

"""



 # Unfortunately Python, don't have a favorable syntax to function 
 # composition like: composition operator, lightweight lambda and function
 # application without parenthesis.
 #

>>> mapl = lambda f: lambda xs: list(map(f, xs))
>>> filterl = lambda f: lambda xs: list(filter(f, xs))


>>> splitlines = lambda s: s.splitlines()
>>> reject_empty = lambda xs: list(filter(lambda x: x, xs))
>>> strip = lambda s: s.strip()
>>> split = lambda sep: lambda s: s.split(sep)


>>> composef([splitlines])(text)
    ['',
 ' 12.23,30.23,892.2323',
 ' 23.23,90.23,1000.23',
 ' 3563.23,100.23,45.23',
 '']
 
 
>>> composef([splitlines, reject_empty])(text)
    [' 12.23,30.23,892.2323', 
    ' 23.23,90.23,1000.23', 
    ' 3563.23,100.23,45.23']

    
>>> composef([splitlines, reject_empty, mapl(strip)])(text)
    ['12.23,30.23,892.2323', '23.23,90.23,1000.23', 
    '3563.23,100.23,45.23']


>>> composef([splitlines, reject_empty, mapl(strip), mapl(split(","))])(text)
    [['12.23', '30.23', '892.2323'],
 ['23.23', '90.23', '1000.23'],
 ['3563.23', '100.23', '45.23']]

>>> composef([splitlines, reject_empty, mapl(strip), mapl(split(",")), mapl(mapl(float))])(text)
    [[12.23000, 30.23000, 892.23230],
 [23.23000, 90.23000, 1000.23000],
 [3563.23000, 100.23000, 45.23000]]

parse_csvtable =  composef(
    [splitlines, 
    reject_empty, 
    mapl(strip), 
    mapl(split(",")), 
    mapl(mapl(float))]
    )


>>> parse_csvtable(text)
    [[12.23000, 30.23000, 892.23230],
 [23.23000, 90.23000, 1000.23000],
 [3563.23000, 100.23000, 45.23000]]

    #  Notice there is three maps together, so that it can be optimized 
    #  each map is like a for loop, by composing the functions in map1,  
    #  map2 and map3 the code can be more faster.
    #
    # parse_csvtable =  composef(
    # [splitlines, 
    # reject_empty, 
    # mapl(strip),          ---> map1
    # mapl(split(",")),     ---> map2
    # mapl(mapl(float))]    ---> map3
    # )


parse_csvtable_optmized =  composef(
    [splitlines, 
    reject_empty, 
    mapl(composef([strip, split(","), mapl(float)]))
    ])
    
>>> parse_csvtable_optmized(text)
    [[12.23000, 30.23000, 892.23230],
 [23.23000, 90.23000, 1000.23000],
 [3563.23000, 100.23000, 45.23000]]

    
#+END_SRC
*** Function Composition in F#

F# uses the operator (<<) for composition which is similar to Haskell
composition operator (.) dot. It also uses the operator (>>) for forward
composition that performs the operation in the inverse order of
operator (<<).

Composition Operator (<<):

#+BEGIN_SRC fsharp
- (<<) ;;
val it : (('a -> 'b) -> ('c -> 'a) -> 'c -> 'b) 
> 

> let h x = x + 3 ;;         

val h : x:int -> int

> let g x = x * 5 ;;

val g : x:int -> int

- let m x = x - 4 ;;

val m : x:int -> int

// The composition is performed in the same way as math composition 
// from right to left. 
//
- h (g 4) ;;
val it : int = 23
> 
- 
- (h << g) 4 ;;
val it : int = 23
> 



> m (h (g 4)) ;;
val it : int = 19
> 
- (m << h << g) 4 ;;
val it : int = 19
> 

// It is the same as math composition: f(x) = m Â° h Â° g
//
- let f = m << h << g ;;

val f : (int -> int)

> f 4 ;;
val it : int = 19
> 



#+END_SRC

Forward Composition Operator (>>):

#+BEGIN_SRC fsharp
> (>>) ;;
val it : (('a -> 'b) -> ('b -> 'c) -> 'a -> 'c) 

> let h x = x + 3 ;;         

val h : x:int -> int

> let g x = x * 5 ;;

val g : x:int -> int

- let m x = x - 4 ;;

val m : x:int -> int


- h (g 4) ;;
val it : int = 23
> 

- (g >> h) 4 ;;
val it : int = 23
> 
- let f = g >> h ;;

val f : (int -> int)

> f 4 ;;
val it : int = 23
> 


- m (h (g 4)) ;;
val it : int = 19
> 
- 

- (g >> h >> m ) 4 ;;
val it : int = 19
> 
- 

// The argument is seen flowing from left to right, in the inverse
// order of math composition and Haskell composition operator (.) dot,
// which is more easier to read.  
//
//  (g >> h >> m) 4 => It is seen as passing through each function 
//
//   Evaluating:  g >> h >> m                    
//
//                    f =  g >> h >> m 
//       .........................................................
//       .                                                       .         
//       .   |-----------|      |-----------|     |-----------|  .
//     ----> |g = x * 5  ||---->| h = x + 3 |---->| m = x - 4 |----->
//   4   .   |-----------|  20  |-----------| 23  |-----------|  .  19 
//       .       = 4 * 5 = 20    = 20 + 3 = 23    = 23 - 4 = 19  . 
//       .........................................................
//

- let f = g >> h >> m ;;

val f : (int -> int)

> f 4 ;;
val it : int = 19
> 

#+END_SRC

F# Argument Piping operator (|>) 

#+BEGIN_SRC fsharp 
- let h x = x + 3 ;; 

val h : x:int -> int

> let g x = x * 5 ;;

val g : x:int -> int

>  let m x = x - 4 ;;

val m : x:int -> int

> 

// The piping operator feeds the function input forward. 
//
- (|>) ;;
val it : ('a -> ('a -> 'b) -> 'b) 
> 

- (g 4) ;;
val it : int = 20
> 
- 4 |> g ;;
val it : int = 20
> 

// It is the same as:  4 |> g |> h 
//
- h (g 4) ;;
val it : int = 23
>

- 4 |> g |> h ;;
val it : int = 23
> 

// It is the same as:  4 |> g |> h |> m ;; 
//
- m (h (g 4)) ;;
val it : int = 19
> 

- 4 |> g |> h |> m ;; 
val it : int = 19
> 
#+END_SRC

Example of a non numeric function composition:

#+BEGIN_SRC fsharp

let text = "
 12.23,30.23,892.2323
 23.23,90.23,1000.23
 3563.23,100.23,45.23

"

// Negate predicate. Invert a predicate function. 
//
> let neg pred = fun x -> not (pred x) ;;

val neg : pred:('a -> bool) -> x:'a -> bool



let split_string sep str =                                
    List.ofArray  (System.Text.RegularExpressions.Regex.Split (str, sep))

> let split_lines = split_string "\n" ;;

val split_lines : (string -> string list)

> let trim_string (s: string) = s.Trim() ;;              

val trim_string : s:string -> string

- let is_string_empty (s: string) = s.Length = 0 
- ;;

val is_string_emtpy : s:string -> bool

- text |> split_lines ;;       
val it : string list =
  [""; " 12.23,30.23,892.2323"; " 23.23,90.23,1000.23";
   " 3563.23,100.23,45.23"; ""; ""]
> 

- text |> split_lines |> List.filter (neg is_string_empty) ;;
val it : string list =
  [" 12.23,30.23,892.2323"; " 23.23,90.23,1000.23"; " 3563.23,100.23,45.23"]
> 

- text |> split_lines |> List.filter (neg is_string_empty) |> List.map trim_stri- ng ;;
val it : string list =
  ["12.23,30.23,892.2323"; "23.23,90.23,1000.23"; "3563.23,100.23,45.23"]
> 
- 

- text |> split_lines |> List.filter (neg is_string_empty) |> List.map trim_stri- ng |> List.map (split_string ",") ;;
val it : string list list =
  [["12.23"; "30.23"; "892.2323"]; ["23.23"; "90.23"; "1000.23"];
   ["3563.23"; "100.23"; "45.23"]]
> 
- 

- text |> split_lines |> List.filter (neg is_string_empty) |> List.map trim_stri- ng |> List.map (split_string ",") |> List.map (List.map float) ;;
val it : float list list =
  [[12.23; 30.23; 892.2323]; [23.23; 90.23; 1000.23]; [3563.23; 100.23; 45.23]]
> 

// Or in multiple lines:

text 
|> split_lines 
|> List.filter (neg is_string_empty) 
|> List.map trim_string 
|> List.map (split_string ",") 
|> List.map (List.map float) 
;;

val it : float list list =
  [[12.23; 30.23; 892.2323]; [23.23; 90.23; 1000.23]; [3563.23; 100.23; 45.23]]
> 

// Then transformed into a function: 
//
let parse_csv text =
   text
   |> split_lines 
   |> List.filter (neg is_string_empty) 
   |> List.map trim_string 
   |> List.map (split_string ",") 
   |> List.map (List.map float) 
;;

val parse_csv : text:string -> float list list

> parse_csv text ;;
val it : float list list =
  [[12.23; 30.23; 892.2323]; [23.23; 90.23; 1000.23]; [3563.23; 100.23; 45.23]]
> 
- 

// This operation can be optimized with function (forward) composition.
// 
let parse_csv2 text =
   text
   |> split_lines 
   |> List.filter (neg is_string_empty) 
   |> List.map (trim_string >> (split_string ",") >> (List.map float)) 
;;

val parse_csv2 : text:string -> float list list

> parse_csv2 text ;;
val it : float list list =
  [[12.23; 30.23; 892.2323]; [23.23; 90.23; 1000.23]; [3563.23; 100.23; 45.23]]
> 

// It could be implemented using the math compostion (<<) operator.
// in the same as in Haskell.  
// 
let parse_csv3 text =
   text
   |> split_lines 
   |> List.filter (neg is_string_empty) 
   |> List.map ((List.map float) << (split_string ",") << trim_string) 
;;

val parse_csv3 : text:string -> float list list

- parse_csv3 text ;;
val it : float list list =
  [[12.23; 30.23; 892.2323]; [23.23; 90.23; 1000.23]; [3563.23; 100.23; 45.23]]
> 

//  934.6923 = 12.23 + 30.23 + 892.2323
//
- parse_csv3 text |> List.map List.sum ;;            
val it : float list = [934.6923; 1113.69; 3708.69]
> 
- 

- parse_csv3 text |> List.map List.sum |> List.sum ;;
val it : float = 5757.0723
> 

#+END_SRC

* Functional Languages

Some Functional programming languages:

| Language     | Evaluation    | Typing  | Type Inference | Pattern Matching         | GIL | TCO | OO  | AGDT | Platform       | Family        | Currying | Feature                                  |
|--------------+---------------+---------+----------------+--------------------------+-----+-----+-----+------+----------------+---------------+----------+------------------------------------------|
| Haskell      | Lazy          | Static  | Yes            | Yes                      | No  | Yes | No  | Yes  | NAT            | ML/SML        | Yes      | Concurrency/Parallelism                  |
| Ocaml        | Strict        | Static  | Yes            | Yes                      | Yes | Yes | Yes | Yes  | NAT/BC         | ML/SML        | Yes      |                                          |
| F# (F sharp) | Strict        | Static  | Yes            | Yes                      | No  | Yes | Yes | Yes  | .NET           | ML/SML        | Yes      | .NET Integration                         |
| Scheme       | Strict        | Dynamic | No             | No                       | *   | Yes | No  | No   | -              | Lisp          | No       | Minimalist Educational                   |
| Clojure      | Strict + Lazy | Dynamic | No             | Destructuring and macros | No  | No  | No  | No   | JVM            | Lisp          | No       | Java integration + Macros                |
| Scala        | Strict        | Static  | Yes            | Yes                      | No  | Yes | Yes | Yes  | JVM            |               | Yes      | Java integration + Type safety           |
| Erlang       | Strict        | Dynamic | ?              | Yes                      | No  | No  | ?   | ?    | VM/Bytecode    |               | ?        | Telecommunications, Servers, Concurrency |
| JavaScript   | Strict        | Dynamic | No             | No                       | Yes | No  | Yes | No   | VM/Interpreted | *Lisp/ Scheme | No       | Only language that runs in the browser.  |
|              |               |         |                |                          |     |     |     |      |                |               |          |                                          |
| R            | Strict        | Dynamic | No             | No                       | ?   | No  | Yes | -    | VM/Bytecode    | *Lisp/ Scheme | No       | DSL - Statics                            |
| Mathematica  | Strict        | Dynamic | Yes            | ?                        | ?   | ??  | ?   | ?    | ?              |               | No       | DSL - Computer Algebraic System          |



Notes:

 - AGDT   - Algebraic Data Types

 - GIL    - Global Interpreter Locking. Languages with GIL cannot take
   advantage of multi-core processors.

 - TCO - Tail Call Optimization. Languages without TCO cannot perform
   recursion safely. It can lead to a stack overflow for a big number
   of iterations. 

 - JVM    - Java Virtual Machine / Java Platform

 - .NET   - Dot Net Platform

 - NAT    - Native Code

 - VM     - Virtual Machine 

 - OO     - Object Orientated

 - Currying  - Curried functions like in Haskell

 - DSL    - Domain Specific Language

 - It is controversial that Javascript is based on scheme. According
   to Douglas Crockford JavaScript is Scheme on a C clothe. With a
   C-like syntax.


More Information: [[http://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages][Comparison of Functional Programming Languages]]

See also: [[http://hyperpolyglot.org/ml][ML Dialects and Haskell: SML, OCaml, F#, Haskell]] 

* Notable People

A selection of people who influenced functional programming:

 - [[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]], Mathematician -> Lambda Calculus

 - [[https://en.wikipedia.org/wiki/Haskell_Curry][Haskell Curry]], Mathematician -> Concept of currying

 - [[https://en.wikipedia.org/wiki/Robin_Milner][Robin Milner]], Computer Scientist -> Type inference, [[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system][Hindleyâ€“Milner type system]], [[https://en.wikipedia.org/wiki/ML_(programming_language][ML language]])

 - [[https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist][John McCarthy]]),  Computer Scientist -> Creator of [[https://en.wikipedia.org/wiki/Lisp_(programming_language][Lisp]]), Artificial intelligence

    * [[http://www.infoq.com/interviews/Steele-Interviews-John-McCarthy][Guy Steele Interviews John McCarthy, Father of Lisp]]

 - [[https://en.wikipedia.org/wiki/John_Backus][John Backus]], Computer Scientist ->  Backus-Naur form (BNF), Fortran
   Language, 

    * [[https://web.stanford.edu/class/cs242/readings/backus.pdf][Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs]]

 - [[https://en.wikipedia.org/wiki/Philip_Wadler][Philip Wadler]], Theory behind functional programming and the use of
   monads in functional programming, the design of the purely
   functional language Haskell.

    * [[http://www.eliza.ch/doc/wadler92essence_of_FP.pdf][The essence of functional programing]]
    * [[http://www.infoq.com/interviews/wadler-functional-programming][Philip Wadler on Functional Programming - Interview]]

 - [[https://en.wikipedia.org/wiki/Eugenio_Moggi][Eugenio Moggi]], Professor of computer science at the University of
   Genoa, Italy. - He first described the general use of monads to
   structure programs.

    * [[http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf][Notions of computation and monads - Eugenio Moggi]]

 - [[https://en.wikipedia.org/wiki/Simon_Peyton_Jones][Simon Peyton Jones]], Computer Scientist -> Major contributor to the
   design of the Haskell programming language.

 - [[https://en.wikipedia.org/wiki/John_Hughes_(computer_scientist][John Hughes]]), Computer Scientist -> One of the most influentials
   papers in FP field: Why functional programing matters.


 - [[https://en.wikipedia.org/wiki/Gerald_Jay_Sussman][Gerald Jay Sussman]], Mathematician and Computer Scientist

   * [[https://en.wikipedia.org/wiki/Scheme_(programming_language][Scheme Lisp]]) Language
   * Book: [[https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs][Structure and Interpretation of Computer Programs]]
   * Book: [[https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Classical_Mechanics][Structure and Interpretation of Classical Mechanics]]

   * [[https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language#The_Lambda_Papers][Lambda Papers]]: A series of MIT AI Memos published between 1975
     and 1980, developing the Scheme programming language and a number
     of influential concepts in programming language design and
     implementation.

* Miscellaneous
**** Selected Wikipedia Articles

Selected Wikipedia Pages:

 - [[http://en.wikipedia.org/wiki/List_of_functional_programming_topics][List of functional programming topics]]

 - [[http://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages][Comparison of Functional Programming Languages]]
 - [[http://en.wikipedia.org/wiki/Functional_programming][Functional programming]]

 - [[http://en.wikipedia.org/wiki/Declarative_programming][Declarative programming]]
 - [[http://en.wikipedia.org/wiki/Aspect-oriented_programming][Aspect-oriented programming]]

*Functions*

First Class Functions

 - [[https://en.wikipedia.org/wiki/First-class_function][First-class function]]
 - [[https://en.wikipedia.org/wiki/Pure_function][Pure function]]
 - [[https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29][Side effect (computer science)]]
 - [[https://en.wikipedia.org/wiki/Purely_functional][Purely functional]]

 - [[https://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29][Referential transparency (computer science)]]
 - [[https://en.wikipedia.org/wiki/Function_type][Function type]]

 - [[https://en.wikipedia.org/wiki/Arity][Arity]]
 - [[https://en.wikipedia.org/wiki/Variadic_function][Variadic function]]

Composition

 - [[https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29][Function composition (computer science)]]
 - [[https://en.wikipedia.org/wiki/Function_composition][Function composition - Mathematics]]
 - [[https://en.wikipedia.org/wiki/Composability][Composability]]

 - [[https://en.wikipedia.org/wiki/Functional_decomposition][Functional decomposition]]

Scope

 - [[https://en.wikipedia.org/wiki/Scope_%28computer_science%29][Scope (computer science)]]

Currying and Partial Evaluation

 - [[https://en.wikipedia.org/wiki/Currying][Currying]]
 - [[https://en.wikipedia.org/wiki/Partial_evaluation][Partial evaluation]]

Higher Order Functions, Closures, Anonymous Functions

 - [[https://en.wikipedia.org/wiki/Anonymous_function][Anonymous function]]
 - [[https://en.wikipedia.org/wiki/Closure_%28computer_programming%29][Closure (computer programming)]]
 - [[https://en.wikipedia.org/wiki/Higher-order_function][Higher-order function]]
 - [[https://en.wikipedia.org/wiki/Fixed-point_combinator][Fixed-point combinator]]
 - [[https://en.wikipedia.org/wiki/Defunctionalization][Defunctionalization]]

 - [[http://en.wikipedia.org/wiki/Closure_(computer_programming][Closure (computer programming)]])
 - [[http://en.wikipedia.org/wiki/Callback_(computer_programming][Callback (computer programming)]])
 - [[http://en.wikipedia.org/wiki/Coroutine][Coroutine]]


Recursion

 - [[https://en.wikipedia.org/wiki/Recursion_%28computer_science%29][Recursion (computer science)]]
 - [[https://en.wikipedia.org/wiki/Tail_call][Tail call]]
 - [[https://en.wikipedia.org/wiki/Double_recursion][Double recursion]]
 - [[https://en.wikipedia.org/wiki/Primitive_recursive_function][Primitive recursive function]]


 - [[https://en.wikipedia.org/wiki/Ackermann_function][Ackermann function]]
 - [[https://en.wikipedia.org/wiki/Tak_%28function%29][Tak (function)]]


Lambda Calculus and Process Calculus

 - [[https://en.wikipedia.org/wiki/Typed_lambda_calculus][Typed lambda calculus]]
 - [[http://en.wikipedia.org/wiki/Lambda_calculus][Lambda calculus]]
 - [[https://en.wikipedia.org/wiki/Process_calculus][Process calculus]]


 - [[https://en.wikipedia.org/wiki/Futures_and_promises][Futures and promises]]
 - [[https://en.wikipedia.org/wiki/Combinatory_logic][Combinatory logic]]


*Evaluation*

 - [[https://en.wikipedia.org/wiki/Evaluation_strategy][Evaluation strategy]]

 - [[http://en.wikipedia.org/wiki/Eager_evaluation][Eager Evaluation]]
 - [[http://en.wikipedia.org/wiki/Short-circuit_evaluation][Short-circuit evaluation]]

Related to Lazy Evaluation

 - [[http://en.wikipedia.org/wiki/Lazy_evaluation][Lazy Evaluation]]
 - [[https://en.wikipedia.org/wiki/Thunk][Thunk]]

*Monads*

 - [[http://en.wikipedia.org/wiki/Monad_(functional_programming][Monads Functional Programming]])
 - [[http://en.wikibooks.org/wiki/Haskell/Understanding_monads][Haskell/Understanding monads]]
 - [[http://en.wikipedia.org/wiki/Monad_transformer][Monad transformer]]

*Continuations*

 - [[http://en.wikipedia.org/wiki/Continuation][Continuation]]
 - [[http://en.wikipedia.org/wiki/Continuation-passing_style][Continuation-passing style]]

*Fundamental Data Structure*

 - [[https://en.wikipedia.org/wiki/List_%28abstract_data_type%29][List (abstract data type)]]
 - [[https://en.wikipedia.org/wiki/Array_data_structure][Array data structure]]
 - [[https://en.wikipedia.org/wiki/Array_data_type][Array data type]]


*Types*

 - [[https://en.wikipedia.org/wiki/Category_theory][Category theory]]
 - [[https://en.wikipedia.org/wiki/Type_theory][Type Theory]]
 - [[https://en.wikipedia.org/wiki/Type_system][Type System]]

 - [[https://en.wikipedia.org/wiki/Algebraic_data_type][Algebraic data type]]

 - [[https://en.wikipedia.org/wiki/Type_signature][Type signature]]
 - [[https://en.wikipedia.org/wiki/Enumerated_type][Enumerated type]]
 - [[https://en.wikipedia.org/wiki/Product_type][Product type]]
 - [[https://en.wikipedia.org/wiki/Tagged_union][Tagged union]]
 - [[https://en.wikipedia.org/wiki/Dependent_type][Dependent type]]


 - [[https://en.wikipedia.org/wiki/Recursive_data_type][Recursive data type]]

 - [[https://en.wikipedia.org/wiki/Generalized_algebraic_data_type][Generalized algebraic data type]]

 - [[https://en.wikipedia.org/wiki/Disjoint_union][Disjoint union]]

*Miscellaneous*

 - [[https://en.wikipedia.org/wiki/Call_stack][Call stack]]
 - [[https://en.wikipedia.org/wiki/Call_graph][Call graph]]

 - [[https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29][Reflection (computer programming)]]

 - [[https://en.wikipedia.org/wiki/Function_object][Function object]]

 - [[https://en.wikipedia.org/wiki/Memoization][Memoization]]

 - [[https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29][Garbage collection (computer science)]]

*Functional Languages*

 - [[https://en.wikipedia.org/wiki/Lisp_%28programming_language%29][Lisp (programming language)]]
 - [[https://en.wikipedia.org/wiki/Scheme_%28programming_language%29][Scheme Lisp]]

 - [[https://en.wikipedia.org/wiki/Haskell][Haskell]]

 - [[https://en.wikipedia.org/wiki/ML_%28programming_language%29][ML (programming language)]]
 - [[https://en.wikipedia.org/wiki/Standard_ML][Standard ML]]
 - [[https://en.wikipedia.org/wiki/OCaml][OCaml]]
 - [[https://en.wikipedia.org/wiki/F_Sharp_%28programming_language%29][F# - Fsharp]]

**** Selected Rosettacode Pages
*** Concepts Examples

 - [[http://rosettacode.org/wiki/Call_a_function][Call a function]]

 - [[http://rosettacode.org/wiki/Higher-order_functions][Higher-order functions]]

 - [[http://rosettacode.org/wiki/Closures/Value_capture][Closures/Value capture]]

 - [[http://rosettacode.org/wiki/Function_composition][Function composition]]

 - [[http://rosettacode.org/wiki/Partial_function_application][Partial function application]]

 - [[http://rosettacode.org/wiki/Currying][Currying]]

 - [[http://rosettacode.org/wiki/Catamorphism][Catamorphism - Fold/Reduce]]

 - [[http://rosettacode.org/wiki/Null_object][Null object]]

 - [[http://rosettacode.org/wiki/Y_combinator][Y combinator]]

Recursion:

 - [[http://rosettacode.org/wiki/Anonymous_recursion][Anonymous recursion]]

 - [[http://rosettacode.org/wiki/Ackermann_function][Ackermann function]]

*** Languages

 - [[http://rosettacode.org/wiki/Haskell][Haskell]]

 - [[http://rosettacode.org/wiki/OCaml][Ocaml]]

 - [[http://rosettacode.org/wiki/Fsharp][F# - Fsharp]]

 - [[http://rosettacode.org/wiki/scheme][Scheme]]

 - [[http://rosettacode.org/wiki/Racket][Racket]]

 - [[http://rosettacode.org/wiki/Clojure][Clojure]]

 - [[http://rosettacode.org/wiki/Scala][Scala]]

 - [[http://rosettacode.org/wiki/Category:JavaScript][JavaScript /
   ECMAScript]]
* Footnotes

[fn:Schwaighofer-2009]  Schwaighofer A. *Tail Call Optimization in the
Java HotSpotâ„¢ VM.* Available at:  <http://www.ssw.uni-linz.ac.at/Research/Papers/Schwaighofer09Master/schwaighofer09master.pdf>

[fn:martin-odersky-tail-call] Schinz M, Odersky M. *Tail call
elimination on the Java virtual machine.* InProceedings of the First
Workshop on Multi-Language Infrastructure and Interoperability 2001
(No. LAMP-CONF-2001-001). Available at: <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.98.1934&rep=rep1&type=pdf>

[fn:R-tco] [[http://stackoverflow.com/questions/13208963/tail-recursion-on-r-statistical-environment][Tail recursion on R Statistical Environment - Stack Overflow]]

[fn:python-tco1] [[http://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html][Neopythonic: Tail Recursion Elimination]] 

[fn:python-tco2] [[http://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html][Neopythonic: Final Words on Tail Calls]]





