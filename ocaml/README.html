<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Ocaml</title>
<!-- 2016-11-01 ter 01:18 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Caio Rodrigues" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href="/Functional-Programming/theme/style.css" rel="stylesheet">

<script type="text/javascript" src="/Functional-Programming/theme/org-info.js">
/**
 *
 * @source: /Functional-Programming/theme/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in /Functional-Programming/theme/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in /Functional-Programming/theme/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Ocaml</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. OCaml</a>
<ul>
<li><a href="#sec-1-1">1.1. Overview</a></li>
<li><a href="#sec-1-2">1.2. Setup</a></li>
<li><a href="#sec-1-3">1.3. Toolset</a>
<ul>
<li>
<ul>
<li><a href="#sec-1-3-0-1">1.3.0.1. OCAML Interactive Shell</a></li>
<li><a href="#sec-1-3-0-2">1.3.0.2. UTOP Interactive Shell</a></li>
<li><a href="#sec-1-3-0-3">1.3.0.3. OCaml Browser</a></li>
<li><a href="#sec-1-3-0-4">1.3.0.4. Troubleshooting</a></li>
<li><a href="#sec-1-3-0-5">1.3.0.5. Opam Package Manager</a></li>
<li><a href="#sec-1-3-0-6">1.3.0.6. Misc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Basic Syntax</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. Primitive Types</a></li>
<li><a href="#sec-1-4-2">1.4.2. Operators</a></li>
<li><a href="#sec-1-4-3">1.4.3. Variable Declaration</a></li>
<li><a href="#sec-1-4-4">1.4.4. Local Binding</a></li>
<li><a href="#sec-1-4-5">1.4.5. Polymorphic Functions</a></li>
<li><a href="#sec-1-4-6">1.4.6. Number Formats</a></li>
<li><a href="#sec-1-4-7">1.4.7. Math / Float Functions</a></li>
<li><a href="#sec-1-4-8">1.4.8. Function Declaration</a></li>
<li><a href="#sec-1-4-9">1.4.9. Function Composition</a></li>
<li><a href="#sec-1-4-10">1.4.10. Lambda Functions/ Anonymous Functions</a></li>
<li><a href="#sec-1-4-11">1.4.11. Recursive Functions</a></li>
<li><a href="#sec-1-4-12">1.4.12. Mutable References</a></li>
<li><a href="#sec-1-4-13">1.4.13. Control Structures</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Standard (Native) Library Modules</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. List</a></li>
<li><a href="#sec-1-5-2">1.5.2. Array</a></li>
<li><a href="#sec-1-5-3">1.5.3. String</a></li>
<li><a href="#sec-1-5-4">1.5.4. Sys</a></li>
<li><a href="#sec-1-5-5">1.5.5. Filename</a></li>
<li><a href="#sec-1-5-6">1.5.6. Unix</a></li>
<li><a href="#sec-1-5-7">1.5.7. IO - Input / Output</a></li>
<li><a href="#sec-1-5-8">1.5.8. Type Casting</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. Algebraic Data Types and Pattern Matching</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. Overview</a></li>
<li><a href="#sec-1-6-2">1.6.2. Record Types</a></li>
<li><a href="#sec-1-6-3">1.6.3. Disjoint Union</a></li>
<li><a href="#sec-1-6-4">1.6.4. Agreggated Data types</a></li>
<li><a href="#sec-1-6-5">1.6.5. Pattern Matching</a>
<ul>
<li><a href="#sec-1-6-5-1">1.6.5.1. Basic Pattern Matching</a></li>
<li><a href="#sec-1-6-5-2">1.6.5.2. Tuple Pattern Matching</a></li>
</ul>
</li>
<li><a href="#sec-1-6-6">1.6.6. Recursive Data Structures</a>
<ul>
<li><a href="#sec-1-6-6-1">1.6.6.1. Alternative List Implementation</a></li>
<li><a href="#sec-1-6-6-2">1.6.6.2. File Tree Recursive Directory Walk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-7">1.7. Lazy Evaluation</a></li>
<li><a href="#sec-1-8">1.8. Foreign Function Interface FFI</a>
<ul>
<li><a href="#sec-1-8-1">1.8.1. Calling C Standard Library and Unix System Calls</a></li>
<li><a href="#sec-1-8-2">1.8.2. Calling Shared Libraries</a>
<ul>
<li><a href="#sec-1-8-2-1">1.8.2.1. Calling GNU Scientific Library</a></li>
<li><a href="#sec-1-8-2-2">1.8.2.2. Calling Python</a></li>
</ul>
</li>
<li><a href="#sec-1-8-3">1.8.3. Finding Shared Libraries</a></li>
<li><a href="#sec-1-8-4">1.8.4. References</a></li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. Module System</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. Overview</a></li>
<li><a href="#sec-1-9-2">1.9.2. Opening Modules</a></li>
<li><a href="#sec-1-9-3">1.9.3. Defining a module in the Toplevel</a></li>
<li><a href="#sec-1-9-4">1.9.4. Loading file as module in the toplevel</a></li>
<li><a href="#sec-1-9-5">1.9.5. Loading Libraries Modules</a></li>
<li><a href="#sec-1-9-6">1.9.6. Including Modules</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. Compiling</a>
<ul>
<li><a href="#sec-1-10-1">1.10.1. Compiling a single file</a></li>
<li><a href="#sec-1-10-2">1.10.2. Compiling a single File and a single Module</a></li>
<li><a href="#sec-1-10-3">1.10.3. See also</a></li>
</ul>
</li>
<li><a href="#sec-1-11">1.11. Creating Libraries, Modules and Compiling to Bytecode or Machine Code</a>
<ul>
<li><a href="#sec-1-11-1">1.11.1. Loading Files in Interactive Shell</a></li>
<li><a href="#sec-1-11-2">1.11.2. Compile Module to Bytecode</a></li>
</ul>
</li>
<li><a href="#sec-1-12">1.12. Batteries Standard Library</a>
<ul>
<li><a href="#sec-1-12-1">1.12.1. Batteries Modules</a>
<ul>
<li><a href="#sec-1-12-1-1">1.12.1.1. Batteries List</a></li>
<li><a href="#sec-1-12-1-2">1.12.1.2. Lazy List</a></li>
<li><a href="#sec-1-12-1-3">1.12.1.3. Bat Enum</a></li>
<li><a href="#sec-1-12-1-4">1.12.1.4. String</a></li>
<li><a href="#sec-1-12-1-5">1.12.1.5. BatOption</a></li>
<li><a href="#sec-1-12-1-6">1.12.1.6. BatRef</a></li>
<li><a href="#sec-1-12-1-7">1.12.1.7. BatFiles</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-13">1.13. Miscellaneous</a>
<ul>
<li><a href="#sec-1-13-1">1.13.1. Changing Toploop Prompt</a></li>
<li><a href="#sec-1-13-2">1.13.2. Adding Directives to Toploop Shell</a></li>
<li><a href="#sec-1-13-3">1.13.3. Shell Script in Ocaml</a></li>
<li><a href="#sec-1-13-4">1.13.4. Debugging</a></li>
<li><a href="#sec-1-13-5">1.13.5. Generating OCaml html API Doc</a></li>
</ul>
</li>
<li><a href="#sec-1-14">1.14. Resources</a>
<ul>
<li><a href="#sec-1-14-1">1.14.1. Articles</a></li>
<li><a href="#sec-1-14-2">1.14.2. Links</a></li>
<li><a href="#sec-1-14-3">1.14.3. Books</a>
<ul>
<li><a href="#sec-1-14-3-1">1.14.3.1. Online Books</a></li>
</ul>
</li>
<li><a href="#sec-1-14-4">1.14.4. Community</a>
<ul>
<li><a href="#sec-1-14-4-1">1.14.4.1. Online Resources</a></li>
<li><a href="#sec-1-14-4-2">1.14.4.2. Blogs</a></li>
<li><a href="#sec-1-14-4-3">1.14.4.3. Hacker News Threads</a></li>
<li><a href="#sec-1-14-4-4">1.14.4.4. Slides and Presentations</a></li>
<li><a href="#sec-1-14-4-5">1.14.4.5. Stack Overflow Highlighted Questions</a></li>
<li><a href="#sec-1-14-4-6">1.14.4.6. See Also</a></li>
<li><a href="#sec-1-14-4-7">1.14.4.7. Quick Reference Sheets</a></li>
</ul>
</li>
<li><a href="#sec-1-14-5">1.14.5. References By Subject</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<lu> 
  <li><a href="/Functional-Programming/index.html">Index</a></li>
  <li><a href="https://github.com/caiorss/Functional-Programming">Repository</a></li>
</lu>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> OCaml</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Overview</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="images/ocamlogo.png" alt="ocamlogo.png" />
</p>
</div>

<p>
OCaml (Objective Categorical Abstract Machine Language) (formerly
known as Objective Caml) is the main implementation of the Caml
programming language, created by Xavier Leroy, Jérôme Vouillon, Damien
Doligez, Didier Rémy and others in 1996. OCaml is an open source
project managed and principally maintained by the French institute
INRIA. The Caml's toolset includes an interactive toplevel
interpreter, a bytecode compiler, and an optimizing native code
compiler.
</p>

<p>
<b>Features</b>
</p>

<ul class="org-ul">
<li>Strong Static Type  - Type Safety
</li>
<li>Type Inference      - The compiler infers the types for you, you don't need to write all the types;
</li>
<li>Curried Functions   - Allows to create and functions on the fly.
</li>
<li>Strict Evaluation by default
</li>
<li>Optional Lazy Evaluation
</li>
<li>Multi Paradigm      - Functional, Imperative and Object Orientated
</li>
<li>Compiled and Interpreted - It allows iteractive development and debugging.
<ul class="org-ul">
<li>Compiles to natve code and bytecode
</li>
</ul>
</li>
<li>Algebraic Data Types
</li>
<li>Pattern Matching
</li>
</ul>

<p>
<b>History</b>
</p>

<ul class="org-ul">
<li>ML: Meta Language
<ul class="org-ul">
<li>1973, University of Edinburg
</li>
<li>Used to program search tactics in LCF theorem prover
</li>
</ul>
</li>

<li>SML: Standard ML
<ul class="org-ul">
<li>1990, Princeton University
</li>
</ul>
</li>

<li>OCaml
<ul class="org-ul">
<li>1996, INRIA
</li>
</ul>
</li>
</ul>

<p>
<b>Ocaml Shell Online</b>
</p>

<p>
You Can try OCaml online in:
</p>

<ul class="org-ul">
<li><a href="http://ocsigen.org/js_of_ocaml/dev/files/toplevel/index.html">OCsigen - JS of Ocaml Toploop</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Setup</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Ocaml installer, packages and releases:
</p>
<ul class="org-ul">
<li><a href="http://caml.inria.fr/ocaml/release.en.html">http://caml.inria.fr/ocaml/release.en.html</a>
</li>

<li><a href="https://github.com/OCamlPro/ocpwin-distrib">OCamlPro's version of OCaml on Windows</a>
</li>
</ul>

<p>
<b>Linux</b>
</p>

<p>
Ubuntu:
</p>

<p>
Show all OCaml packages available.
</p>
<div class="org-src-container">

<pre class="src src-bash">$ apt-cache search ocaml
</pre>
</div>

<div class="org-src-container">

<pre class="src src-bash">sudo apt-get install curl build-essential
sudo apt-get install ocaml opam ocaml-native-compilers m4
</pre>
</div>

<p>
Arch Linux:
</p>
<pre class="example">
$ yaourt -s ocaml
</pre>

<p>
Gentoo:
</p>
<pre class="example">
$ emerge ocaml
</pre>

<p>
Fedora
</p>
<pre class="example">
$ su - -c "yum install ocaml"
</pre>

<p>
Install Utop, Core library and Batteries library
</p>

<pre class="example">
opam update
opam install utop core batteries
</pre>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Toolset</h3>
<div class="outline-text-3" id="text-1-3">
<p>
See also: <a href="https://github.com/OCamlPro/ocaml-cheat-sheets">https://github.com/OCamlPro/ocaml-cheat-sheets</a>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Program</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">ocaml</td>
<td class="left">toplevel loop  / Interactive Shell</td>
</tr>

<tr>
<td class="left">ocamlrun</td>
<td class="left">bytecode interpreter</td>
</tr>

<tr>
<td class="left">ocamlc</td>
<td class="left">bytecode batch compiler</td>
</tr>

<tr>
<td class="left">ocamlopt</td>
<td class="left">native code batch compiler</td>
</tr>

<tr>
<td class="left">ocamlc.opt</td>
<td class="left">optimized bytecode batch compiler</td>
</tr>

<tr>
<td class="left">ocamlopt.opt</td>
<td class="left">optimized native code batch compiler</td>
</tr>

<tr>
<td class="left">ocamlmktop</td>
<td class="left">new toplevel constructor</td>
</tr>

<tr>
<td class="left">ocamldoc</td>
<td class="left">Generate documentation for source files in HTML/ LaTex / man pages</td>
</tr>

<tr>
<td class="left">ocamlfind</td>
<td class="left">Find OCaml packages installed</td>
</tr>

<tr>
<td class="left">opam</td>
<td class="left">Package manager for OCaml</td>
</tr>

<tr>
<td class="left">utop[optional]</td>
<td class="left">Improved interactive shell</td>
</tr>
</tbody>
</table>


<pre class="example">
Purpose             C       Bytecode    Native code
Source code         *.c     *.ml        *.ml
Header files1       *.h     *.mli       *.mli
Object files        *.o     *.cmo       *.cmx2
Library files       *.a     *.cma       *.cmxa3
Binary programs     prog    prog        prog.opt4
</pre>

<p>
Standard Libraries:
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/">Native Library</a>
</li>

<li><a href="https://ocaml.janestreet.com/ocaml-core/111.17.00/doc/core/">Core</a> - Jane Street Capital's Standard
</li>
<li><a href="https://github.com/janestreet/core_kernel">https://github.com/janestreet/core_kernel</a>
</li>
</ul>

<p>
Library
</p>

<ul class="org-ul">
<li><a href="http://batteries.forge.ocamlcore.org/">Batteries</a> - Maintained by community
</li>
</ul>

<p>
Linux:
</p>

<pre class="example">
$ apropos ocaml
Callback (3o)        - Registering OCaml values with the C runtime.
Lexing (3o)          - The run-time library for lexers generated by ocamllex.
ocaml (1)            - The OCaml interactive toplevel
ocaml.m4 (1)         - Autoconf macros for OCaml
ocamlbuild (1)       - The OCaml project compilation tool
ocamlbuild.byte (1)  - The OCaml project compilation tool
ocamlbuild.native (1) - The OCaml project compilation tool
ocamlc (1)           - The OCaml bytecode compiler
ocamlcp (1)          - The OCaml profiling compilers
ocamldebug (1)       - the OCaml source-level replay debugger.
ocamldep (1)         - Dependency generator for OCaml
ocamldoc (1)         - The OCaml documentation generator
ocamldot (1)         - generate dependency graphs of ocaml programs
ocamldumpobj (1)     - disassembler for OCaml executable and .cmo object files
ocamllex (1)         - The OCaml lexer generator
ocamlmklib (1)       - generate libraries with mixed C / Caml code.
ocamlmktop (1)       - Building custom toplevel systems
ocamlobjinfo (1)     - dump information about OCaml compiled objects
ocamlopt (1)         - The OCaml native-code compiler
ocamloptp (1)        - The OCaml profiling compilers
ocamlprof (1)        - The OCaml profiler
ocamlrun (1)         - The OCaml bytecode interpreter
ocamlyacc (1)        - The OCaml parser generator
opam (1)             - source-based OCaml package management
Parsing (3o)         - The run-time library for parsers generated by ocamlyacc.

$ whereis ocaml
ocaml: /usr/bin/ocaml /usr/lib/ocaml /usr/bin/X11/ocaml
/usr/local/lib/ocaml /usr/share/man/man1/ocaml.1.gz
</pre>

<p>
Extension Files:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Extension</th>
<th scope="col" class="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">.ml</td>
<td class="left">source file</td>
</tr>

<tr>
<td class="left">.mli</td>
<td class="left">interface file</td>
</tr>

<tr>
<td class="left">.cmo</td>
<td class="left">object file (bytecode)</td>
</tr>

<tr>
<td class="left">.cma</td>
<td class="left">library object file (bytecode)</td>
</tr>

<tr>
<td class="left">.cmi</td>
<td class="left">compiled interface file</td>
</tr>

<tr>
<td class="left">.cmx</td>
<td class="left">object file (native)</td>
</tr>

<tr>
<td class="left">.cmxa</td>
<td class="left">library object file (native)</td>
</tr>

<tr>
<td class="left">.c</td>
<td class="left">C source file</td>
</tr>

<tr>
<td class="left">.o</td>
<td class="left">C object file (native)</td>
</tr>

<tr>
<td class="left">.a</td>
<td class="left">C library object file (native)</td>
</tr>
</tbody>
</table>
</div>



<div id="outline-container-sec-1-3-0-1" class="outline-5">
<h5 id="sec-1-3-0-1"><span class="section-number-5">1.3.0.1</span> OCAML Interactive Shell</h5>
<div class="outline-text-5" id="text-1-3-0-1">
<pre class="example">
$ rlwrap -m -c -r -H ../history.ml -f ../completion.txt ocaml
</pre>

<p>
OCAML Directives
</p>

<p>
Read, compile and execute source phrases from the given file. This is textual inclusion: phrases are processed just as if they were typed on standard input. The reading of the file stops at the first error encountered.
</p>

<pre class="example">
#use "whatever.ml";;
</pre>

<p>
Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc.
</p>

<pre class="example">
#load "file-name";;
</pre>

<p>
Add the given directory to the list of directories searched for source and compiled files.
</p>

<pre class="example">
#directory "dir-name";;
</pre>

<p>
Change the current working directory.
</p>

<pre class="example">
#cd "dir-name";;
</pre>

<p>
Exit the toplevel loop and terminate the ocaml command.
</p>

<pre class="example">
#quit;;
</pre>

<p>
Source:
</p>

<p>
<a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual023.html#toc91">OCaml Manual</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-3-0-2" class="outline-5">
<h5 id="sec-1-3-0-2"><span class="section-number-5">1.3.0.2</span> UTOP Interactive Shell</h5>
<div class="outline-text-5" id="text-1-3-0-2">
<p>
Install Utop:
</p>

<pre class="example">
# opam install utop
</pre>


<div class="figure">
<p><img src="images/utopshell.png" alt="utopshell.png" />
</p>
</div>

<p>
<b>Show UTOP help</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">utop # #utop_help;;
If you can't see the prompt properly try: #utop_prompt_simple                                                                                                                               utop defines the following directives:

#utop_bindings   : list all the current key bindings
#utop_macro      : display the currently recorded macro
#topfind_log     : display messages recorded from findlib since the beginning of the session
#topfind_verbose : enable/disable topfind verbosity
For a complete description of utop, look at the utop(1) manual page.
</pre>
</div>

<p>
Note: Those commands below also works in the native ocaml interpreter (ocaml).
</p>

<p>
<b>Load a library</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">utop # #use "topfind";;
- : unit = ()                                                                                 Findlib has been successfully loaded. Additional directives:                                    #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
</pre>
</div>

<p>
<b>List Installed Packages</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">utop # #list ;;
archimedes          (version: 0.4.17) archimedes.graphics (version: 0.4.17)                                  archimedes.internals (version: 0.4.17)
archimedes.top      (version: 0.4.17)
batteries           (version: 2.3)
bigarray            (version: [distributed with Ocaml])
bin_prot            (version: 111.03.00)
...
</pre>
</div>


<p>
<b>Load Installed OCaml Packages</b>
</p>

<pre class="example">
utop # #require "batteries";;
utop # #require "gnuplot";;
</pre>

<p>
<b>Show UTOP Key Bindings</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">utop # #utop_bindings;;
enter       : accept                        -&gt; accept the current input.                                  escape      : cancel-search                 -&gt; cancel search mode.                                        tab         : complete                      -&gt; complete current input.
up          : history-prev                  -&gt; go to the previous entry of the history.
down        : history-next                  -&gt; go to the next entry of the history.
...
</pre>
</div>

<p>
<b>Load ML file, source code</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #use "text.ml" ;;
val split_lines : string -&gt; string list = &lt;fun&gt;
val split_space : string -&gt; string list = &lt;fun&gt;
val split_delim : string -&gt; string -&gt; string list = &lt;fun&gt;
val add_prefix : string -&gt; string -&gt; string = &lt;fun&gt;
val add_suffix : string -&gt; string -&gt; string = &lt;fun&gt;
# 

#  split_space "Hello world ocaml" ;; 
- : string list = ["Hello"; "world"; "ocaml"]
#
</pre>
</div>

<p>
<b>Load ML file as module</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #mod_use "text.ml" ;;
  module Text :
    sig
      val split_lines : string -&gt; string list
      val split_space : string -&gt; string list
      val split_delim : string -&gt; string -&gt; string list
      val add_prefix : string -&gt; string -&gt; string
      val add_suffix : string -&gt; string -&gt; string
    end
  # 

  #  Text.split_space "Hello world ocaml" ;;
  - : string list = ["Hello"; "world"; "ocaml"]
  #
</pre>
</div>

<p>
<b>Show a Module Sinature</b>
</p>

<p>
(Ocaml version &gt;= 4.2)
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #show Filename ;;
module Filename :
  sig
    val current_dir_name : string
    val parent_dir_name : string
    val dir_sep : string
    val concat : string -&gt; string -&gt; string
    val is_relative : string -&gt; bool
    val is_implicit : string -&gt; bool
    val check_suffix : string -&gt; string -&gt; bool
    val chop_suffix : string -&gt; string -&gt; string
    val chop_extension : string -&gt; string
    val basename : string -&gt; string
    val dirname : string -&gt; string
    val temp_file : ?temp_dir:string -&gt; string -&gt; string -&gt; string
    val open_temp_file :
      ?mode:open_flag list -&gt;
      ?temp_dir:string -&gt; string -&gt; string -&gt; string * out_channel
    val get_temp_dir_name : unit -&gt; string
    val set_temp_dir_name : string -&gt; unit
    val temp_dir_name : string
    val quote : string -&gt; string
  end
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-0-3" class="outline-5">
<h5 id="sec-1-3-0-3"><span class="section-number-5">1.3.0.3</span> OCaml Browser</h5>
<div class="outline-text-5" id="text-1-3-0-3">
<p>
Browser OCaml Type Signatures.
</p>

<pre class="example">
$ ocamlfind browser -all
$ ocamlfind ocamlbrowser -package core
$ ocamlfind browser -package batterie
</pre>


<div class="figure">
<p><img src="images/ocamlbrowser.png" alt="ocamlbrowser.png" />
</p>
</div>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/browser.html">http://caml.inria.fr/pub/docs/manual-ocaml/browser.html</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-0-4" class="outline-5">
<h5 id="sec-1-3-0-4"><span class="section-number-5">1.3.0.4</span> Troubleshooting</h5>
<div class="outline-text-5" id="text-1-3-0-4">
<p>
Finding the version of Ocaml and Opam
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ocaml -version
The OCaml toplevel, version 4.01.0

$ opam --version
1.2.2

$ ocamlc -v
The OCaml compiler, version 4.01.0
Standard library directory: /usr/lib/ocaml

$ ocamlopt -v
The OCaml native-code compiler, version 4.01.0
Standard library directory: /usr/lib/ocaml

$ utop -version
The universal toplevel for OCaml, version 1.17, compiled for OCaml version 4.01.0
</pre>
</div>

<p>
Get information about compiled files:
</p>

<pre class="example">
$ ocamlobjinfo seq.cmo
File seq.cmo
Unit name: Seq
Interfaces imported:
    54ba2685e6ed154753718e9c8becb28b    String
    6e0efdddf4b33e30be4cc8ff056b56ff    Seq
    4836c254f0eacad92fbf67abc525fdda    Pervasives
Uses unsafe features: no
Force link: no


$ ocamlobjinfo seq.cma
File seq.cma
Force custom: no
Extra C object files:
Extra C options:
Extra dynamically-loaded libraries:
Unit name: Seq
Interfaces imported:
    54ba2685e6ed154753718e9c8becb28b    String
    4387952f7aad2695faf187cd3feeb5e5    Seq
    4836c254f0eacad92fbf67abc525fdda    Pervasives
Uses unsafe features: no
Force link: no


$ ocamlobjinfo seq.cmi
File seq.cmi
Unit name: Seq
Interfaces imported:
    4387952f7aad2695faf187cd3feeb5e5    Seq
    4836c254f0eacad92fbf67abc525fdda    Pervasives
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-0-5" class="outline-5">
<h5 id="sec-1-3-0-5"><span class="section-number-5">1.3.0.5</span> Opam Package Manager</h5>
<div class="outline-text-5" id="text-1-3-0-5">
<p>
Opam Version
</p>

<pre class="example">
$ opam --version
1.2.2
</pre>

<p>
List Installed Versions of OCaml compilers:
</p>

<pre class="example">
$ opam switch list
--     -- 3.11.2             Official 3.11.2 release
--     -- 3.12.1             Official 3.12.1 release
--     -- 4.00.0             Official 4.00.0 release
--     -- 4.00.1             Official 4.00.1 release
4.01.0  C 4.01.0             Official 4.01.0 release
--     -- 4.02.0             Official 4.02.0 release
4.02.1  I 4.02.1             Official 4.02.1 release
--     -- ocamljava-preview
doc     I system             System compiler (4.00.1)
 # 111 more patched or experimental compilers, use '--all' to show
</pre>

<p>
Switch to a ocaml version 4.02.1:
</p>

<pre class="example">
$ opam switch 4.02.1
 # To setup the new switch in the current shell, you need to run:
eval `opam config env`
</pre>

<p>
Search Packages
</p>

<pre class="example">
$ opam search core
 * Existing packages for 4.01.0:
async               --  Monadic concurrency library
async_core          --  Monadic concurrency library
async_extended      --  Additional utilities for async
...
</pre>

<p>
Install Packages
</p>

<pre class="example">
opam install lablgtk ocamlfind
</pre>

<p>
Upgrade Packages
</p>

<pre class="example">
$ opam upgrade
</pre>

<p>
Show all Installed Packages
</p>

<pre class="example">
$  ocamlfind list
archimedes          (version: 0.4.17)
archimedes.graphics (version: 0.4.17)
archimedes.internals (version: 0.4.17)
archimedes.top      (version: 0.4.17)
batteries           (version: 2.3)
bigarray            (version: [distributed with Ocaml])
bin_prot            (version: 111.03.00)
bin_prot.syntax     (version: 111.03.00)
bytes               (version: [OCaml strictly before 4.02])
camlp4              (version: [distributed with Ocaml])
camlp4.exceptiontracer (version: [distributed with Ocaml])
camlp4.extend       (version: [distributed with Ocaml])
camlp4.foldgenerator (version: [distributed with Ocaml])
..
</pre>

<p>
Finding Opam Settings
</p>

<div class="org-src-container">

<pre class="src src-bash">$ opam config list
 # Global OPAM configuration variables

user                 tux
group                tux
make                 make
os                   linux
root                 /home/tux/.opam
prefix               /home/tux/.opam/system
lib                  /home/tux/.opam/system/lib
bin                  /home/tux/.opam/system/bin
sbin                 /home/tux/.opam/system/sbin
doc                  /home/tux/.opam/system/doc
stublibs             /home/tux/.opam/system/lib/stublibs
toplevel             /home/tux/.opam/system/lib/toplevel
man                  /home/tux/.opam/system/man
share                /home/tux/.opam/system/share
etc                  /home/tux/.opam/system/etc

 # Global variables from the environment

ocaml-version        4.01.0     # The version of the currently used OCaml compiler
opam-version         1.2.2      # The currently running OPAM version
compiler             system     # The name of the current OCaml compiler (may be more specific than the version, eg: "4.01.0+fp", or "system")
preinstalled         true       # Whether the compiler was preinstalled on the system, or installed by OPAM
switch               system     # The local name (alias) of the current switch
jobs                 1          # The number of parallel jobs set up in OPAM configuration
ocaml-native         true       # Whether the OCaml native compilers are available
ocaml-native-tools   false      # Whether the native ".opt" version of the OCaml toolchain is available
ocaml-native-dynlink true       # Whether native dynlink is available on this installation
arch                 i686       # The current arch, as returned by "uname -m"

 # Package variables ('opam config list PKG' to show)

PKG:name         # Name of the package
PKG:version      # Version of the package
PKG:depends      # Resolved direct dependencies of the package
PKG:installed    # Whether the package is installed
PKG:enable       # Takes the value "enable" or "disable" depending on whether the package is installed
PKG:pinned       # Whether the package is pinned
PKG:bin          # Binary directory for this package
PKG:sbin         # System binary directory for this package
PKG:lib          # Library directory for this package
PKG:man          # Man directory for this package
PKG:doc          # Doc directory for this package
PKG:share        # Share directory for this package
PKG:etc          # Etc directory for this package
PKG:build        # Directory where the package was built
PKG:hash         # Hash of the package archive
</pre>
</div>

<p>
Filter Installed Packages
</p>

<pre class="example">
$ ocamlfind list | grep -i core
cohttp.lwt-core     (version: 0.17.1)
core                (version: 111.28.01)
core.syntax         (version: 109.32.00)
core.top            (version: 111.28.01)
core_kernel         (version: 111.28.00)
core_kernel.check_caml_modify (version: 111.28.00)
core_kernel.raise_without_backtrace (version: 111.28.00)
netmulticore        (version: 4.0.2)
num.core            (version: [internal])

$ ocamlfind list | grep -i batteries
batteries           (version: 2.3
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-0-6" class="outline-5">
<h5 id="sec-1-3-0-6"><span class="section-number-5">1.3.0.6</span> Misc</h5>
<div class="outline-text-5" id="text-1-3-0-6">
<p>
Create .mli file from .ml files. The command bellow creates context.mli from context.ml
</p>
<pre class="example">
$ ocamlc -i -c context.ml &gt; context.mli
</pre>

<p>
Custom Top Level Interpreter with preload libraries:
</p>

<pre class="example">
$ ocamlmktop -custom -o mytoplevel graphics.cma -cclib -lX11
./mytoplevel
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Basic Syntax</h3>
<div class="outline-text-3" id="text-1-4">
<p>
This section describes the OCaml native library and <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html">Pervasives module</a>.
</p>

<p>
Escape Characters:
</p>

<pre class="example">
Sequence  ASCII     Name
\\        \         Backlash
\"        "         Double Quote
\'        '         Double Quote
\n        LF        Line Feed
\r        CR        Carriage Return
\t        TAB       Horizontal tabulation
\b        BS        Backspace
'\ '      SPC       Space
\nnnn     nnn       Decimal Code of Acii Character
\xhhh     xhh       Hexadecimal Code of Ascii Character
</pre>

<div class="org-src-container">

<pre class="src src-ocaml"># '\\' ;;
- : char = '\\'
# '\ ' ;;
- : char = ' '
# '\"' ;;
- : char = '"'
# '\r' ;;
- : char = '\r'
# '\n' ;;
- : char = '\n'
# '\t' ;;
- : char = '\t'
# '\ ' ;;
- : char = ' '
# '\098' ;;
- : char = 'b'
# '\x21' ;;
- : char = '!'
</pre>
</div>
</div>


<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Primitive Types</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">

<pre class="src src-ocaml">$ ocaml
        OCaml version 4.01.0

    (* Boolean          *)
    (*------------------*)

    # true ;;
    - : bool = true
    # false ;;
    - : bool = false
    #

    (* Int              *)
    (*--------------------
     *      32 bits  signed int in 32 bits machines
     *      64 bits  signed int in 64 bits machines
     *)
    # 1000 ;;
    - : int = 1000

    (* Binary  int *)
    # 0b1000111011 ;;
    - : int = 571

    (* Hexadecimal int *)
    # 0xf0057a3 ;;
    - : int = 251680675

    (* octal int *)
    # 0o73456 ;;
    - : int = 30510

    (* Floats                   *)
    (* ------------------------ *)
    # 3.23e3 ;;
    - : float = 3230.
    # 34.2E-5 ;;
    - : float = 0.000342
    # 232. ;;
    - : float = 232.
    #

    (* Char                     *)
    (* ------------------------ *)

    # 'a' ;;
    - : char = 'a'
    # '\n' ;;
    - : char = '\n'
    # '\232' ;;
    - : char = '\232'


    (* String                         *)
    (* ------------------------------- *)

    # "Hello world OCaml" ;;
    - : string = "Hello world OCaml"
    #

    (* Tuples                            *)
    (* ----------------------------------*)
    # "Hello world OCaml" ;;
    - : string = "Hello world OCaml"
    # (10, 203.2322) ;;
    - : int * float = (10, 203.2322)
    # ("hello", 'w', 10 ) ;;
    - : string * char * int = ("hello", 'w', 10)
    #

    (* Lists / Are immutable data structure   *)
    (*----------------------------------------*)

    # [10; 20; 30; 40; 1; 3] ;;
    - : int list = [10; 20; 30; 40; 1; 3]

    # ["hello" ; "world" ; "ocaml" ; "F#" ; "Haskell" ] ;;
    - : string list = ["hello"; "world"; "ocaml"; "F#"; "Haskell"]
    #

    # [10. ; 2.323 ; 29.232 ; 100.597 ; -23.3 ] ;;
    - : float list = [10.; 2.323; 29.232; 100.597; -23.3]
    #

    # [(1, 'a') ; (2, 'b') ; (3, 'c')] ;;
    - : (int * char) list = [(1, 'a'); (2, 'b'); (3, 'c')]
    #

    (* Arrays / Mutable data structures  *)
    (* --------------------------------- *)

    # [|23; 100; 50; 80; 30; 50 |] ;;
    - : int array = [|23; 100; 50; 80; 30; 50|]

     # [|123.23; 10.23; 50.53; -80.23; 30.9734; 50.25 |] ;;
    - : float array = [|123.23; 10.23; 50.53; -80.23; 30.9734; 50.25|]

     # [|'o'; 'c'; 'a' ; 'm' ; 'l' |] ;;
    - : char array = [|'o'; 'c'; 'a'; 'm'; 'l'|]

    (* Unit / Represents side effects (Similar to Haskell IO ()*)
    (*-------------------------------------------------------- *)

    # ();;
    - : unit = ()
    #

    # print_string ;;
    - : string -&gt; unit = &lt;fun&gt;

    # read_line ;;
    - : unit -&gt; string = &lt;fun&gt;

    # let read_two_lines () = read_line (); read_line (); print_string "two lines" ;;
    val read_two_lines : unit -&gt; unit = &lt;fun&gt;

    # read_two_lines () ;;
    2323
    5353535
    two lines- : unit = ()


    (* Option Type / Equivalent to Haskell Maybe *)

    # None ;;
    - : 'a option = None
    # Some 10 ;;
    - : int option = Some 10
    # Some 'a' ;;
    - : char option = Some 'a'
    # Some "OCaml" ;;
    - : string option = Some "OCaml"
    #
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> Operators</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Float Functions must use +. /. -. *. operators since Ocaml doesn't support
operator overload.
</p>

<p>
Boolean Operators
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* NOT                  *)
(*----------------------*)

# not ;;
- : bool -&gt; bool = &lt;fun&gt;
#

# not false ;;
- : bool = true
# not true ;;
- : bool = false

(* AND                  *)
(*----------------------*)

# (&amp;&amp;) ;;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;

# (&amp;&amp;) true false ;;
- : bool = false
#


# true &amp;&amp; true ;;
- : bool = true
# true &amp;&amp; false ;;
- : bool = false
#

(* OR                   *)
(*----------------------*)

# (||) ;;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;

# (||) false true ;;
- : bool = true
#

# true || true ;;
- : bool = true
# true || false ;;
- : bool = true
# false || false ;;
- : bool = false
#
</pre>
</div>

<p>
Comparison
</p>
<div class="org-src-container">

<pre class="src src-ocaml">(* Equality *)
# (=) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
# (==) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;

(* Inequality *)
# (&lt;&gt;) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
# (!=) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
#


# (&lt;) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
# (&lt;=) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
# (&gt;=) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
# (&gt;) ;;
- : 'a -&gt; 'a -&gt; bool = &lt;fun&gt;
#

# max ;;
- : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
# min ;;
- : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;


# compare ;;
- : 'a -&gt; 'a -&gt; int = &lt;fun&gt;
#

# 2 &lt;&gt; 4 ;;
- : bool = true
# 2 &lt;&gt; 2 ;;
- : bool = false
#
# 3 != 4 ;;
- : bool = true
# 3 != 3 ;;
- : bool = false
#


# max 3 100 ;;
- : int = 100
# min 2.323 100.33 ;;
- : float = 2.323
#
</pre>
</div>


<div class="org-src-container">

<pre class="src src-ocaml"> # (+) ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

 # (-) ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

 # (+.) ;;
- : float -&gt; float -&gt; float = &lt;fun&gt;

 (-.) ;;
- : float -&gt; float -&gt; float = &lt;fun&gt;


(* Interger Operators *)
(*--------------------*)
# 23 + 234 ;;
- : int = 257
# 1000 / 4 ;;
- : int = 250
#

# 1005 mod 10 ;;
- : int = 5
#

# abs (-10) ;;
- : int = 10
# abs 10 ;;
- : int = 10
#
# pred 100 ;;
- : int = 99
# pred 99 ;;
- : int = 98
# succ 100 ;;
- : int = 101
# succ 101 ;;
- : int = 102
#

(* Float Point *)
(*-------------*)

# 100. +. 23.23 ;;
- : float = 123.23
#
# 0.545 *. 100. ;;
- : float = 54.5000000000000071
#
# 1000. /. 4. ;;
- : float = 250.
#
# 1000.0 -. 4.0 ;;
- : float = 996.
#

(* Pow function 2^4 = 16 / only works for float points *)
# 2.0 ** 4. ;;
- : float = 16.
#
# ( **) ;;
- : float -&gt; float -&gt; float = &lt;fun&gt;
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> Variable Declaration</h4>
<div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; let x = 2 ;;
val x : int = 2

(* Declaration with Type *)
&gt; let a : float  = 2.323 ;;
val a : float = 2.323

(* Characters and String *)

&gt; 'a' ;;
- : char = 'a'
&gt; "hello world" ;;
- : string = "hello world"

(* Lists *)

&gt; [1; 2; 3; 4 ; 5; 6] ;;
- : int list = [1; 2; 3; 4; 5; 6]


&gt; [2.323; 534.23; 83.434; 54.3323 ] ;;
- : float list = [2.323; 534.23; 83.434; 54.3323]


&gt; ["hello"; "world"; "ocaml"; "amazing" ] ;;
- : string list = ["hello"; "world"; "ocaml"; "amazing"]



(****** Tuples ***********)

&gt;  (90, 100 ) ;;
- : int * int = (90, 100)

&gt;  (232, 23.232, "hello ", 'c' ) ;;
- : int * float * string * char = (232, 23.232, "hello ", 'c')
&gt;


&gt;  ("hello", 23.23 ) ;;
- : string * float = ("hello", 23.23)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> Local Binding</h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">

<pre class="src src-ocaml"># let  x = 10 in 
  let  y = 3  in
  let  z = 4  in 
  (x, y, z)
  ;;
- : int * int * int = (10, 3, 4)

# x ;;
Error: Unbound value x
# y ;;
Error: Unbound value y
# z ;;
Error: Unbound value z
# 

(**********************)

# let z = 
    let x = 10 in
    let y = 20 in
    x + 2*y
  ;;
val z : int = 50
# z ;;
- : int = 50
# x ;;
Error: Unbound value x
# y ;;
Error: Unbound value y
# 

(**********************)

# let a = 
    let f1 x = 10 *x in
    let fxy x y = 3*x + 4*y in 
    let z = 3 in
    f1 z + fxy 3 4 + f1 6 ;;
val a : int = 115

# a ;;
- : int = 115
# 

# f1 ;;
Error: Unbound value f1
# fxy ;;
Error: Unbound value fxy


(**********************)

# let a, b, c = 
     let f1 x  = 3 * x in 
     let f2 x y = 5 * x - 3 * y in
     let a = 3 in
     let b = 4 in 
     let c = a + b in 
     (f1 a, f2 a b, a + b + c)
  ;;
val a : int = 9
val b : int = 3
val c : int = 14
# 

# f1 ;;
Error: Unbound value f1
# f2 ;;
Error: Unbound value f2
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> Polymorphic Functions</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; let id = fun x -&gt; x ;;
val id : 'a -&gt; 'a = &lt;fun&gt;

&gt;  id 10.23 ;;
- : float = 10.23
&gt;  id 100  ;;
- : int = 100
&gt;  id "Hello world" ;;
- : string = "Hello world"
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> Number Formats</h4>
<div class="outline-text-4" id="text-1-4-6">
<ul class="org-ul">
<li>Int   -  Default Interger format 31 bits signed int on 32 bits machine and 63 bits on a 64 bits machine
</li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Int32.html">Int32</a> - 32 bits signed int
</li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Int64.html">Int64</a> - 63 bits signed int
</li>

<li>Float -  IEEE.754 - 64 bits double precision float point numbers.
</li>

<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Num.html">Num</a> - Arbitrary Precision Integer
</li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Big_int.html">Big_Int</a> - Arbitrary Precision Integer
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">(* 31 bits signed int, since this machine has 32 bits word lenght*)

    # Pervasives.min_int ;;
    - : int = -1073741824
    # Pervasives.max_int ;;
    - : int = 1073741823

(* 32 bits signed int *)

    # Int32.max_int ;;
    - : int32 = 2147483647l
    # Int32.min_int ;;
    - : int32 = -2147483648l

(* 64 bits signed int *)
    # Int64.min_int ;;
    - : int64 = -9223372036854775808L
    # Int64.max_int ;;
    - : int64 = 9223372036854775807L

(* IEEE.754 - 64 bits double precision - float point *)

    # Pervasives.min_float ;;
    - : float = 2.22507385850720138e-308
    # Pervasives.max_float ;;
    - : float = 1.79769313486231571e+308
</pre>
</div>

<p>
Numeric Literals
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Default - Pervasives 31 bit signed int (32 bits machine) *)

    # 23213 ;;
    - : int = 23213

    # 0xf43aaec ;;
    - : int = 256092908

    # 0b10001110011 ;;
    - : int = 1139

(* 32 bits signed int *)

    # 23213l ;;
    - : int32 = 23213l

    # 0xf4123l ;;
    - : int32 = 999715l

    # 0b1111100011110011l ;;
    - : int32 = 63731l

(* 64 bits signed int *)

    # 1000000L ;;
    - : int64 = 1000000L

     # 0xff2562abcL ;;
    - : int64 = 68490242748L

    # 0b11111000111100110011111101L ;;
    - : int64 = 65260797L
</pre>
</div>

<p>
Number Conversion / Type Casting
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># Int32.of_int 10002373 ;;
- : int32 = 10002373l
# Int32.of_float 232322.323 ;;
- : int32 = 232322l
# Int32.of_string "98232376" ;;
- : int32 = 98232376l

# Int32.to_int 100033l ;;
- : int = 100033


# Int64.of_int 100 ;;
- : int64 = 100L
# Int64.of_float 1000239823.2323 ;;
- : int64 = 1000239823L
# Int64.of_string "34234912" ;;
- : int64 = 34234912L

# Int64.to_int 2323884L ;;
- : int = 2323884


 # int_of_float (-1235.34083402321) ;;
- : int = -1235
# Pervasives.int_of_float (-1235.34083402321) ;;
- : int = -1235
 # int_of_string "9123" ;;
- : int = 9123

# float_of_int 1000 ;;
- : float = 1000.
</pre>
</div>

<p>
Math Operations. In Ocaml the same operator cannot be used for more than one type, so to add ints (<del>) must be used, to add floats (</del>.), to add Int32, (Int32.add) and to add Int64, (Int64.add).
</p>

<div class="org-src-container">

<pre class="src src-ocaml">    # (+) ;;
    - : int -&gt; int -&gt; int = &lt;fun&gt;

    # (+.) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;

    # Int32.add ;;
    - : int32 -&gt; int32 -&gt; int32 = &lt;fun&gt;

    # Int64.add ;;
    - : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;

    # Big_int.add_big_int ;;
    - : Big_int.big_int -&gt; Big_int.big_int -&gt; Big_int.big_int = &lt;fun&gt;

    # 23423 + 1212 ;;
    - : int = 24635

    # 32.34 +. 232.22 ;;
    - : float = 264.56

    # Int32.add 2323l 6023l ;;
    - : int32 = 8346l

    # Int64.add 232L 3434L ;;
    - : int64 = 3666L

    (* Simplifying Number Operators *)

    # let fun1 x y = 10 * x - 4 * y ;;
    val fun1 : int -&gt; int -&gt; int = &lt;fun&gt;

    # fun1 45 23 ;;
    - : int = 358

    # fun1 45L 23L ;;
    Error: This expression has type int64 but an expression was expected of type int

    (* Defining the function to 64 bits *)

     # let fun1L x y =
                 let (-) = Int64.sub in
                 let ( * ) = Int64.mul in
                 10L * x - 4L * y
        ;;val fun1L : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;

    # fun1L 45L 23L ;;
    - : int64 = 358L

    (* Trick Creating an Operator Module *)

    # module OP =
    struct
        module FL =
        struct
            let (+) = (+.)
            let (-) = (-.)
            let ( * ) = ( *. )
            let (/) = (/.)
        end

        module I32 =
        struct
            let (+) = Int32.add
            let (-) = Int32.sub
            let (/) = Int32.div
            let ( * ) = Int32.mul
        end

        module I64 =
        struct
            let (+) = Int64.add
            let (-) = Int64.sub
            let ( * ) = Int64.mul
            let (/) = Int64.div
        end

    end
      ;;
    module OP :
      sig
        module FL :
          sig
            val ( + ) : float -&gt; float -&gt; float
            val ( - ) : float -&gt; float -&gt; float
            val ( * ) : float -&gt; float -&gt; float
            val ( / ) : float -&gt; float -&gt; float
          end
        module I32 :
          sig
            val ( + ) : int32 -&gt; int32 -&gt; int32
            val ( - ) : int32 -&gt; int32 -&gt; int32
            val ( / ) : int32 -&gt; int32 -&gt; int32
            val ( * ) : int32 -&gt; int32 -&gt; int32
          end
        module I64 :
          sig
            val ( + ) : int64 -&gt; int64 -&gt; int64
            val ( - ) : int64 -&gt; int64 -&gt; int64
            val ( * ) : int64 -&gt; int64 -&gt; int64
            val ( / ) : int64 -&gt; int64 -&gt; int64
          end
      end
    #

(* Defined for int *)

    # let fun1 x y = 10 * x - 4 * y ;;
    val fun1 : int -&gt; int -&gt; int = &lt;fun&gt;

    # fun1 100 20 ;;
    - : int = 920

(* Defined for Int32 *)

    # let fun1_int32 x y  =
        let open OP.I32 in
        10l * x - 4l * y
    ;;
    val fun1_int32 : int32 -&gt; int32 -&gt; int32 = &lt;fun&gt;

    # fun1_int32 100l 20l ;;
    - : int32 = 920l

    (* OR for short *)

    # let fun1_int32_ x y  = OP.I32.(10l  * x - 4l * y) ;;
    val fun1_int32_ : int32 -&gt; int32 -&gt; int32 = &lt;fun&gt;

    # fun1_int32_ 100l 20l ;;
    - : int32 = 920l

(* Defined for Int64 *)

    # let fun1_int64 x y  =
            let open OP.I64 in
            10L * x - 4L * y
        ;;
    val fun1_int64 : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;

    # fun1_int64 100L 20L ;;
    - : int64 = 920L

    (* OR *)

    # let fun1_int64_ x y = OP.I64.(10L * x - 4L * y) ;;
    val fun1_int64_ : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;

(* Defined for Float *)

    # let fun1_float x y  =
                let open OP.FL in
                10. * x - 4. * y
            ;;
    val fun1_float : float -&gt; float -&gt; float = &lt;fun&gt;

    # fun1_float 100. 20. ;;
    - : float = 920.

    (* OR *)

    # let fun1_float_ x y  = OP.FL.(10.  * x - 4. * y) ;;
    val fun1_float_ : float -&gt; float -&gt; float = &lt;fun&gt;

    # fun1_float_ 100. 20. ;;
    - : float = 920.
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> Math / Float Functions</h4>
<div class="outline-text-4" id="text-1-4-7">
<p>
Documentation:
</p>

<p>
OCaml's floating-point complies with the <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754 standard</a>,  double precision (64 bits) numbers.
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">(* Operators *)

    # (+.) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;
    # (-.) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;
    # (/.) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;
    # ( *. ) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;

     (* Power operator/ Exponentiation *)
     # ( ** ) ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;

    # List.map ( (+.) 2.323) [10.23; 3.4; 30. ; 12. ] ;;
    - : float list = [12.553; 5.723; 32.323; 14.323]

    # List.map ( ( *. ) 3.) [10.23; 3.4; 30. ; 12. ] ;;
    - : float list = [30.69; 10.2; 90.; 36.]

    # List.map (fun x -&gt; 2. ** x ) [1. ; 2.; 3.; 4.; 5.; 6.; 7.; 8.] ;;
    - : float list = [2.; 4.; 8.; 16.; 32.; 64.; 128.; 256.]

(* Absolute Value *)

    # abs_float ;;
    - : float -&gt; float = &lt;fun&gt;
    #

(* Square Root *)

    # sqrt ;;
    - : float -&gt; float = &lt;fun&gt;

(* Trigonometric *)

    # sin ;;
    - : float -&gt; float = &lt;fun&gt;
    # cos ;;
    - : float -&gt; float = &lt;fun&gt;
    # tan ;;
    - : float -&gt; float = &lt;fun&gt;
    # atan ;;
    - : float -&gt; float = &lt;fun&gt;
    # atan2 ;;
    - : float -&gt; float -&gt; float = &lt;fun&gt;
    #
    # acos ;;
    - : float -&gt; float = &lt;fun&gt;
    # asin ;;
    - : float -&gt; float = &lt;fun&gt;
    #

(* Hyperbolic Functions *)
    # cosh ;;
    - : float -&gt; float = &lt;fun&gt;
    # sinh ;;
    - : float -&gt; float = &lt;fun&gt;
    # tanh ;;
    - : float -&gt; float = &lt;fun&gt;
    #


(* Logarithm and exp *)
    # log ;;
    - : float -&gt; float = &lt;fun&gt;
    # log10 ;;
    - : float -&gt; float = &lt;fun&gt;
    # exp ;;
    - : float -&gt; float = &lt;fun&gt;

    (* exp x -. 1.0, *)
    # expm1 ;;
    - : float -&gt; float = &lt;fun&gt;

    (*  log(1.0 +. x)  *)
    # log1p ;;
- : float -&gt; float = &lt;fun&gt;


(* Remove Decimal Part *)
    # floor ;;
    - : float -&gt; float = &lt;fun&gt;
    # ceil ;;
    - : float -&gt; float = &lt;fun&gt;
    # truncate ;;
    - : float -&gt; int = &lt;fun&gt;
    #
    # int_of_float ;;
    - : float -&gt; int = &lt;fun&gt;
    #


(* Float Constants *)

    # infinity ;;
    - : float = infinity
    #
    # neg_infinity ;;
    - : float = neg_infinity
    #

    # max_float ;;
    - : float = 1.79769313486231571e+308
    # min_float ;;
    - : float = 2.22507385850720138e-308


    # nan ;;
    - : float = nan
    #

    # 1. /. 0. ;;
    - : float = infinity
    #
    # -1. /. 0. ;;
    - : float = neg_infinity
    #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> Function Declaration</h4>
<div class="outline-text-4" id="text-1-4-8">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; let x = 34 ;;
val x : int = 34

&gt; x ;;
- : int = 34

&gt; let x = 10 in
  let y = 20 in
  let z = x*y in
  z - x - y
;;
- : int = 170

&gt; let x = 10.25 in
  let y = 30.   in
  x *. y
;;
- : float = 307.5

&gt;  let f x = 10 * x + 4 ;;
val f : int -&gt; int = &lt;fun&gt;

&gt;  f 4 ;;
- : int = 44

&gt;  f 5 ;;
- : int = 54
&gt;

&gt; let f (x, y) = x +  y ;;
val f : int * int -&gt; int = &lt;fun&gt;

&gt; f (2, 5) ;;
- : int = 7

&gt; f (10, 5) ;;
- : int = 15


&gt; let add_floats x y = x +. y ;;
val add_floats : float -&gt; float -&gt; float = &lt;fun&gt;

&gt; add_floats 10. 50.343 ;;
- : float = 60.343


&gt; let a_complex_function x y =
    let a = 10 * x in
    let b = 5 * y + x in
    a + b
;;
val a_complex_function : int -&gt; int -&gt; int = &lt;fun&gt;

(*
    a_complex_function 2 3
        a = 10 * x --&gt;  a = 10*2 = 20
        b = 5 * 3  --&gt;  b = 5*3 + 2 = 17
        a + b      --&gt;  20 + 17 = 37
*)
&gt; a_complex_function 2 3 ;;
- : int = 37


(* Function Inside functions *)

&gt; let func1 x y =
    let ft1 x y = 10*x + y in
    let ft2 x y z = x + y - 4 * z in
    let ft3 x y = x - y in
    let z = 10 in
    (ft1 x y) + (ft2 x y z) - (ft3 x y)
;;

&gt; func1 4 5 ;;
- : int = 15

&gt; func1 14 5 ;;
- : int = 115

&gt; func1 20 (-10) ;;
- : int = 130

(* Returning More than one value *)

&gt; let g x y =  (10* x, x + y) ;;

&gt; g 4 5 ;;
- : int * int = (40, 9)
</pre>
</div>

<p>
Declaring Functions with type signature.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let func1 (x:int) (y:float) : float = (float_of_int x) +. y ;;
val func1 : int -&gt; float -&gt; float = &lt;fun&gt;

&gt; func1 10 2.334 ;;
- : float = 12.334


&gt; let func2 (xy: (int * int)) : int  = (fst xy) + (snd xy) ;;
val func2 : int * int -&gt; int = &lt;fun

&gt; func2 (5, 6) ;;
- : int = 11

&gt; let show (x:float) = Printf.printf "%.3f" x ;;
val show : float -&gt; unit = &lt;fun&gt;

&gt; show 3.232 ;;
3.232- : unit = ()


&gt; let showxy (x, y) : unit = Printf.printf "%.3f\n" (x +. y) ;;
val showxy : float * float -&gt; unit = &lt;fun

&gt; showxy (32.323, 100.232) ;;
132.555
- : unit = ()


&gt; let double_list (list_of_floats : float list) : float list =
    List.map (fun x -&gt; 2.0 *. x) list_of_floats ;;
val double_list : float list -&gt; float list = &lt;fun&gt;

&gt; double_list [1. ; 2. ; 3. ; 4. ; 5. ] ;;
- : float list = [2.; 4.; 6.; 8.; 10.]
</pre>
</div>

<p>
Declaring function type with anonymous functions.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let func2' : (int * int) -&gt; int = fun (a, b) -&gt; a + b ;;
val func2' : int * int -&gt; int = &lt;fun&gt;

&gt; func2' (5, 6) ;;
- : int = 11

&gt; let showxy' : float * float -&gt; unit = fun (x, y) -&gt;
   Printf.printf "%.3f\n" (x +. y) ;;

&gt; showxy' (23.3, 5.342021321) ;;
28.642
- : unit = ()
</pre>
</div>

<p>
Declaration functions that takes another function as argument
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let apply_to_fst f (x, y) = (f x, y) ;;
val apply_to_fst : ('a -&gt; 'b) -&gt; 'a * 'c -&gt; 'b * 'c = &lt;fun&gt;

let apply_to_fst2 : ('a -&gt; 'c) -&gt; 'a * 'b  -&gt; 'c * 'b =
    fun f (x, y) -&gt;  (f x, y)

&gt; let f x = x + 10 ;;
val f : int -&gt; int = &lt;fun&gt;

&gt; apply_to_fst f (10, "hello world") ;;
- : int * string = (20, "hello world")

&gt; apply_to_fst2 f (10, "hello world") ;;
- : int * string = (20, "hello world")
</pre>
</div>

<p>
Declaring functions with custom types
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; type tuple_of_int = int * int ;;
type tuple_of_int = int * int

&gt; type func_float_to_string = float -&gt; string ;;
type func_float_to_string = float -&gt; string


&gt; type func_tuple_of_ints_to_float = int * int -&gt; float ;;
type func_tuple_of_ints_to_float = int * int -&gt; float

&gt; let x: tuple_of_int = (10, 4) ;;
val x : tuple_of_int = (10, 4)

&gt; let f : func_float_to_string = fun x -&gt; "x = " ^ (string_of_float x) ;;
val f : func_float_to_string = &lt;fun&gt;

&gt; f 2.23 ;;
- : string = "x = 2.23"

&gt; let funct : tuple_of_int -&gt; int = fun (x, y) -&gt; x + y ;;
val funct : tuple_of_int -&gt; int = &lt;fun&gt;

&gt; funct (10, 100) ;;
- : int = 11

&gt; let fxy : func_tuple_of_ints_to_float =
    fun (x, y) -&gt; 10.4 *. (float_of_int x) -. 3.5 *. (float_of_int y) ;;
val fxy : func_tuple_of_ints_to_float = &lt;fun&gt;

&gt; fxy ;;
- : func_tuple_of_ints_to_float = &lt;fun&gt;

&gt; fxy (10, 5) ;;
- : float = 86.5


&gt; type list_of_float = float list ;;
type list_of_float = float list

&gt; let double (xs: list_of_float) : list_of_float = List.map (fun x -&gt; 2.0 *. x) xs ;;
val double : list_of_float -&gt; list_of_float = &lt;fun&gt;

&gt; double [1. ; 2. ; 3. ; 4. ; 5. ] ;;
- : list_of_float = [2.; 4.; 6.; 8.; 10.]

&gt; double ;;
- : list_of_float -&gt; list_of_float = &lt;fun&gt;

&gt; let double2 : list_of_float -&gt; list_of_float =
  fun xs -&gt; List.map (fun x -&gt; 2.0 *. x) xs ;;
val double2 : list_of_float -&gt; list_of_float = &lt;fun&gt;

&gt; double2 ;;
- : list_of_float -&gt; list_of_float = &lt;fun&gt;

&gt; double2 [1. ; 2. ; 3. ; 4. ; 5. ] ;;
- : list_of_float = [2.; 4.; 6.; 8.; 10.]
</pre>
</div>

<p>
Functions with Named Parameters
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let f1 ~x ~y = 10* x - y ;;
val f1 : x:int -&gt; y:int -&gt; int = &lt;fun&gt;

&gt; f1 ;;
- : x:int -&gt; y:int -&gt; int = &lt;fun&gt;

&gt; f1 4 5 ;;
- : int = 35

&gt; f1 20 15 ;;
- : int = 185

(* Currying Funcctions with named parameters *)
&gt; f1 20 ;;
Error: The function applied to this argument has type x:int -&gt; y:int -&gt; int                      This argument cannot be applied without label

&gt; f1 ~x:20 ;;
- : y:int -&gt; int = &lt;fun&gt;

&gt; let f1_20 = f1 ~x:20 ;;
val f1_20 : y:int -&gt; int = &lt;fun&gt;

&gt; f1_20 10 ;;
- : int = 190

&gt; f1_20 40 ;;
- : int = 160

&gt; List.map f1_20 [1; 2; 10; 20; 30] ;;
Error: This expression has type y:int -&gt; int but an expression was expected of type 'a -&gt; 'b

&gt; List.map (fun y -&gt; f1_20 y) [1; 2; 10; 20; 30] ;;
- : int list = [199; 198; 190; 180; 170]

&gt; let show_msg x ~msg () = Printf.printf "%s = %d" msg x ;;
val show_msg : int -&gt; msg:string -&gt; unit -&gt; unit = &lt;fun&gt;

&gt; show_msg 2 "Hello world" () ;;
Hello world = 2- : unit = ()

&gt; show_msg 20  ;;
- : msg:string -&gt; unit -&gt; unit = &lt;fun&gt;

&gt; let f = show_msg 20 ;;
val f : msg:string -&gt; unit -&gt; unit = &lt;fun&gt;

&gt; f "x" ();;
x = 20- : unit = ()

&gt; f "y" () ;;
y = 20- : unit = ()

&gt; List.iter f ["x" ; "y" ; "z" ; "w"] ;;
Error: This expression has type msg:string -&gt; unit -&gt; unit
but an expression was expected of type 'a -&gt; unit

&gt; List.iter (fun msg -&gt; f msg ()) ["x" ; "y" ; "z" ; "w"] ;;
x = 20y = 20z = 20w = 20- : unit = ()
</pre>
</div>

<p>
Functions with Optional Parameters:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(*
    If the parameter x is not given, x will be set to 100
*)
&gt; let f ?(x = 100)  y = 10*x - 5*y ;;
val add : ?x:int -&gt; int -&gt; int = &lt;fun&gt;

&gt; f ;;
- : ?x:int -&gt; int -&gt; int = &lt;fun&gt;

(*
    f 20 ==&gt; (10*x - 5*y) 100 20
             (10 * 10 - 5 * 20 )
             (1000 - 100)
             900
 *)
&gt; f 20 ;;
- : int = 900


(*
    f 60 ==&gt; (10*x - 5*y) 100 60
             (10*100 - 5*60)
             (1000 - 300)
             700
*)
&gt; f 60 ;;
- : int = 700

&gt; List.map f [10; 20; 30; 40; 50] ;;
- : int list = [950; 900; 850; 800; 750]


&gt; f ~x:40 20 ;;
- : int = 300


&gt; f ~x:50 20 ;;
- : int = 400

&gt; f ~x:40 ;;
- : int -&gt; int = &lt;fun&gt;

&gt; let f_x40  = f ~x:40 ;;
val f_x40 : int -&gt; int = &lt;fun&gt;

&gt; List.map f_x40 [10; 20; 30; 40; 50] ;;
- : int list = [350; 300; 250; 200; 150]

&gt; List.map (f ~x: 40) [10; 20; 30; 40; 50] ;;
- : int list = [350; 300; 250; 200; 150]


&gt; let rectangle_area ?(width = 30) ~height = width*height ;;
val rectangle_area : ?width:int -&gt; height:int -&gt; int = &lt;fun&gt;

&gt; rectangle_area 20 ;;
- : int = 600

&gt; rectangle_area 30 ;;
- : int = 900

&gt; List.map rectangle_area [10; 20; 30; 40; 50] ;;
Error: This expression has type ?width:int -&gt; height:int -&gt; int
but an expression was expected of type 'a -&gt; 'b

&gt; List.map (fun h -&gt; rectangle_area h ) [10; 20; 30; 40; 50] ;;
- : int list = [300; 600; 900; 1200; 1500]

&gt; rectangle_area ~width: 200 ;;
- : height:int -&gt; int = &lt;fun&gt;

&gt;: rectangle_area ~width: 200 ~height: 20 ;;
- : int = 4000

&gt; List.map (fun h -&gt; rectangle_area ~height:h ~width:30 )
[10; 20; 30; 40; 50] ;;
- : int list = [300; 600; 900; 1200; 1500]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-9" class="outline-4">
<h4 id="sec-1-4-9"><span class="section-number-4">1.4.9</span> Function Composition</h4>
<div class="outline-text-4" id="text-1-4-9">
<p>
Operators:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Composition Operator *)
let (&lt;&lt;) f g x = f (g x) ;;

(* F# Piping Composition Operator *)
let (&gt;&gt;) f g x = g( f x) ;;

(* F# Piping Operator *)
let (|&gt;) x f  = f x ;;

let (&lt;|) f x = f x ;;
</pre>
</div>

<p>
Example: Composition Operator
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt;  let f1 x = 10 + x ;;
val f1 : int -&gt; int = &lt;fun&gt;

&gt;  let f2 x = 2 * x ;;
val f2 : int -&gt; int = &lt;fun&gt;

&gt;  let f3 x = x - 8 ;;
val f3 : int -&gt; int = &lt;fun&gt;

&gt;  f1( f2 (f3 10)) ;;
- : int = 14
&gt;

&gt;  (f1 &lt;&lt; f2 &lt;&lt; f3) 10 ;;
- : int = 14
&gt;


&gt;  let f = f1 &lt;&lt; f2 &lt;&lt; f3 ;;
val f : int -&gt; int = &lt;fun&gt;
&gt;  f 10 ;;
- : int = 14
&gt;  f 20 ;;
- : int = 34
&gt;
</pre>
</div>

<p>
Example: Pipe Operators
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt;
  10 |&gt; f3 |&gt; f2 |&gt; f1 ;;
- : int = 14

&gt;
  10 |&gt; f3 ;;
- : int = 2

&gt;  2 |&gt; f2 ;;
- : int = 4

&gt;  4 |&gt; f1 ;;
- : int = 14
&gt;


&gt; 10 |&gt; (f3 &gt;&gt; f2 &gt;&gt; f1) ;;
- : int = 14

&gt; f3 &gt;&gt; f2 &gt;&gt; f1  &lt;| 10 ;;
- : int = 14


&gt; let f = f3 &gt;&gt; f2 &gt;&gt; f1 ;;
val f : int -&gt; int = &lt;fun&gt;

&gt; f 10 ;;
- : int = 14
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-10" class="outline-4">
<h4 id="sec-1-4-10"><span class="section-number-4">1.4.10</span> Lambda Functions/ Anonymous Functions</h4>
<div class="outline-text-4" id="text-1-4-10">
<p>
Anonymous functions, also known as lambda functions, are useful to pass already existing functions to another functions as arguments and create closures.  They are specially useful when used with map filter and another higher order functions. They can be seen as bolts that connect one part to another.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">fun x -&gt; x+1                       : int -&gt; int
fun x -&gt; x +. 1.0                  : float -&gt; float
fun x -&gt; x ^ x                     : string -&gt; string
fun (x,y) -&gt; x + y                 : (int * int) -&gt; int
fun (x,y) -&gt; (y,x)                 : ('a*'b) -&gt; ('b*'a)
fun x y -&gt; (x,y)                   : 'a -&gt; 'b -&gt; ('a*'b)
fun x y z -&gt; (x,y,z)               : 'a -&gt; 'b -&gt; 'c -&gt; ('a*'b*'c)
</pre>
</div>

<p>
In the shell:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; fun x -&gt; x+1  ;;
- : int -&gt; int = &lt;fun&gt;

&gt; (fun x -&gt; x+1) 10 ;;
- : int = 11

&gt; let f = fun x -&gt; x+1 ;;
val f : int -&gt; int = &lt;fun&gt;

&gt; f 10 ;;
- : int = 11

&gt; List.map (fun x -&gt; x+1) [1; 2; 3; 4; 5 ] ;;
- : int list = [2; 3; 4; 5; 6]

&gt; 


&gt; (fun x y z -&gt;  10 * x + 4 * z - 3 * x * y) 1 ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

(* x = 1 *) 
&gt; (fun x y z -&gt;  10 * x + 4 * z - 3 * x * y) 1 ;; 
- : int -&gt; int -&gt; int = &lt;fun&gt;

(* x = 1 y = 2 *) 
&gt; (fun x y z -&gt;  10 * x + 4 * z - 3 * x * y) 1 2 ;;  
- : int -&gt; int = &lt;fun&gt;

(* x = 1 y = 2  z = 3 *) 
&gt; (fun x y z -&gt;  10 * x + 4 * z - 3 * x * y) 1 2 3 ;; 
- : int = 16 

(* Partial Evaluation *)
(*----------------------*)

&gt; let f = fun x y z -&gt;  10 * x + 4 * z - 3 * x * y ;;
val f : int -&gt; int -&gt; int -&gt; int = &lt;fun&gt;

&gt; (f 1) ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

&gt; ((f 1) 2) ;;
- : int -&gt; int = &lt;fun&gt;

&gt; (((f 1) 2) 3) ;;
- : int = 16

&gt; f 1 2 3 ;;
- : int = 16


(* x= ?, y=?, z=3 The variables x and y varies *)
&gt; List.map (fun (x, y) -&gt; f x y 3) [(1, 2); (3, 4); (5, 6)]  ;;
- : int list = [16; 6; -28]


(* x= ?, y=2, z=? The variables x and z varies *) 
&gt; List.map (fun (x, z) -&gt; f x 2 z) [(1, 2); (3, 4); (5, 6)]  ;;
- : int list = [12; 28; 44]


(* All variables varies *)
&gt; List.map (fun (x, y, z) -&gt; f x y z) [(1, 2, 3); (2, 3, 1); (3, 4, 5)] ;;
- : int list = [16; 6; 14]

(** Filtering                      *)
(**--------------------------------*)

&gt; List.filter (fun x -&gt; x &gt; 5) [1; 2; 3; -3; 10; 4; 50] ;;
- : int list = [10; 50]

&gt; List.filter (fun (x, y) -&gt; x + y &gt; 10) [(-10, 30); (5, 4); (12, -8); (9, 8)] ;;
- : (int * int) list = [(-10, 30); (9, 8)]


&gt; [(-10, 30); (5, 4); (12, -8); (9, 8)]
|&gt; List.filter (fun (x, y) -&gt; x + y &gt; 10)
;;
- : (int * int) list = [(-10, 30); (9, 8)]

(** Filters and maps be combined with the (|&gt;) pipelining operator to process data *)

&gt; [(-10, 30); (5, 4); (12, -8); (9, 8)]
|&gt; List.filter (fun (x, y) -&gt; x + y &gt; 10)
|&gt; List.map (fun (x, y) -&gt; 4 * x + 3 * y) 
;;
- : int list = [50; 60]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-11" class="outline-4">
<h4 id="sec-1-4-11"><span class="section-number-4">1.4.11</span> Recursive Functions</h4>
<div class="outline-text-4" id="text-1-4-11">
<div class="org-src-container">

<pre class="src src-ocaml">    # let rec factorial1 n =
        match n with
        | 0 -&gt; 1
        | 1 -&gt; 0
        | k -&gt; k * factorial1 (k - 1)
    ;;
    val factorial1 : int -&gt; int = &lt;fun&gt;

    # let rec factorial2 = function
        | 0     -&gt; 1
        | 1     -&gt; 1
        | n     -&gt; n * factorial2 (n - 1)
    ;;
    val factorial2 : int -&gt; int = &lt;fun&gt;

    # factorial1 5 ;;
    - : int = 120

     # factorial2 5 ;;
    - : int = 120

    # let rec map f xs =   match xs with
        | []        -&gt;  []
        | h::tl     -&gt;  (f h)::(map f tl)
    ;;
    val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;

    # map ((+) 5) [10; 20; 25 ; 9] ;;
    - : int list = [15; 25; 30; 14]

    # let rec sumlist = function
        | []        -&gt; 0
        | [a]       -&gt; a
        | (hd::tl)  -&gt; hd + sumlist tl
    ;;
    val sumlist : int list -&gt; int = &lt;fun&gt;

    # sumlist [1; 2; 4; 5; 6; 7; 8; 9] ;;
    - : int = 42

    # let rec prodlist = function
        | []        -&gt; 1
        | [a]       -&gt; a
        | (hd::tl)  -&gt; hd * prodlist tl
    ;;
    val prodlist : int list -&gt; int = &lt;fun&gt;

    # prodlist [1 ; 2; 3; 4; 5; 6 ] ;;
    - : int = 720

    # let rec filter f xs = match xs with
        | []        -&gt; []
        | h::tl     -&gt; if f h
                       then h::(filter f tl)
                       else filter f tl

    ;;

     # filter (fun x -&gt; x &lt; 10) [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = [1; 2; 4; 6]


    # let rec take n xs =
        match (n, xs) with
        | (0, _    ) -&gt; []
        | (_, []   ) -&gt; []
        | (k, h::tl) -&gt; k::(take (n-1) tl)
    ;;val take : int -&gt; 'a list -&gt; int list = &lt;fun&gt;

    # take 3 [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = [3; 2; 1]
    # take 20 [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = [20; 19; 18; 17; 16; 15; 14]


    # let rec drop n xs =
        if n &lt; 0 then failwith "n negative"
        else
            match (n, xs) with
            | (0, _ )    -&gt;  xs
            | (_, [])    -&gt;  []
            | (k, h::tl) -&gt;  drop (k-1) tl
    ;;val drop : int -&gt; 'a list -&gt; 'a list = &lt;fun&gt;

    # drop (-10)  [1; 2; 10; 20; 4; 6; 15] ;;
    Exception: Failure "n negative".

    # drop 10 [] ;;
    - : 'a list = []

    # drop 0 [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = [1; 2; 10; 20; 4; 6; 15]

    # drop 5 [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = [6; 15]

    # drop 25 [1; 2; 10; 20; 4; 6; 15] ;;
    - : int list = []

(*

    Haskell Function:
    foldl1 : ( a -&gt; a -&gt; a ) -&gt; [a] -&gt; [a]

    &gt; foldl1 (\x y -&gt; 10*x + y) [1, 2, 3, 4, 5]
    12345

    foldl1 f  [1, 2, 3, 4, 5]  =
    f 5 (f 4 (f 3 (f 1 2)))

    foldl f [x0, x1, x2, x3, x4, x5 ... ] =

    f xn (f xn-1 (f xn-2 ... (f x3 (f x2 (f x1 x0))))) ....

    From: http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
*)

    let rec foldl1 f xs =
        match xs with
        | []            -&gt; failwith "Empty list"
        | [x]           -&gt; x
        | (x::y::tl)    -&gt; foldl1 f (f x y :: tl)
    ;;

    # foldl1 (fun x y -&gt; 10*x + y) [1; 2; 3; 4; 5] ;;
    - : int = 12345


    # let rec foldr1 f xs =
        match xs with
        | []        -&gt; failwith "Empty list"
        | [x]       -&gt; x
        | x::tl     -&gt; f x (foldr1 f tl)
    ;;
    val foldr1 : ('a -&gt; 'a -&gt; 'a) -&gt; 'a list -&gt; 'a = &lt;fun&gt;

    # foldr1 (fun x y -&gt; x + 10*y) [1; 2; 3; 4; 5; 6] ;;
    - : int = 654321

    # let rec foldl f acc xs =
        match xs with
        | []     -&gt; acc
        | x::tl  -&gt; foldl f (f acc x) tl
    ;;

    # foldl (fun x y -&gt; 10*x + y) 0  [1; 2; 3; 4; 5; 6] ;;
    - : int = 123456

    # let rec foldr f acc xs =
        match xs with
        | []    -&gt; acc
        | x::tl -&gt; f x (foldr f acc tl)
    ;;
    val foldr : ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b = &lt;fun&gt;

    # foldr (fun x y -&gt; x + 10*y) 0  [1; 2; 3; 4; 5; 6] ;;
    - : int = 654321


    # let rec range start stop step =
        if start &gt; stop
        then []
        else start::(range  (start + step) stop step )
    ;;
    val range : int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;

    # range 0 30 1 ;;
    - : int list =  [0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14;
    15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25;    26; 27; 28; 29; 30]

    # range 0 100 10 ;;
    - : int list = [0; 10; 20; 30; 40; 50; 60; 70; 80; 90; 100]

    # range (-100) 100 10 ;;
    - : int list = [-100; -90; -80; -70; -60; -50; -40; -30; -20;
    -10; 0; 10; 20; 30; 40; 50; 60; 70; 80; 90; 100]
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-4-12" class="outline-4">
<h4 id="sec-1-4-12"><span class="section-number-4">1.4.12</span> Mutable References</h4>
<div class="outline-text-4" id="text-1-4-12">
<div class="org-src-container">

<pre class="src src-ocaml">(** Declare a reference *)

    #  let x = ref 0 ;;
    val x : int ref = {contents = 0}
    # 

(** Get the value of a reference *)

    # !x ;;
    - : int = 0
    # 

(** Set the value of a reference *)

    # (:=) ;;
    - : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
    # 

    # x := 100 ;;
    - : unit = ()
    # 

(** Update a reference *)

    #  x:= !x + 100 ;;
    - : unit = ()

    # x ;;
    - : int ref = {contents = 100}
    # 

(** A reference can be accessed inside a function *)


    # let x = ref 10 ;;
    val x : int ref = {contents = 10}
    # 

    let add_10_to_x () = 
              x := !x + 10 
            ;;
    val add_10_to_x : unit -&gt; unit = &lt;fun&gt;
    # 

    #  add_10_to_x () ;;
    - : unit = ()
    # x ;;
    - : int ref = {contents = 20}

    # add_10_to_x () ;;
    - : unit = ()
    # x ;;
    - : int ref = {contents = 30}
    # 

(** Functions that operates references *)

    # let y = ref 10 ;;
    val y : int ref = {contents = 10}
    # 

    #  let get_ref x = !x ;;
    val get_ref : 'a ref -&gt; 'a = &lt;fun&gt;

    #  get_ref y ;;
    - : int = 10
    #     

    # let set_ref r new_value = 
          r := new_value 
      ;;
    val set_ref : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;
    # 

    #  set_ref y 100 ;;
    - : unit = ()
    # y ;;
    - : int ref = {contents = 100}
    # 

    #  let add_x_to_ref r x = 
         r := !r + x 
      ;;
    val add_x_to_ref : int ref -&gt; int -&gt; unit = &lt;fun&gt;
    # 


    #  add_x_to_ref y 200 ;;
    - : unit = ()

    # y ;;
    - : int ref = {contents = 300}
    # 

    (* 
        y &lt;-- y + 1 + 2 + 3 + 4 + 5 + 6 
    *)
    # List.iter (add_x_to_ref y) [1; 2; 3; 4; 5; 6] ;;
    - : unit = ()
    # y ;;
    - : int ref = {contents = 321}
    # 


    (*******************)

    # let y = ref 10 ;;
    val y : int ref = {contents = 10}
    #     

    #  let add_10_to_ref r =
         r := !r + 10 
      ;;
    val add_10_to_ref : int ref -&gt; unit = &lt;fun&gt;
    # 

    # add_10_to_ref y ;;
    - : unit = ()
    # y ;;
    - : int ref = {contents = 20}
    # 

    #  add_10_to_ref y ;;
    - : unit = ()
    # y ;;
    - : int ref = {contents = 30}
    # 

    (*********************************)

    #  let swap_ref a b = 
          let c = !a in
            a := !b ;
            b := c
      ;;
    val swap_ref : 'a ref -&gt; 'a ref -&gt; unit = &lt;fun&gt;
    # 

    #  let x = ref 10 ;;
    val x : int ref = {contents = 10}
    # let y = ref 20 ;;
    val y : int ref = {contents = 20}
    # 
      swap_ref x y ;;
    - : unit = ()
    # x ;;
    - : int ref = {contents = 20}
    # y ;;
    - : int ref = {contents = 10}
    # 

(** Capturing references with closures *)


    let make_counter () = 
              let i = ref 0 in
              fun () -&gt;
                i:= !i + 1 ;
                !i
                ;;
    val make_counter : unit -&gt; unit -&gt; int = &lt;fun&gt;
    # 


    # let counter1 = make_counter () ;;
    val counter1 : unit -&gt; int = &lt;fun&gt;
    # 
      counter1 () ;;
    - : int = 1
    # counter1 () ;;
    - : int = 2
    # counter1 () ;;
    - : int = 3
    # counter1 () ;;
    - : int = 4
    # 

    #  let counter2 = make_counter () ;;
    val counter2 : unit -&gt; int = &lt;fun&gt;
    # counter2 () ;;
    - : int = 1
    # counter2 () ;;
    - : int = 2
    # counter1 () ;;
    - : int = 5
    #         

(** Miscellaneous *)


    # let lst = ref [1.0; 2.0; 3.0] ;;
    val lst : float list ref = {contents = [1.; 2.; 3.]}

    # !lst ;;
    - : float list = [1.; 2.; 3.]

    # List.nth (!lst) 0 ;;
    - : float = 1.
    # List.nth (!lst) 2 ;;
    - : float = 3.
    # 

    # List.map (fun x -&gt; x *. 2.) !lst ;;
    - : float list = [2.; 4.; 6.]
    # 

    # lst := List.map (fun x -&gt; x *. 2.) !lst ;;
    - : unit = ()
    # lst ;;
    - : float list ref = {contents = [2.; 4.; 6.]}
    # 

    #  lst := !lst @ [3.23; 832.23; 90.23] ;;
    - : unit = ()
    # lst ;;
    - : float list ref = {contents = [2.; 4.; 6.; 3.23; 832.23; 90.23]}
    #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-13" class="outline-4">
<h4 id="sec-1-4-13"><span class="section-number-4">1.4.13</span> Control Structures</h4>
<div class="outline-text-4" id="text-1-4-13">
<p>
Conditional Expressions
</p>

<div class="org-src-container">

<pre class="src src-ocaml">let test x =
if x &gt; 0
then print_string "x is positive"
else print_string "x is negative"
;;


val test : int -&gt; unit = &lt;fun&gt;

&gt; test 10 ;;
x is positive- : unit = ()

&gt; test (-10) ;;
x is negative- : unit = ()


&gt; let sign x =
  if x = 0
    then 0
  else if x &gt; 0
       then 1
       else (-1)
;;
val sign : int -&gt; int = &lt;fun&gt;

&gt; List.map sign [1; -1; 0; 2; 3] ;;
- : int list = [1; -1; 0; 1; 1]

&gt;
</pre>
</div>

<p>
For Loop:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; for i = 0 to 5 do Printf.printf "= %i\n" i  done ;;
= 0
= 1
= 2
= 3
= 4
= 5
- : unit = ()

&gt; for i = 10 downto 1 do
  Printf.printf "%d .. " i
done;
  ;;
10 .. 9 .. 8 .. 7 .. 6 .. 5 .. 4 .. 3 .. 2 .. 1 .. - : unit = ()
</pre>
</div>

<p>
While Loop:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let j = ref 5 ;;
val j : int ref = {contents = 5}

&gt; while !j &gt; 0 do Printf.printf "x = %d\n" !j ; j := !j -1 done ;;
x = 5
x = 4
x = 3
x = 2
x = 1
- : unit = ()
</pre>
</div>

<p>
Infinite While Loop
</p>

<pre class="example">
utop # while true do
    print_string "hello world / hit return to continue ";
    read_line ();
done;
;;

Characters 77-90:                                                                       Warning 10: this expression should have type unit.                                      Characters 77-90:
Warning 10: this expression should have type unit.
hello world / hit return to continue
hello world / hit return to continue
hello world / hit return to continue
hello world / hit return to continue ^CInterrupted.

utop # let mainloop () =
      while true do
          print_string "hello world / hit return to continue ";
          read_line ();
      done;

  ;;
Warning 10: this expression should have type unit.
val mainloop : unit -&gt; unit = &lt;fun&gt;

utop # mainloop()   ;;
hello world / hit return to continue
hello world / hit return to continue
hello world / hit return to continue
hello world / hit return to continue
hello world / hit return to continue
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Standard (Native) Library Modules</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Then native library is small and lacks many things someone would like
and most functions are <a href="https://blogs.janestreet.com/optimizing-list-map/">not tail recursive</a>, it means that it will
overflow stack for a very big number of iterations. For a better
standard library see: Batteries and Core.
</p>


<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref">Documentation</a>
</li>
</ul>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> List</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
The module List has almost all functions to process lists which are immutable data structures.
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html</a>
</li>
</ul>

<p>
Cons and Nil
</p>
<div class="org-src-container">

<pre class="src src-ocaml">[] : 'a list                    (*     Nil *)
:: : 'a -&gt; 'a list -&gt; 'a list   (* :: Cons *)
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">&gt;   23::[] ;;
- : int list = [23]
&gt;  12::23::[] ;;
- : int list = [12; 23]
&gt;  34::12::23::[] ;;
- : int list = [34; 12; 23]

&gt;  1::[2; 34; 55] ;;
- : int list = [1; 2; 34; 55]
&gt;

&gt;  []::[] ;;
- : 'a list list = [[]]
&gt;  []::[]::[] ;;
- : 'a list list = [[]; []]
</pre>
</div>

<p>
List Functions
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Concatenate Lists *)
&gt; (@) ;;
- : 'a list -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
&gt; [1; 2; 3; 4; 5] @ [5; 6; 8] ;;
- : int list = [1; 2; 3; 4; 5; 5; 6; 8]
&gt;

(* First element of a list / head of the list *)
&gt; List.hd [1 ; 2; 3; 4 ; 6 ; 9] ;;
- : int = 1

(* Remove first Element of a list/ tail of the list *)
  List.tl [1 ; 2; 3; 4; 5; 6; 9] ;;
- : int list = [2; 3; 4; 5; 6; 9]

&gt;  sum [1 ; 2; 3; 4; 5; 6; 7] ;;
- : int = 28

(* Reverse List *)
&gt;  List.rev [1; 2; 3; 4] ;;
- : int list = [4; 3; 2; 1]

(* Pick Element *)
&gt; List.nth [0; 1; 2; 3; 4 ] 0 ;;
- : int = 0
&gt; List.nth [0; 1; 2; 3; 4 ] 1 ;;
- : int = 1
&gt; List.nth [0; 1; 2; 3; 4 ] 2 ;;
- : int = 2
&gt; List.nth [0; 1; 2; 3; 4 ] 3 ;;
- : int = 3

(* List Lenght *)
&gt; List.length [0; 1; 2; 3; 4 ] ;;
- : int = 5
&gt; List.length [0; 1; 2] ;;
- : int = 3

(* Combine - Equivalent to Haskell zip *)
&gt; List.combine ;;
- : 'a list -&gt; 'b list -&gt; ('a * 'b) list = &lt;fun&gt;

&gt; List.combine [1; 2; 3] ['a'; 'b'; 'c' ] ;;
- : (int * char) list = [(1, 'a'); (2, 'b'); (3, 'c')]

&gt; List.combine [1; 2; 3; 5 ] ['a'; 'b'; 'c' ] ;;
Exception: Invalid_argument "List.combine".
&gt;

(* Split - Equivalent to Haskell unzip *)

&gt; List.split  [(1, 'a'); (2, 'b'); (3, 'c')] ;;
- : int list * char list = ([1; 2; 3], ['a'; 'b'; 'c'])
&gt;

&gt;  List.split  [(1, 'a'); (2, 'b'); (3, 'c')] ;;
- : int list * char list = ([1; 2; 3], ['a'; 'b'; 'c'])
&gt;


(* Equivalent to Haskell (++) *)

&gt; List.append [0; 2; 3; 5; 6 ] [1; 2; 6] ;;
- : int list = [0; 2; 3; 5; 6; 1; 2; 6]

(* Find *)

&gt; List.find  (fun x -&gt; x &lt; 10) [1; 2 ; 3; 45] ;;
- : int = 1

&gt; List.find  (fun x -&gt; x &gt; 10) [1; 2 ; 3; 45] ;;
- : int = 45

&gt;
&gt; List.find  (fun x -&gt; x &gt; 10) [1; 2 ; 3] ;;
Exception: Not_found.
&gt;

&gt; List.find  (fun x -&gt; x &gt; 100) [1; 2 ; 3; 45] ;;
Exception: Not_found.


&gt; List.find_all  (fun x -&gt; x &gt; 10) [-10; 20 ; 3; 12; 100; 4; 35] ;;
- : int list = [20; 12; 100; 35]

&gt; List.exists ;;
- : ('a -&gt; bool) -&gt; 'a list -&gt; bool = &lt;fun&gt;
&gt; List.exists ((==) 10) [1; 2; 30; 50 ; 3];;
- : bool = false
&gt; List.exists ((==) 10) [1; 2; 30; 10 ; 50 ; 3];;
- : bool = true

&gt; List.for_all2 (&gt;=) [1;2;3] [2;3;4];;
- : bool = false
&gt; List.exists2 (&lt;) [1;2;3] [1;2;3] ;;
- : bool = false
&gt;  List.exists2 (&lt;) [1;2;0] [1;2;3] ;;
- : bool = true
&gt;  List.exists2 (&lt;) [1;2;0] [1;2];;
Exception: Invalid_argument "List.exists2".
&gt;

&gt; List.assoc 3 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
- : string = "d"
&gt; List.assoc 0 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
- : string = "a"
&gt; List.assoc 5 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
Exception: Not_found.
&gt;

&gt; List.mem_assoc 5 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
- : bool = false
&gt; List.mem_assoc 3 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
- : bool = true
&gt; List.mem_assoc 2 [(0, "a"); (1, "b"); (2, "c"); (3, "d")] ;;
- : bool = true
&gt;

&gt; List.remove_assoc 0 [0,"a"; 1,"b"; 2,"c"; 3,"d"];;
- : (int * string) list = [(1, "b"); (2, "c"); (3, "d")]



(* Partition *)

&gt; List.partition ;;
- : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list = &lt;fun&gt;
&gt;
&gt; List.partition   (fun x -&gt; x &gt; 10) [-10; 20 ; 3; 12; 100; 4; 35] ;;
- : int list * int list = ([20; 12; 100; 35], [-10; 3; 4])


(* Flatten  *)

&gt; List.flatten ;;
- : 'a list list -&gt; 'a list = &lt;fun&gt;
&gt;

&gt; List.flatten [[1]; [2; 4] ; [6; 90; 100] ; []] ;;
- : int list = [1; 2; 4; 6; 90; 100]
&gt;


(*      MAP         *)
(*------------------*)

&gt; List.map ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
&gt;
&gt; List.map (( *) 10 )  [-10 ; 20 ; 5 ; 50; 100; 3 ] ;;
- : int list = [-100; 200; 50; 500; 1000; 30]

&gt; List.map ((+) 10) [-10 ; 20 ; 5 ; 50; 100; 3 ] ;;
- : int list = [0; 30; 15; 60; 110; 13]
&gt;

&gt; let f x = 10 * x - 5 ;;
val f : int -&gt; int = &lt;fun&gt;
&gt; List.map f  [-10 ; 20 ; 5 ; 50; 100; 3 ] ;;
- : int list = [-105; 195; 45; 495; 995; 25]
&gt;

&gt; List.map (fun x -&gt; 10.5 *. x -. 4. ) [2. ; 3. ; 5. ; 10. ; 20. ];;
- : float list = [17.; 27.5; 48.5; 101.; 206.]
&gt;

(*      MAPI        *)
(*------------------*)
&gt; List.mapi ;;
- : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;

&gt; List.mapi (fun  index element -&gt; index, element) [17.; 27.5; 48.5; 101.; 206.] ;;
- : (int * float) list = [(0, 17.); (1, 27.5); (2, 48.5); (3, 101.); (4, 206.)]


(* MAP2 / Haskell zipWith *)

&gt; List.map2 ;;
- : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list = &lt;fun&gt;
&gt;

&gt; List.map2 (+) [10; 20; 30; 100] [15; 35; 25; 80] ;;
- : int list = [25; 55; 55; 180]

&gt; List.map2 ( *) [10; 20; 30; 100] [15; 35; 25; 80] ;;
Warning 2: this is not the end of a comment.
- : int list = [150; 700; 750; 8000]

&gt; List.map2 (fun x y -&gt; (x, y)) [10; 20; 30; 100] [15; 35; 25; 80] ;;
- : (int * int) list = [(10, 15); (20, 35); (30, 25); (100, 80)]

&gt; List.map2 (fun x y -&gt; (x, y)) [10; 20; 30; 100] [15; 35; 25] ;;
Exception: Invalid_argument "List.map2".
&gt;


&gt; let fxy x y = 10*x - 4*y ;;
val fxy : int -&gt; int -&gt; int = &lt;fun&gt;
&gt;
&gt; List.map2 fxy [10; 20; 30; 100] [15; 35; 25; 80] ;;
- : int list = [40; 60; 200; 680]
&gt;


(*      FILTER      *)
(*------------------*)
&gt; List.filter ;;
- : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
&gt;
&gt;  List.filter ((&lt;) 10) [-10 ; 20 ; 5 ; 50; 100; 3 ] ;;
- : int list = [20; 50; 100]
&gt;

(*  FOLFR and FOLDL - Equivalent to Haskell foldr and foldl
 *   The fold functions are known as reduce. (i.e Python reduce (left fold))
 *)

&gt; List.fold_right ;;
- : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b = &lt;fun&gt;

    (*
        f x y = x + 10* y
        foldr  f [1; 2; 3; 5; 6] 0

    Evaluation:

    (f 1 (f 2 (f 3  (f 5 (f 6 0)))))    f 6   0  = 6 + 10*0    =     6
    (f 1 (f 2 (f 3  (f 5 6))))          f 5   6  = 5 + 10*6    =     65
    (f 1 (f 2 (f 3  65)))               f 3  65  = 3 + 10*65   =    653
    (f 1 (f 2 653))                     f 2 653  = 2 + 10*653  =    6532
    (f 1 6532)                          f 1 6532 = 1 + 10*6532 =   65321
    65321
    *)
&gt; List.fold_right (fun x y -&gt; x + 10*y) [1; 2; 3; 5; 6] 0 ;;
- : int = 65321
&gt;

&gt; List.fold_left ;;
- : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a = &lt;fun&gt;
&gt;
    (*
        f x y = 10*x + y
        flodl f 0 [1; 2; 3; 5; 6]

    Evaluation:

    (f (f (f ( f (f 0 1) 2 ) 3) 5) 6)     f 0    1 = 10*0    + 1   =    1
    (f (f (f ( f 1 2 ) 3) 5) 6)           f 1    2 = 10*1    + 2   =   12
    (f (f (f 12 3) 5) 6)                  f 12   3 = 10*12   + 3   =   123
    (f (f 123 5) 6)                       f 123  5 = 10*123  + 5   =  1235
    (f 1235 6)                            f 1235 6 = 10*1235 + 5   = 12356
    12356
    *)

&gt; List.fold_left (fun x y -&gt; 10*x +  y) 0 [1; 2; 3; 5; 6]  ;;
- : int = 12356
&gt;

&gt; List.fold_left (+) 0 [ 1; 2; 3; 4; 5; 6 ] ;;
- : int = 21

&gt; List.fold_left ( *) 1 [ 1; 2; 3; 4; 5 ] ;;
Warning 2: this is not the end of a comment.
- : int = 120



(*    ITER / MAP Non Pure Functions  *)
(*-----------------------------------*)

&gt; List.iter ;;
- : ('a -&gt; unit) -&gt; 'a list -&gt; unit = &lt;fun&gt;
&gt;

&gt; List.iter (Printf.printf "= %d \n") [-10; 3; 100; 50; 5; 20] ;;
= -10
= 3
= 100
= 50
= 5
= 20
- : unit = ()
&gt;

(* ITERI    *)

&gt; List.iteri ;;
- : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit = &lt;fun&gt;

&gt; List.iteri (Printf.printf "idendx = %d element = %d\n") [-10; 3; 100; 50; 5; 20] ;;
idendx = 0 element = -10
idendx = 1 element = 3
idendx = 2 element = 100
idendx = 3 element = 50
idendx = 4 element = 5
idendx = 5 element = 20
- : unit = ()


(* ITER2    *)
&gt; List.iter2 ;;
- : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit = &lt;fun&gt;
&gt;
&gt; List.iter2 (Printf.printf "%s = %d\n") ["x"; "y"; "z"] [1; 2; 3 ] ;;
x = 1
y = 2
z = 3
- : unit = ()
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> Array</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Arrays as oppose to lists are mmutable data structures.
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Array.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Array.html</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; [| 10; 2 ; 10; 25 ; 100; 0 ; 1 |]  ;;
- : int array = [|10; 2; 10; 25; 100; 0; 1|]

&gt; let a = [| 10; 2 ; 10; 25 ; 100; 0 ; 1 |]  ;;
val a : int array = [|10; 2; 10; 25; 100; 0; 1|]

&gt; a.(0) ;;
- : int = 10
&gt; a.(1) ;;
- : int = 2
&gt; a.(4) ;;
- : int = 100
&gt; a.(10) ;;
Exception: Invalid_argument "index out of bounds".
&gt;

&gt; Array.length ;;
- : 'a array -&gt; int = &lt;fun&gt;

&gt; Array.length a ;;
- : int = 7

&gt; Array.map ;;
- : ('a -&gt; 'b) -&gt; 'a array -&gt; 'b array = &lt;fun&gt;

&gt; Array.map (fun x -&gt; x*2 + 1) a ;;
- : int array = [|21; 5; 21; 51; 201; 1; 3|]

&gt; a.(0) &lt;- 56 ;;
- : unit = ()
&gt; a ;;
- : int array = [|56; 2; 10; 25; 100; 0; 1|]
&gt; a.(5) &lt;- 567 ;;
- : unit = ()
&gt; a ;;
- : int array = [|56; 2; 10; 25; 100; 567; 1|]

(*  Maps a function that takes the index of element
    as first argument and then the element as second
    argument.

    f(index, element)
*)
&gt; Array.mapi ;;
- : (int -&gt; 'a -&gt; 'b) -&gt; 'a array -&gt; 'b array = &lt;fun&gt;
 Array.mapi (fun idx e -&gt; idx, e) [|56; 2; 10; 25; 100; 567; 1|]  ;;
- : (int * int) array = [|(0, 56); (1, 2); (2, 10); (3, 25); (4, 100); (5, 567); (6, 1)|]


 &gt; Array.to_list ;;
- : 'a array -&gt; 'a list = &lt;fun&gt;
&gt; Array.to_list a ;;
- : int list = [56; 2; 10; 25; 100; 567; 1]


&gt; Array.of_list ;;
- : 'a list -&gt; 'a array = &lt;fun&gt;
&gt; Array.of_list [56; 2; 10; 25; 100; 567; 1] ;;
- : int array = [|56; 2; 10; 25; 100; 567; 1|]

&gt; Array.get ;;
- : 'a array -&gt; int -&gt; 'a = &lt;fun&gt;
 &gt; Array.get a 0 ;;
- : int = 56
&gt; Array.get a 20 ;;
Exception: Invalid_argument "index out of bounds".




&gt; let a = [|56; 2; 10; 25; 100; 567; 1|]  ;;
val a : int array = [|56; 2; 10; 25; 100; 567; 1|]
&gt; Array.set ;;
- : 'a array -&gt; int -&gt; 'a -&gt; unit = &lt;fun&gt;

&gt; Array.set a  0 15 ;;
- : unit = ()
&gt; Array.set a  4 235 ;;
- : unit = ()
&gt; a ;;
- : int array = [|15; 2; 10; 25; 235; 567; 1|]

&gt; Array.fold_right ;;
- : ('b -&gt; 'a -&gt; 'a) -&gt; 'b array -&gt; 'a -&gt; 'a = &lt;fun&gt;
&gt; Array.fold_right (+) [|56; 2; 10; 25; 100; 567; 1|]  0 ;;
- : int = 761

&gt; Array.fold_left ;;
- : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b array -&gt; 'a = &lt;fun&gt;
&gt; Array.fold_left (+) 0 [|56; 2; 10; 25; 100; 567; 1|]  ;;
- : int = 761

&gt; Array.iter (Printf.printf "x = %d\n") [|56; 2; 10; 25; 100; 567; 1|]  ;;
x = 56
x = 2
x = 10
x = 25
x = 100
x = 567
x = 1
- : unit = ()
&gt;

(*  Applies a function that takes the index of element
    as first argument and then the element as second
    argument.

    f(index, element)
*)
&gt; Array.iteri ;;
- : (int -&gt; 'a -&gt; unit) -&gt; 'a array -&gt; unit = &lt;fun&gt;

&gt; Array.iteri (Printf.printf "x[%d] = %d\n") [|56; 2; 10; 25; 100; 567; 1|]  ;;
x[0] = 56
x[1] = 2
x[2] = 10
x[3] = 25
x[4] = 100
x[5] = 567
x[6] = 1
- : unit = ()



&gt; Array.init ;;
- : int -&gt; (int -&gt; 'a) -&gt; 'a array = &lt;fun&gt;

&gt; Array.init 10 (fun x -&gt; 5. *. float_of_int x)  ;;
- : float array = [|0.; 5.; 10.; 15.; 20.; 25.; 30.; 35.; 40.; 45.|]
&gt; Array.init 10 (fun x -&gt; 5 * x + 10 )  ;;
- : int array = [|10; 15; 20; 25; 30; 35; 40; 45; 50; 55|]

&gt; Array.make_matrix ;;
- : int -&gt; int -&gt; 'a -&gt; 'a array array = &lt;fun&gt;
&gt; Array.make_matrix 2 3 1 ;;
- : int array array = [|[|1; 1; 1|]; [|1; 1; 1|]|]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> String</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
There are more useful string functions on the core library.
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html</a>
</li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Char.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Char.html</a>
</li>
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html</a>
</li>
</ul>

<p>
<b>Char Module</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Acii code to Char *)

    # Char.chr ;;
    - : int -&gt; char = &lt;fun&gt;

    # Char.chr 99 ;;
    - : char = 'c'

(* Char to Ascii Code*)


    # Char.code 'a' ;;
    - : int = 97

    # Char.code ;;
    - : char -&gt; int = &lt;fun&gt;

(* Upper Case / Lower Case *)

    # Char.uppercase 'c' ;;
    - : char = 'C'
    # Char.lowercase 'A' ;;
    - : char = 'a'
</pre>
</div>

<p>
<b>String Module</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Length of String *)

    # String.length "Hello world" ;;
    - : int = 11

(* Concatenate Strings *)
    # String.concat "\n" ["Hello"; "World"; "Ocaml" ] ;;
    - : string = "Hello\nWorld\nOcaml"

    # "Hello " ^ " World " ^ " Ocaml" ;;
    - : string = "Hello  World  Ocaml"

(* Uppercase / Lowercase *)
    # String.capitalize "hello world" ;;
    - : string = "Hello world"

    # String.lowercase "HELLO WORLD" ;;
    - : string = "hello world"

(* Get Character at position *)

    # String.get ;;
    - : string -&gt; int -&gt; char = &lt;fun&gt;
    # String.get  "Hello world" 0 ;;
    - : char = 'H'
    # String.get  "Hello world" 1 ;;
    - : char = 'e'

    # List.map (String.get "Buffalo") [0; 1; 2; 3; 4; 5; 6] ;;
    - : char list = ['B'; 'u'; 'f'; 'f'; 'a'; 'l'; 'o']
    #

    # let str =  "My string" ;;
    val str : string = "My string"

    # str.[0] ;;
    - : char = 'M'
     # str.[5] ;;
    - : char = 'r'

(* Setting Characters *)

    # let str =  "My string" ;;
    val str : string = "My string"

    # s.[0] &lt;- 'H' ;;
    - : unit = ()
     # s.[1] &lt;- 'e' ;;
    - : unit = ()
     # s ;;
    - : string = "He to world"

(* Contains test if character is in the string *)

    # String.contains ;;
    - : string -&gt; char -&gt; bool = &lt;fun&gt;

    # String.contains "hello" 'c' ;;
    - : bool = false

    # String.contains "hello" 'h' ;;
    - : bool = true

(* Map Characters *)

    # String.map ;;
    - : (char -&gt; char) -&gt; string -&gt; string = &lt;fun&gt;

    # let encode key chr = Char.chr ((Char.code chr) - key) ;;
    val encode : int -&gt; char -&gt; char = &lt;fun&gt;

    # let decode key chr = Char.chr (Char.code chr + key) ;;
    val decode : int -&gt; char -&gt; char = &lt;fun&gt;

    # let str = "Hello world" ;;
    val str : string = "Hello world"

    # String.map (encode 13) str ;;
- : string = ";X__b\019jbe_W"

    # String.map (decode 13) ";X__b\019jbe_W" ;;
    - : string = "Hello world"
</pre>
</div>



<p>
<b>Str Module</b>
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">(* When in the toploop interactive shell *)
    #load "str.cma"

(* Compile String to a regular expression*)
    # Str.regexp ;;
    - : string -&gt; Str.regexp = &lt;fun&gt;

    # Str.regexp ",";;
    - : Str.regexp = &lt;abstr&gt;

(* Split String *)

    # Str.split ;;
    - : Str.regexp -&gt; string -&gt; string list = &lt;fun&gt;

    # Str.split (Str.regexp ",") "23.232,9823,\"Ocaml Haskell FP\"";;
    - : string list = ["23.232"; "9823"; "\"Ocaml Haskell FP\""]

    # Str.split (Str.regexp "[,|;]") "23.232,9823;\"Ocaml Haskell FP\";400";;
    - : string list = ["23.232"; "9823"; "\"Ocaml Haskell FP\""; "400"]

    # Str.split (Str.regexp "[ ]") "23.232 9823 Ocaml Haskell FP 400";;
    - : string list = ["23.232"; "9823"; "Ocaml"; "Haskell"; "FP"; "400"]

    # Str.string_before ;;
    - : string -&gt; int -&gt; string = &lt;fun&gt;
    # Str.string_before "Hello world ocaml" 3 ;;
    - : string = "Hel"
    # Str.string_before "Hello world ocaml" 11 ;;
    - : string = "Hello world"

    # Str.string_after "Hello world ocaml" 11 ;;
    - : string = " ocaml"


    #  Str.split (Str.regexp "[ ]") "23.232 9823 Ocaml Haskell FP 400";;
    - : string list = ["23.232"; "9823"; "Ocaml"; "Haskell"; "FP"; "400"]
</pre>
</div>

<p>
<b>Buffer Module</b>
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html</a>
</li>
</ul>

<p>
It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; Buffer.create ;;
- : int -&gt; Buffer.t = &lt;fun&gt;

(* Converts Buffer to String *)
Buffer.contents ;;
- : Buffer.t -&gt; bytes = &lt;fun&gt;
&gt;

(* Add Char to Buffer *)
&gt; Buffer.add_char ;;
- : Buffer.t -&gt; char -&gt; unit = &lt;fun&gt;

Buffer.add_bytes ;;
- : Buffer.t -&gt; bytes -&gt; unit = &lt;fun&gt;
&gt;

(* Add String to Buffer *)
&gt; Buffer.add_string ;;
- : Buffer.t -&gt; bytes -&gt; unit = &lt;fun&gt;
&gt;

(* Reset Buffer -&gt; buffer = "" *)
&gt; Buffer.reset ;;
- : Buffer.t -&gt; unit = &lt;fun&gt;
&gt;

&gt; let b = Buffer.create  0 ;;
val b : Buffer.t = &lt;abstr&gt;

&gt; Buffer.contents b ;;
- : bytes = ""


&gt; Buffer.add_string  b "ocaml fp rocks ! ocaml is amazing" ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = "ocaml fp rocks ! ocaml is amazing"

&gt; Buffer.add_string b " - Ocaml is strict FP" ;;
- : unit = ()

Buffer.length b ;;
- : int = 33

&gt; Buffer.contents b ;;
- : bytes = "ocaml fp rocks ! ocaml is amazing - Ocaml is strict FP"
&gt;


Buffer.reset b ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = ""



let c = Buffer.create 0 ;;
val c : Buffer.t = &lt;abstr&gt;
&gt; Buffer.add_char c 'o' ;;
- : unit = ()
&gt; Buffer.add_char c 'c' ;;
- : unit = ()
&gt; Buffer.add_char c 'a' ;;
- : unit = ()
&gt; Buffer.add_char c 'm' ;;
- : unit = ()
&gt; Buffer.add_char c 'l' ;;
- : unit = ()

&gt; Buffer.contents c ;;
- : bytes = "ocaml"

print_string (Buffer.contents c) ;;
ocaml- : unit = ()


&gt; Buffer.nth c 0 ;;
- : char = 'o'
&gt; Buffer.nth c 1 ;;
- : char = 'c'
&gt; Buffer.nth c 2 ;;
- : char = 'a
&gt; Buffer.nth c 3 ;;
- : char = 'm'
&gt; Buffer.nth c 4 ;;
- : char = 'l'

List.map (Buffer.nth c) [0; 1; 2; 3; 4] ;;
- : char list = ['o'; 'c'; 'a'; 'm'; 'l']

&gt; let s = "hindler milner type system" ;;
val s : bytes = "hindler milner type system"

&gt; let b = Buffer.create 0 ;;
val b : Buffer.t = &lt;abstr&gt;

&gt; Buffer.add_substring ;;
- : Buffer.t -&gt; bytes -&gt; int -&gt; int -&gt; unit = &lt;fun&gt;

Buffer.add_substring b s 0 4 ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = "hind"

Buffer.add_substring b s 4 5 ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = "hindler m"

&gt; Buffer.add_substring b s 6 10 ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = "hindler mr milner t"


&gt; Buffer.sub ;;
- : Buffer.t -&gt; int -&gt; int -&gt; bytes = &lt;fun&gt;


let c = Buffer.create 0 ;;
val c : Buffer.t = &lt;abstr&gt;
&gt; Buffer.add_string c "Ocaml is almost fast as C" ;;
- : unit = ()
&gt; Buffer.sub c 0 1 ;;
- : bytes = "O"
&gt; Buffer.sub c 0 5 ;;
- : bytes = "Ocaml"
&gt; Buffer.sub c 0 10 ;;
- : bytes = "Ocaml is a"
&gt; Buffer.sub c 5 15 ;;
- : bytes = " is almost fast"
&gt;
</pre>
</div>

<p>
<b>String Processing</b>
</p>

<p>
Splitting a string into characters.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let s = "p2p peer to peer connection" ;;
val s : bytes = "p2p peer to peer connection"

(* Imperative Approach *)


&gt; let arr = Array.make ;;
val arr : int -&gt; 'a -&gt; 'a array = &lt;fun&gt;

let arr = Array.make (String.length s) '\000' ;;
val arr : char array =
[|'\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000';
'\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000';
'\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'; '\000'|]

&gt; for i = 0 to (String.length s - 1) do
      arr.(i) &lt;- s.[i]
  done ;;
- : unit = ()


&gt; arr ;;
- : char array =
[|'p'; '2'; 'p'; ' '; 'p'; 'e'; 'e'; 'r'; ' '; 't'; 'o'; ' '; 'p'; 'e'; 'e';
'r'; ' '; 'c'; 'o'; 'n'; 'n'; 'e'; 'c'; 't'; 'i'; 'o'; 'n'|]

let str2chars s =
    let arr = Array.make (String.length s) '\000' in
    for i = 0 to (String.length s - 1) do
        arr.(i) &lt;- s.[i]
    done ;
    arr
;;
val str2chars : bytes -&gt; char array = &lt;fun&gt;
&gt;

str2chars "fox" ;;
- : char array = [|'f'; 'o'; 'x'|]



&gt; str2chars "fox" |&gt; Array.map Char.code ;;
- : int array = [|102; 111; 120|]

&gt; let str2chars_ s =
    let arr = Array.make (String.length s) '\000' in
    for i = 0 to (String.length s - 1) do
        arr.(i) &lt;- s.[i]
    done ;
    Array.to_list arr
;;
val str2chars_ : bytes -&gt; char list = &lt;fun&gt;
&gt;

&gt; str2chars_ "UNIX" ;;
- : char list = ['U'; 'N'; 'I'; 'X']

&gt; str2chars_ "UNIX" |&gt; List.map Char.code ;;
- : int list = [85; 78; 73; 88]

(* Functional Approach *)

&gt; let str2chars s =
    let n = String.length s in
    let rec aux i alist =
        if i =0
        then []
        else s.[n-i]::(aux (i-1) alist)
    in aux n []
;;
val str2chars : bytes -&gt; char list = &lt;fun&gt;

&gt; str2chars "UNIX" ;;
- : char list = ['U'; 'N'; 'I'; 'X']

str2chars "UNIX" |&gt; List.map Char.code ;;
- : int list = [85; 78; 73; 88]


(* Extract Digits *)

let digit_of_char c =
    match c with
    | '0' -&gt; 0
    | '1' -&gt; 1
    | '2' -&gt; 2
    | '3' -&gt; 3
    | '4' -&gt; 4
    | '5' -&gt; 5
    | '6' -&gt; 6
    | '7' -&gt; 7
    | '8' -&gt; 8
    | '9' -&gt; 9
    | _   -&gt; failwith "Not a digit"
;;
;;val digit_of_char : char -&gt; int = &lt;fun&gt;

&gt; str2chars "12334" |&gt; List.map digit_of_char ;;
- : int list = [1; 2; 3; 3; 4]

&gt; str2chars "12334x" |&gt; List.map digit_of_char ;;
Exception: Failure "Not a digit".

&gt; let str2digits s =  str2chars s |&gt; List.map digit_of_char ;;
val str2digits : bytes -&gt; int list = &lt;fun&gt;

&gt; str2digits "1234" ;;
- : int list = [1; 2; 3; 4]
</pre>
</div>

<p>
Join Chars
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let cs = ['o' ; 'c'; 'a'; 'm'; 'l' ] ;;
val cs : char list = ['o'; 'c'; 'a'; 'm'; 'l']

&gt; Buffer.add_char ;;
- : Buffer.t -&gt; char -&gt; unit = &lt;fun&gt;

&gt; List.iter ;;
- : ('a -&gt; unit) -&gt; 'a list -&gt; unit = &lt;fun&gt;

List.iter (Buffer.add_char b) cs ;;
- : unit = ()

&gt; Buffer.contents b ;;
- : bytes = "ocaml"

let chars2str cs =
    let b = Buffer.create 0 in
    List.iter (Buffer.add_char b) cs ;
    Buffer.contents b
;;
val chars2str : char list -&gt; bytes = &lt;fun&gt;
&gt;

&gt; chars2str ['o' ; 'c'; 'a'; 'm'; 'l' ] ;;
- : bytes = "ocaml"
</pre>
</div>

<p>
Strip Left Chars
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let trim chars s =
    let n = String.length s in
    let b = Buffer.create 0 in

    for i = 0 to n - 1 do
        if List.mem s.[i] chars
            then ()
            else Buffer.add_char b s.[i]
    done ;
    Buffer.contents b
;;


&gt; trim ['-'; '.']  "-.--.--.....-trim chars---...----.-.-" ;;
- : bytes = "trim chars"
</pre>
</div>
</div>
</div>






<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4"><span class="section-number-4">1.5.4</span> Sys</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html</a>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Command Line Arguments *)

    &gt; Sys.argv ;;
    - : string array = [|"/home/tux/bin/ocaml"|]
    &gt;

(* Current Directory *)

    &gt; Sys.getcwd ;;
    - : unit -&gt; string = &lt;fun&gt;

    &gt; Sys.getcwd() ;;
    - : string = "/home/tux/PycharmProjects/ocaml/prelude"

(* Change Current Directory *)

    &gt; Sys.chdir ;;
    - : string -&gt; unit = &lt;fun&gt;

    &gt; Sys.chdir "/" ;;
    - : unit = ()
    &gt; Sys.getcwd () ;;
    - : string = "/"
    &gt;

(* List directory *)

    &gt; Sys.readdir ;;
    - : string -&gt; string array = &lt;fun&gt;
    &gt;

    &gt; Sys.readdir("/") ;;
    - : string array =
    [|"tftpboot"; "var"; "cdrom"; "home"; "lost+found"; "netinterface.log";
      "opt"; "root.tar"; "tmp"; "sys"; "etc"; "root"; "srv"; "bin";
      "vmlinuz.old"; "sbin"; "backup.log"; "initrd.img.old"; "run"; "initrd.img";
      "lib"; "usr"; "vmlinuz"; "mnt"; "dev"; "media"; "boot"; "proc"|]
    &gt;

(* Test if is directory *)

    &gt; Sys.is_directory "/etc" ;;
    - : bool = true
    &gt; Sys.is_directory "/etca" ;;
    Exception: Sys_error "/etca: No such file or directory".
    &gt; Sys.is_directory "/etc/fstab" ;;
    - : bool = false
    &gt;


(* Test if File exists *)

    &gt; Sys.file_exists ;;
    - : string -&gt; bool = &lt;fun&gt;

    &gt; Sys.file_exists "/etc" ;;
    - : bool = true
    &gt;
      Sys.file_exists "/etca" ;;
    - : bool = false
    &gt;

    (* Execute shell command and return exit code
     *   0    For success
     *  not 0 For failure
     *)

    &gt; Sys.command ;;
    - : string -&gt; int = &lt;fun&gt;

    &gt; Sys.command "uname -a" ;;
    Linux tux-I3000 3.13.0-36-generic &gt;63-Ubuntu SMP Wed Sep 3 21:30:45 UTC 2014 i686 i686 i686 GNU/Linux
    - : int = 0
    &gt;

    &gt; Sys.command "nam" ;;
    sh: 1: nam: not found
    - : int = 127
    &gt;


(* Constants and Flags *)

    (* Machine Word Size in bits *)
    &gt;  Sys.word_size ;;
    - : int = 32
    &gt;

    (* Machine Endianess *)
    &gt; Sys.big_endian ;;
    - : bool = false
    &gt;

    (*
     *  For Linux/BSD or OSX  --&gt; "Unix"
     *  Windows               --&gt; "Win32"
    *)
    &gt; Sys.os_type ;;
    - : string = "Unix"
    &gt;

    (*  Maximum length of strings and byte sequences. =
     *   =~  16 MB
     *)
    &gt; Sys.max_string_length ;;
    - : int = 16777211
    &gt;
</pre>
</div>

<p>
Extra Example:
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># let (|&gt; x f = f x ;;

# let (&lt;|) f x = f x ;;
val ( &lt;| ) : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;

# Sys.chdir "/boot" ;;
- : unit = ()

# Sys.readdir "." ;;
- : string array =
[|"abi-3.13.0-35-generic"; "System.map-3.13.0-35-generic";
  "vmlinuz-3.13.0-35-generic"; "abi-3.13.0-36-generic";
  "config-3.13.0-35-generic"; "memtest86+_multiboot.bin";
  "initrd.img-3.13.0-35-generic"; "memtest86+.elf"; "memtest86+.bin";
  "System.map-3.13.0-36-generic"; "initrd.img-3.13.0-36-generic";
  "xen-4.4-amd64.gz"; "extlinux"; "config-3.13.0-36-generic";
  "vmlinuz-3.13.0-36-generic"; "grub"|]
#


(* List only directories *)
# "." |&gt; Sys.readdir |&gt; Array.to_list  |&gt; List.filter Sys.is_directory ;;
- : string list = ["extlinux"; "grub"]

(* List only files *)

# "." |&gt; Sys.readdir |&gt; Array.to_list  |&gt; List.filter (fun d -&gt; not &lt;| Sys.is_directory d );;
- : string list =
["abi-3.13.0-35-generic"; "System.map-3.13.0-35-generic";
 "vmlinuz-3.13.0-35-generic"; "abi-3.13.0-36-generic";
 "config-3.13.0-35-generic"; "memtest86+_multiboot.bin";
 "initrd.img-3.13.0-35-generic"; "memtest86+.elf"; "memtest86+.bin";
 "System.map-3.13.0-36-generic"; "initrd.img-3.13.0-36-generic";
 "xen-4.4-amd64.gz"; "config-3.13.0-36-generic"; "vmlinuz-3.13.0-36-generic"]
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5"><span class="section-number-4">1.5.5</span> Filename</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
It provides file name combinators.
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #show Filename ;;
module Filename :
  sig
    val current_dir_name : string
    val parent_dir_name : string
    val dir_sep : string
    val concat : string -&gt; string -&gt; string
    val is_relative : string -&gt; bool
    val is_implicit : string -&gt; bool
    val check_suffix : string -&gt; string -&gt; bool
    val chop_suffix : string -&gt; string -&gt; string
    val chop_extension : string -&gt; string
    val basename : string -&gt; string
    val dirname : string -&gt; string
    val temp_file : ?temp_dir:string -&gt; string -&gt; string -&gt; string
    val open_temp_file :
      ?mode:open_flag list -&gt;
      ?temp_dir:string -&gt; string -&gt; string -&gt; string * out_channel
    val get_temp_dir_name : unit -&gt; string
    val set_temp_dir_name : string -&gt; unit
    val temp_dir_name : string
    val quote : string -&gt; string
  end
# 

(** Note:  Directory Separtor, on Windows it is (\), but is written 
in Ocaml as (\\) , but you can also use Unix path conventions, "/" 
the root is translater as C:\\ and "/" as \\ and "." as the current
directory.   
*)
# Filename.dir_sep ;;
- : string = "/"
# 

(** Concat Concat File Paths *)

# Filename.concat "/home/dummy/Documents/" "blueprints.doc" ;;
- : string = "/home/dummy/Documents/blueprints.doc"
# 

# Filename.concat "/home/dummy/Documents" "blueprints.doc" ;;
- : string = "/home/dummy/Documents/blueprints.doc"        

# List.map (Filename.concat "/opt")  ["dir1"; "dir2"; "dir3"] ;;
- : string list = ["/opt/dir1"; "/opt/dir2"; "/opt/dir3"]
# 

# let concat_paths pathlist = List.fold_right  Filename.concat  pathlist "" ;;
val concat_paths : string list -&gt; string = &lt;fun&gt;
# 
# concat_paths ["/" ; "etc" ; "fstab" ] ;;
- : string = "/etc/fstab/"


(** Get the file name without path to file *)
 Filename.basename "/etc/fstab" ;;
- : string = "fstab"
# 

(** Get the path where is the file or directory*)

# Filename.dirname "/home/tux/windows/ocamlapidoc/index.html" ;;
- : string = "/home/tux/windows/ocamlapidoc"
# 

# Filename.dirname "/home/tux/windows/ocamlapidoc" ;;
- : string = "/home/tux/windows"
# 

(** Test if file ends with extension *)

# Filename.check_suffix  "test.ml" "ml" ;;
- : bool = true
# 

# Filename.check_suffix  "test.ml" "sh" ;;
- : bool = false
#     
# "/etc" 
 |&gt; Sys.readdir 
 |&gt; Array.to_list 
 |&gt; List.filter (fun x -&gt; Filename.check_suffix  x "conf") ;;
- : string list =
["nsswitch.conf"; "ntp.conf"; "mke2fs.conf"; "mtools.conf"; ...]

(* You can can create combinators to enhance the composability, 
   reusability and modularity   
*)

#  let listdir path = Sys.readdir path |&gt; Array.to_list ;;
val litsdir : string -&gt; string list = &lt;fun&gt;
# 

# let is_file_type ext fname = Filename.check_suffix  fname ext ;;
val is_file_type : string -&gt; string -&gt; bool = &lt;fun&gt;

# listdir "/etc" |&gt; List.filter (is_file_type ".conf") ;;
- : string list =
["nsswitch.conf"; "ntp.conf"; "mke2fs.conf"; "mtools.conf"; 
"gai.conf"; "pnm2ppa.conf"; "inetd.conf"; "deluser.conf"; 
"resolv.conf"; "rsyslog.conf" ...]


# List.map Filename.chop_extension ["file1.ml"; "filex.hs"; "file3.py"] ;;
- : string list = ["file1"; "filex"; "file3"]
# 

# Filename.chop_suffix "archive.tar.gz" ".tar.gz" ;;
- : string = "archive"
# 

# Filename.chop_suffix "archive.tar.gz" ".tar.bz2" ;;
- : string = "archiv"
# 


# Filename.quote "separated file name is not good.txt" ;;
- : string = "'separated file name is not good.txt'"
# 

# Filename.quote "separated file name is not good.txt" 
|&gt; print_endline ;;
'separated file name is not good.txt'
- : unit = ()
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6"><span class="section-number-4">1.5.6</span> Unix</h4>
<div class="outline-text-4" id="text-1-5-6">
<p>
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html">Documention</a>
</p>

<p>
Despite the name Unix, this is a multi platform module and also works in Windows OS.
</p>

<p>
Compile Standalone programs with Unix Library.
</p>

<pre class="example">
$ ocamlfind ocamlc -package more,unix program.ml -linkpkg -o program
$ ocamlfind ocamlopt -package more,unix program.ml -linkpkg -o progra
</pre>

<p>
<b>System</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* It is only needed on the toploop shell *)
&gt; #load "unix.cma" ;;

(* Get the current working directory *)
Unix.getcwd () ;;
- : bytes = "/home/tux/PycharmProjects/ocaml/prelude"

(* Change the current working directory *)
&gt; Unix.chdir "/" ;;
- : unit = ()

Unix.getcwd () ;;
- : bytes = "/"


(* Get an environment variable *)
&gt; Unix.getenv "PATH" ;;
- : string =
"/home/tux/.opam/4.02.1/bin:/home/tux/bin:/usr/local/sbin:/usr/local/bin:
/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tux/bin:
/home/tux/usr/bin:/home/tux/.apps ...


(* Set an environment variable *)
&gt;
Unix.putenv "DUMMYVAR" "Test value"  ;;
- : unit = ()

&gt; Unix.getenv "DUMMYVAR" ;;
- : bytes = "Test value"
&gt;    

(* Get all Environment Variables *)
&gt; Unix.environment () ;;
- : bytes array =
[|"XDG_VTNR=7"; "LC_PAPER=pt_BR.UTF-8";
"CAML_LD_LIBRARY_PATH=/home/tux/.opam/4.02.1/lib/stublibs";
"MANPATH=:/home/tux/.opam/4.02.1/man"; "HTTP_HOME=www.google.co.uk";
  "SSH_AGENT_PID=1055"; "LC_ADDRESS=pt_BR.UTF-8"; "XDG_SESSION_ID=c1";
  "XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/tux"; "LC_MONETARY=pt_BR.UTF-8";
  "SAL_USE_VCLPLUGIN=gtk"; "CLUTTER_IM_MODULE=xim"; "COMP_WORDBREAKS= \t\n\"'&gt;&lt;;|&amp;(:";
  "TERM=xterm"; "XDG_MENU_PREFIX=lxde-"; "SHELL=/bin/bash"; "MAKEFLAGS=";
  "PERL5LIB=/home/tux/.opam/4.02.1/lib/perl5:"; "LC_NUMERIC=pt_BR.UTF-8";
  "OCAML_TOPLEVEL_PATH=/home/tux/.opam/4.02.1/lib/toplevel"; "USER=tux";
  "LC_TELEPHONE=pt_BR.UTF-8";  
  ...

&gt;  Unix.gethostname () ;;
- : string = "tux-I3000"
&gt;

(** Get the current process ID, PID *)
Unix.getpid () ;;
- : int = 31582

(** Pid of the parent process *)
&gt;    Unix.getppid () ;;
- : int = 26778

&gt; 

(* Reading Input Channel *)

let read_channel ch =
   let b = Buffer.create 0 in

   let reader chn =
    try Some (input_line chn)
    with End_of_file -&gt; None

   in let rec aux () =
     match reader ch with
      | None -&gt; ()
      | Some line -&gt; Buffer.add_string b (line ^ "\n") ; aux ()
   in aux () ;
   Buffer.contents b 
;;
val read_channel : in_channel -&gt; bytes = &lt;fun&gt;

&gt; 

&gt; open_in ;;
- : string -&gt; in_channel = &lt;fun&gt;


&gt; let fd = open_in "/tmp/data.txt" ;;
val fd : in_channel = &lt;abstr&gt;

&gt; read_channel fd |&gt; print_string ;;
character \n as a line break, instead of recognizing all line break characters from the Unicode standard. Whether they match or don't match (at) line breaks depends on (?s) and (?m).
(?b) makes Tcl interpret the regex as a POSIX BRE.
(?e) makes Tcl interpret the regex as a POSIX ERE.
- : unit = ()


&gt; Unix.open_process_in ;;
- : string -&gt; in_channel = &lt;fun&gt;


&gt; Unix.open_process_in ;;
- : string -&gt; in_channel = &lt;fun&gt;
# 
  let fd = Unix.open_process_in "ls" ;;
val fd : in_channel = &lt;abstr&gt;
# read_channel fd |&gt; print_string ;;
_build
codetools.ml
_local.ml
Makefile
META
opam
others
prelude.docdir
prelude.ml
prelude.mllib
prelude.odocl
seq.ml
...

&gt; let popen_in cmd =
      let fd = Unix.open_process_in cmd in
      read_channel fd 
  ;;          
val popen_in : string -&gt; string = &lt;fun&gt;    

&gt; popen_in "uname -r" ;;
- : string = "3.19.0-21-generic\n"
&gt;
</pre>
</div>

<p>
<b>Date and Time</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">  # #load "unix.cma" ;;

  (*  Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds
   *
   *)
  # Unix.time ;;
  - : unit -&gt; float = &lt;fun&gt;
  # Unix.time () ;;
  - : float = 1433237870.
  #

  (* Convert a time in seconds, as returned by Unix.time, into a date
   * and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.
   *)

  # Unix.gmtime ;;
  - : float -&gt; Unix.tm = &lt;fun&gt;
  #

  # Unix.gmtime @@ Unix.time () ;;
  - : Unix.tm =
  {Unix.tm_sec = 36; tm_min = 39; tm_hour = 9; tm_mday = 2; tm_mon = 5;
   tm_year = 115; tm_wday = 2; tm_yday = 152; tm_isdst = false}
  #

  # Unix.time () |&gt; Unix.gmtime ;;
  - : Unix.tm =
  {Unix.tm_sec = 20; tm_min = 9; tm_hour = 22; tm_mday = 25; tm_mon = 6;
   tm_year = 115; tm_wday = 6; tm_yday = 205; tm_isdst = false}
  # 


 # let print_dtime tm = 
    let open Unix in
    Printf.printf "Year %d\n" (tm.tm_year + 1900) ;
    Printf.printf "Month %d\n" (tm.tm_mon + 1) ;
    Printf.printf "Day   %d\n" tm.tm_mday; 
    Printf.printf "Hour  %d\n" tm.tm_hour;
    Printf.printf "Min   %d\n" tm.tm_min;
    Printf.printf "Sec   %d\n" tm.tm_sec
 ;;


  #  Unix.time () |&gt; Unix.gmtime |&gt; print_dtime ;;
  Year 2015
  Month 7
  Day   25
  Hour  22
  Min   16
  Sec   58
  - : unit = ()
  # 

  (** Zero date 
    *
    *)
  # 0.0  |&gt; Unix.gmtime |&gt;  print_dtime ;;
  Year 1970
  Month 1
  Day   1
  Hour  0
  Min   0
  Sec   0
  - : unit = ()
  # 


  # let today_date () = 
        let open Unix in 
        let tm = time () |&gt; gmtime in
        (tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday)
    ;;
  val today_date : unit -&gt; int * int * int = &lt;fun&gt;
  # 

  #   today_date () ;;
  - : int * int * int = (2015, 7, 25)
  # 

  # let  make_date (y, m, d) =
    let open Unix in 
    { 
     tm_sec = 0 ;
     tm_min = 0 ;
     tm_hour = 0 ;
     tm_mday = d ;
     tm_mon  = m - 1;
     tm_year = y - 1900 ;
     tm_yday = 0;
     tm_wday = 0 ;
     tm_isdst = false ;
    }
;;


  # make_date (2013, 10, 15) ;;
  - : Unix.tm =
  {Unix.tm_sec = 0; tm_min = 0; tm_hour = 0; tm_mday = 15; tm_mon = 9;
   tm_year = 113; tm_wday = 0; tm_yday = 0; tm_isdst = false}
  # 


  #  make_date (2013, 10, 15) |&gt; print_dtime ;;
  Year 2013
  Month 10
  Day   15
  Hour  0
  Min   0
  Sec   0
  - : unit = ()
  # 


  (** Get the timezone
      The time zone is the difference between the current UTC time 
      and the localtime hour

      UTC_Time = Local_Time + TimeZone

      For example if your local time is 10h and your time zone is +3h,
      then the UTC time will be 10h + 3h =&gt; 13h or 1h PM

      1 h ==&gt; 60 min/h * 60 sec/min = 3600 sec/h

   *)

  # let tzone () =
        let open Unix in
        let epc1 = time () in
        let epc2, _ = epc1 |&gt; gmtime |&gt; mktime in
        int_of_float @@ (epc2 -. epc1) /. 3600.
  ;;

  (** Recife/ Brazil Timezone *)  
  tzone () ;;
    - : int = 3
  #       

  # let test_time_zone epoch =
    let tm1 =
      epoch +. (float_of_int (tzone ())) *. 3600.0
      |&gt; Unix.localtime in

    let tm2 = Unix.gmtime epoch in
    tm1 = tm2
  ;;          

  # let t1 = Unix.time () ;;
  val t1 : float = 1437879090.
  # let t2 = Unix.time () ;;
  val t2 : float = 1437879096.
  # let t3 = Unix.time () ;;
  val t3 : float = 1437879195.
  # 
  List.map test_time_zone [t1; t2; t3] ;;
    - : bool list = [true; true; true]
  #   

  (** Convert time records to Epoch Time 
    *
    * The function Unix.mktime converts a time record to epoch time
    *
    *)

  (* Current time in Epoch time format *)      
  # let ec = Unix.time () ;;
  val ec : float = 1437864615.
  # 

  (* Current time as time record in Local Time record *)
  #  let tm = ec |&gt; Unix.localtime ;;
  val tm : Unix.tm =
    {Unix.tm_sec = 15; tm_min = 50; tm_hour = 19; tm_mday = 25; tm_mon = 6;
     tm_year = 115; tm_wday = 6; tm_yday = 205; tm_isdst = false}
  # 


  #  tm |&gt; print_dtime ;;
  Year 2015
  Month 7
  Day   25
  Hour  19
  Min   50
  Sec   15
  - : unit = ()
  # 

  #  Unix.mktime ;;
  - : Unix.tm -&gt; float * Unix.tm = &lt;fun&gt;
  # 

  #  let (epoch, tm2) = Unix.mktime tm;;
  val epoch : float = 1437864615.
  val tm2 : Unix.tm =
    {Unix.tm_sec = 15; tm_min = 50; tm_hour = 19; tm_mday = 25; tm_mon = 6;
     tm_year = 115; tm_wday = 6; tm_yday = 205; tm_isdst = false}

  # epoch = ec ;;
  - : bool = true

  # tm2 = tm ;;
  - : bool = true
  # 



  (** Count the number of days between two dates 

      1 day = 24 h * 60 h/min * 60 min/sec =
            = 86400 seconds  

      The two date times dt1 and dt2 are assumed to be in UTC (GM time)
  *)

  # let dtime_to_epoch tm = 
        let (ep, _) = Unix.mktime tm in
        ep   
        ;;
  val dtime_to_epoch : Unix.tm -&gt; float = &lt;fun&gt;
  # 


  # let day_count dtm1 dtm2 =        
       let seconds = (dtime_to_epoch dtm2) -. (dtime_to_epoch dtm1) in
       (int_of_float (seconds /. 86400. )) + 1
  ;;     
  val day_count : Unix.tm -&gt; Unix.tm -&gt; int = &lt;fun&gt;


  # day_count (make_date (2003, 5, 12)) (make_date (2008, 9, 10)) ;;
  - : int = 1949
  #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7"><span class="section-number-4">1.5.7</span> IO - Input / Output</h4>
<div class="outline-text-4" id="text-1-5-7">
<p>
Standard Print Functions
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; print_string "Hello world!\n";;
Hello world!
- : unit = ()
&gt;

&gt; print_int 100 ;;
100- : unit = ()

&gt; print_float 23.23 ;;
23.23- : unit = ()

&gt; print_char 'c' ;;
c- : unit = ()
&gt;

&gt; let s = Printf.sprintf "x =  %s  y = %f z = %d" "hello" 2.2232 40  ;;
val s : string = "x =  hello  y = 2.223200 z = 40"

&gt; print_string s ;;
x =  hello  y = 2.223200 z = 40- : unit = ()
</pre>
</div>

<p>
Printf Module
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; Printf.printf "%d" 100 ;;
100- : unit = ()

&gt; Printf.printf "%d %f" 100 2.232 ;;
100 2.232000- : unit = ()

&gt; Printf.printf "%s %d %f" "This is" 100 2.232 ;;
This is 100 2.232000- : unit = ()

&gt; Printf.sprintf "x =  %s  y = %f z = %d" "hello" 2.2232 40 ;;
- : string = "x =  hello  y = 2.223200 z = 40"
</pre>
</div>

<p>
<b>Files</b>
</p>

<p>
Writing a Text File:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">utop # let file = open_out "/tmp/file.txt" ;;
val file : out_channel = &lt;abstr&gt;

utop # output_string file "hello\n" ;;
- : unit = ()

utop # output_string file "world\n" ;;
- : unit = ()

utop # close_out file ;;
- : unit = ()
</pre>
</div>

<p>
Reading a Text File:
</p>

<pre class="example">
utop # let filein = open_in "/tmp/file.txt" ;;
val filein : in_channel = &lt;abstr&gt;

utop # input_line filein ;;
- : string = "hello"

utop # input_line filein ;;
- : string = "world"

utop # input_line filein ;;
Exception: End_of_file.


utop # let filein = open_in "/tmp/file.txt" ;;
val filein : in_channel = &lt;abstr&gt;

utop # input_char ;;
- : in_channel -&gt; char = &lt;fun&gt;


utop # input_char filein ;;
- : char = 'h'
utop # input_char filein ;;
- : char = 'e'
utop # input_char filein ;;
- : char = 'l'
utop # input_char filein ;;
- : char = 'l'
utop #
</pre>
</div>
</div>

<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8"><span class="section-number-4">1.5.8</span> Type Casting</h4>
<div class="outline-text-4" id="text-1-5-8">
<div class="org-src-container">

<pre class="src src-ocaml">utop # float_of_int 2323 ;;
- : float = 2323.

utop # float_of_string "100.04523" ;;
- : float = 100.04523

utop # int_of_float 100.04523 ;;
- : int = 100

utop # int_of_string "90000" ;;
- : int = 90000

utop # let x = [20; 230; 10 ; 40; 50 ] ;;
val x : int list = [20; 230; 10; 40; 50]

utop # List.map float_of_int x ;;
- : float list = [20.; 230.; 10.; 40.; 50.]

utop # Array.of_list [20.; 230.; 10.; 40.; 50.]  ;;
- : float array = [|20.; 230.; 10.; 40.; 50.|]

utop # Array.to_list [|20.; 230.; 10.; 40.; 50.|]  ;;
- : float list = [20.; 230.; 10.; 40.; 50.]

utop # string_of_bool true ;;
- : string = "true"

utop # string_of_int 11000 ;;
- : string = "11000"

utop # string_of_float 23.2323 ;;
- : string = "23.2323"
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Algebraic Data Types and Pattern Matching</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>Product Types: Corresponds to cartesian product. Examples: Tupĺes,
Records, Constructs.
</li>
<li>Sum Types: Disjoin Unions of types. Used to express possibilities.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> Record Types</h4>
<div class="outline-text-4" id="text-1-6-2">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; type country = {
     name : string ;
     domain : string ;
     language : string ;
     id : int ;
  }
  ;;


&gt; let brazil = {name = "Brazil" ; domain = ".br" ; language = "Portuguese" ; id = 100 } ;;
val brazil : country =
  {name = "Brazil"; domain = ".br"; language = "Portuguese"; id = 100}

&gt;  brazil.name ;;
- : string = "Brazil"

&gt; brazil.domain ;;
- : string = ".br"

&gt; brazil.language ;;
- : string = "Portuguese"

&gt; brazil.id ;;
- : int = 100


&gt; let countries = [
    {name = "Brazil" ; domain = ".br" ; language = "Portuguese" ; id = 100 } ;
    {name = "United Kingdom" ; domain = ".co.uk" ; language = "English" ; id = 10 } ;
    {name = "South Africa" ; domain = ".co.za" ; language = "English" ; id = 40 } ;
    {name = "France" ; domain = ".fr" ; language = "French" ; id = 20 } ;
    {name = "Taiwan ROC" ; domain = ".tw" ; language = "Chinese" ; id = 54 } ;
    {name = "Australia" ; domain = ".au" ; language = "English" ; id = 354 } ;
      ]
  ;;
val countries : country list =
  [{name = "Brazil"; domain = ".br"; language = "Portuguese"; id = 100};
   {name = "United Kingdom"; domain = ".co.uk"; language = "English";
    id = 10};
   {name = "South Africa"; domain = ".co.za"; language = "English"; id = 40};
   {name = "France"; domain = ".fr"; language = "French"; id = 20};
   {name = "Taiwan ROC"; domain = ".tw"; language = "Chinese"; id = 54};
   {name = "Australia"; domain = ".au"; language = "English"; id = 354}]


&gt; List.map (fun c -&gt; c.name ) countries ;;
- : string list =
["Brazil"; "United Kingdom"; "South Africa"; "France"; "Taiwan ROC";
 "Australia"]


&gt; List.map (fun c -&gt; c.domain ) countries ;;
- : string list = [".br"; ".co.uk"; ".co.za"; ".fr"; ".tw"; ".au"]

&gt; List.filter (fun c -&gt; c.name = "France") countries ;;
- : country list =
[{name = "France"; domain = ".fr"; language = "French"; id = 20}]

&gt; List.filter (fun c -&gt; c.language = "English") countries ;;
- : country list =
[{name = "United Kingdom"; domain = ".co.uk"; language = "English"; id = 10};
 {name = "South Africa"; domain = ".co.za"; language = "English"; id = 40};
 {name = "Australia"; domain = ".au"; language = "English"; id = 354}]

&gt; countries 
  |&gt; List.filter (fun c -&gt; c.language = "English") 
  |&gt; List.map (fun c -&gt; c.name)
  ;;
- : string list = ["United Kingdom"; "South Africa"; "Australia"]

&gt; let english_speaking_countries = 
  countries 
  |&gt; List.filter (fun c -&gt; c.language = "English") 
  |&gt; List.map (fun c -&gt; c.name)
  ;;
val english_speaking_countries : string list =
  ["United Kingdom"; "South Africa"; "Australia"]


&gt; english_speaking_countries ;;
- : string list = ["United Kingdom"; "South Africa"; "Australia"] 

&gt; countries 
  |&gt; List.filter (fun c -&gt; c.language = "English")
  |&gt; List.map (fun c -&gt; c.name, c.domain)
  ;;
- : (string * string) list =
[("United Kingdom", ".co.uk"); ("South Africa", ".co.za");
 ("Australia", ".au")]


&gt; List.find (fun x -&gt; x.id = 100) countries ;;
- : country =
{name = "Brazil"; domain = ".br"; language = "Portuguese"; id = 100}

&gt; List.find (fun x -&gt; x.id = 354) countries ;;
- : country =
{name = "Australia"; domain = ".au"; language = "English"; id = 354}

&gt;  List.find (fun x -&gt; x.id = 1354) countries ;;
Exception: Not_found.

&gt; countries 
  |&gt; List.find (fun x -&gt; x.id = 100)
  |&gt; fun x -&gt; x.name
  ;;
- : string = "Brazil"
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> Disjoint Union</h4>
<div class="outline-text-4" id="text-1-6-3">
<div class="org-src-container">

<pre class="src src-ocaml">type literal =
    | Integer   of int
    | Float     of float
    | String    of string

type operator =
    | Add
    | Div
    | Mul
    | Sub
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4"><span class="section-number-4">1.6.4</span> Agreggated Data types</h4>
<div class="outline-text-4" id="text-1-6-4">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; type agg = Agg of int * string

&gt;  let a = Agg (1, "hi") ;;
val a : agg = Agg (1, "hi")

&gt;  a ;;
- : agg = Agg (1, "hi")
&gt;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-ocaml">type shape =
      Rect    of float * float          (*width * lenght *)
    | Circle  of float                  (* radius *)
    | Triang  of float * float * float  (* a * b *  c *)

let pictures = [Rect (3.0, 4.0) ; Circle 5.0 ; Triang (5.0, 5.0, 5.0)]

let perimiter s =
    match s with
         Rect    (a, b)      -&gt;  2.0 *. (a +. b)
       | Circle   r          -&gt;  2.0 *. 3.1415 *. r
       | Triang  (a, b, c)   -&gt;  a +. b +. c


&gt;  perimiter (Rect (3.0, 4.0)) ;;
- : float = 14.

&gt;  perimiter (Circle 3.0 ) ;;
- : float = 18.849


&gt;  perimiter (Triang (2.0, 3.0, 4.0)) ;;
- : float = 9.
&gt;

&gt; List.map perimiter pictures ;;
- : float list = [14.; 31.4150000000000027; 15.]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5"><span class="section-number-4">1.6.5</span> Pattern Matching</h4>
<div class="outline-text-4" id="text-1-6-5">
</div><div id="outline-container-sec-1-6-5-1" class="outline-5">
<h5 id="sec-1-6-5-1"><span class="section-number-5">1.6.5.1</span> Basic Pattern Matching</h5>
<div class="outline-text-5" id="text-1-6-5-1">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; match 4 with x -&gt; x;;                        (* ⇒ 4 *)
- : int = 4

&gt; match 4 with xyz -&gt; xyz;;                    (* ⇒ 4 *)
- : int = 4

&gt; match [3;4;5] with [a;b;c] -&gt; b;;            (* ⇒ 4 *)
- : int = 4

&gt; match (3, 7, 4) with ( a, b, c ) -&gt; c;;      (* ⇒ 4 *)
- : int = 4

&gt;  match (3, 4, (8,9)) with (a, b, c ) -&gt; c;;   (* ⇒ (8, 9) *)
- : int * int = (8, 9)
&gt;


&gt; let sign x = match x with
    x when x &lt; 0 -&gt; -1
    | 0           -&gt; 0
    | x           -&gt; 1

;;
val sign : int -&gt; int = &lt;fun&gt;


&gt;  sign 10 ;;
- : int = 1
&gt;  sign 0 ;;
- : int = 0
&gt;  sign 100 ;;
- : int = 1
&gt;  sign (-1) ;;
- : int = -1
&gt;  sign (-100) ;;
- : int = -1
&gt;

let getPassword passw = match passw with
    "hello"   -&gt; "OK. Safe Opened."
    | _       -&gt; "Wrong Password Pal."
  ;;

val getPassword : string -&gt; string = &lt;fun&gt;
&gt;
  getPassword "hellow" ;;
- : string = "Wrong Password Pal."
&gt;  getPassword "Pass" ;;
- : string = "Wrong Password Pal."
&gt;  getPassword "hello" ;;
- : string = "OK. Safe Opened."
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-5-2" class="outline-5">
<h5 id="sec-1-6-5-2"><span class="section-number-5">1.6.5.2</span> Tuple Pattern Matching</h5>
<div class="outline-text-5" id="text-1-6-5-2">
<p>
Extracting elements of a tuple
</p>

<pre class="example">
&gt; let fst (a, _) = a ;;
val fst : 'a * 'b -&gt; 'a = &lt;fun&gt;
&gt; let snd (_, b) = b ;;
val snd : 'a * 'b -&gt; 'b = &lt;fun&gt;

&gt; fst (2, 3) ;;
- : int = 2

&gt; fst ("a", 23) ;;
- : string = "a"

&gt; snd (2, 3) ;;
- : int = 3

&gt; snd (2, "a") ;;
- : string = "a"

&gt; List.map fst [("a", 12); ("b", 23) ; ("c", 23) ; ("d", 67)] ;;
- : string list = ["a"; "b"; "c"; "d"]

&gt; List.map snd [("a", 12); ("b", 23) ; ("c", 23) ; ("d", 67)] ;;
- : int list = [12; 23; 23; 67]


&gt;
let tpl3_1 (a, _, _) = a
let tpl3_2 (_, a, _) = a
let tpl3_3 (_, _, a) = a;;

&gt; tpl3_1 (2, "ocaml", 2.323) ;;
- : int = 2
&gt; tpl3_2 (2, "ocaml", 2.323) ;;
- : string = "ocaml"
&gt; tpl3_3 (2, "ocaml", 2.323) ;;
- : float = 2.323
</pre>

<p>
Returning Multiple Values
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt;  let divmod a b = a/b, a mod b ;;
val divmod : int -&gt; int -&gt; int * int = &lt;fun&gt;

  divmod 10 3 ;;
- : int * int = (3, 1)



&gt; let swap (x, y) = (y, x) ;;
val swap : 'a * 'b -&gt; 'b * 'a = &lt;fun&gt;

  swap (2, 3) ;;
- : int * int = (3, 2)

&gt; List.map swap [("a", 12); ("b", 23) ; ("c", 23) ; ("d", 67)] ;;
- : (int * string) list = [(12, "a"); (23, "b"); (23, "c"); (67, "d")]
</pre>
</div>

<p>
Source:
</p>

<ul class="org-ul">
<li><a href="http://xahlee.info/ocaml/pattern_matching.html">http://xahlee.info/ocaml/pattern_matching.html</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6"><span class="section-number-4">1.6.6</span> Recursive Data Structures</h4>
<div class="outline-text-4" id="text-1-6-6">
</div><div id="outline-container-sec-1-6-6-1" class="outline-5">
<h5 id="sec-1-6-6-1"><span class="section-number-5">1.6.6.1</span> Alternative List Implementation</h5>
<div class="outline-text-5" id="text-1-6-6-1">
<p>
List of Intergers
</p>

<div class="org-src-container">

<pre class="src src-ocaml">type intlist = Nil | Cons of (int * intlist)

let rec length (alist : intlist) : int =
    match alist with
    | Nil           -&gt; 0
    | Cons(h, t)    -&gt; 1 + (length t)


let is_empty (alist: intlist) : bool =
    match alist with
    | Nil           -&gt; true
    | Cons(_, _)   -&gt;  false

let rec sum (alist : intlist) : int =
    match alist with
    | Nil               -&gt; failwith "Error empty list"
    | Cons (a, Nil)     -&gt; a
    | Cons (h, remain)  -&gt; h + sum remain

let rec product (alist : intlist) : int =
    match alist with
    | Nil               -&gt; failwith "Error empty list"
    | Cons (a, Nil)     -&gt; a
    | Cons (h, remain)  -&gt; h * product remain

let head (alist: intlist) : int =
    match alist with
    | Nil           -&gt; failwith "Error empty list"
    | Cons (a, _)   -&gt; a

let rec last (alist : intlist) : int =
    match alist with
    | Nil               -&gt; failwith "Error empty list"
    | Cons (a, Nil)     -&gt; a
    | Cons (h, remain)  -&gt; last remain


let rec map f alist =
    match alist with
    | Nil               -&gt; Nil
    | Cons (e, remain)  -&gt; Cons(f e, map f remain)

let rec iter (f : int -&gt; unit) (alist : intlist) : unit =
    match alist with
    | Nil           -&gt; failwith "Error empty list"
    | Cons(a,  Nil) -&gt; f a
    | Cons(hd, tl)  -&gt; f hd ; iter f tl


let rec filter f alist =
    match alist with
    | Nil               -&gt; Nil
    | Cons (e, remain)  -&gt;
                if (f e)
                    then Cons(e, filter f remain)
                    else filter f remain

let rec foldl1 func alist  =  match alist with
    | Nil                -&gt; failwith "Error empty list"
    | Cons (a, Nil)      -&gt; a
    | Cons (hd, tl)      -&gt; func hd (foldl func tl)


let rec foldl func acc alist =
    match alist with
    | Nil               -&gt; acc
    | Cons (hd, tl)     -&gt; func hd (foldl func acc tl)


let rec nth alist n =
    match (alist, n) with
    | (Nil,     _       )   -&gt; failwith  "Empty list"
    | (Cons(h, _  ),   1)   -&gt; h
    | (Cons(hd, tl),   k)   -&gt; nth tl  (k-1)

let rec take n alist =
    match (n, alist) with
    | (_, Nil)           -&gt; Nil
    | (0, _  )           -&gt; Nil
    | (k, Cons(hd, tl))  -&gt; Cons(hd, take (k-1) tl)


let rec append ((list1:intlist), (list2:intlist)) : intlist =
    match list1 with
    | Nil               -&gt; list2
    | Cons(hd, tl)      -&gt; Cons(hd, append( (tl, list2)))

let rec reverse(list:intlist):intlist =
    match list with
      Nil -&gt; Nil
    | Cons(hd,tl) -&gt; append(reverse(tl), Cons(hd,Nil))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-ocaml">let l1 = Nil
let l2 = Cons(1, Nil)  (* [1] *)
let l3 = Cons(2, l2)   (* [2; 1] *)
let l4 = Cons(3, l3)   (* [3; 2; 1] *)
let l5 = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, Nil)))))

&gt; List.map length [l1 ; l2 ; l4 ; l5 ] ;;
- : int list = [0; 1; 3; 5]

&gt; List.map is_empty [l1 ; l2 ; l4 ; l5 ] ;;
- : bool list = [true; false; false; false]

&gt;  sum l1 ;;
Exception: Failure "Error empty list".
&gt;  sum l2 ;;
- : int = 1
&gt;  sum l3 ;;
- : int = 3
&gt;  sum l4 ;;
- : int = 6
&gt;  sum l5 ;;
- : int = 15
&gt;


&gt;  product l1 ;;
Exception: Failure "Error empty list".
&gt;  product l2 ;;
- : int = 1
&gt;  product l3 ;;
- : int = 2
&gt;  product l4 ;;
- : int = 6
&gt;  product l5 ;;
- : int = 120
&gt;


&gt; List.map head [l2 ; l3 ; l4 ; l5 ] ;;
- : int list = [1; 2; 3; 1]


&gt;  last l1 ;;
Exception: Failure "Error empty list".
&gt;  last l2 ;;
- : int = 1
&gt;  last l3 ;;
- : int = 1
&gt;  last l4 ;;
- : int = 1
&gt;  last l5 ;;
- : int = 5


&gt; map ((+) 1) Nil ;;
- : intlist = Nil
&gt; map ((+) 1) (Cons(1, Nil))  ;;
- : intlist = Cons (2, Nil)
&gt; map ((+) 1) (Cons(1, Cons(3, Cons(4, Cons(5, Nil)))))  ;;
- : intlist = Cons (2, Cons (4, Cons (5, Cons (6, Nil))))


&gt;  append(l4, l5) ;;
- : intlist = Cons  (3, Cons (2, Cons (1, Cons (1, Cons (2, Cons (3, Cons (4, Cons (5, Nil))))))))

&gt; reverse l5 ;;
- : intlist = Cons (5, Cons (4, Cons (3, Cons (2, Cons (1, Nil)))))

&gt;   let even x = x mod 2 == 0 ;;
&gt;   filter even l5 ;;
- : intlist = Cons (2, Cons (4, Nil)

&gt; l5 ;;
- : intlist = Cons (1, Cons (2, Cons (3, Cons (4, Cons (5, Nil)))))

&gt;  nth l5 2 ;;
- : int = 2
&gt;  nth l5 1 ;;
- : int = 1
&gt;  nth l5 3 ;;
- : int = 3
&gt;  nth l5 4 ;;
- : int = 4
&gt;  nth l5 5 ;;
- : int = 5

&gt; foldl1 (+) l5 ;;
- : int = 15

&gt; foldl1 (fun x y -&gt; x * y) l5 ;;
- : int = 120

&gt; foldl1 (fun x y -&gt; x + 10*y) l5 ;;
- : int = 54321


&gt; foldl (+) 0 l5 ;;
- : int = 15

&gt; foldl (fun x y -&gt; x * y) 2 l5 ;;
- : int = 240


&gt;
  take 0 l5 ;;
- : intlist = Nil
&gt;  take 1 l5 ;;
- : intlist = Cons (1, Nil)
&gt;  take 3 l5 ;;
- : intlist = Cons (1, Cons (2, Cons (3, Nil)))
&gt;  take 4 l5 ;;
- : intlist = Cons (1, Cons (2, Cons (3, Cons (4, Nil))))
&gt;  take 10 l5 ;;
- : intlist = Cons (1, Cons (2, Cons (3, Cons (4, Cons (5, Nil)))))


&gt; iter (Printf.printf "= %d\n") l5 ;;
= 1
= 2
= 3
= 4
= 5
- : unit = ()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-6-2" class="outline-5">
<h5 id="sec-1-6-6-2"><span class="section-number-5">1.6.6.2</span> File Tree Recursive Directory Walk</h5>
<div class="outline-text-5" id="text-1-6-6-2">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; type fileTree =
  | File of string
  | Folder of string * fileTree list

let neg f x = not (f x) ;;
type fileTree = File of string | Folder of string * fileTree list
val neg : ('a -&gt; bool) -&gt; 'a -&gt; bool = &lt;fun&gt;

let relpath p str = p ^ "/" ^ str

let scand_dir path =
    Sys.readdir path
    |&gt; Array.to_list

let is_dir_relpath path rel =
    Sys.is_directory (relpath path rel)

let rec walkdir path =

    let files = path
    |&gt; scand_dir
    |&gt; List.filter @@ neg  (is_dir_relpath path)
    |&gt; List.map (fun x -&gt; File x) in

    let dirs = path
    |&gt; scand_dir
    |&gt; List.filter (is_dir_relpath path)
    |&gt; List.map (fun x -&gt; Folder (x, walkdir (relpath path x ))) in

      dirs @ files
  ;;
val relpath : string -&gt; string -&gt; string = &lt;fun&gt;
val scand_dir : string -&gt; string list = &lt;fun&gt;
val is_dir_relpath : string -&gt; string -&gt; bool = &lt;fun&gt;
val walkdir : string -&gt; fileTree list = &lt;fun&gt;
&gt;

&gt; Folder ("Documents", [File "file1.txt"; File "filte2.txt" ;
Folder("Pictures", []) ; Folder("bin",[File "cmd.dat" ; File "thumbs.db" ])
])
;;
- : fileTree =
Folder ("Documents",
 [File "file1.txt"; File "filte2.txt"; Folder ("Pictures", []);
  Folder ("bin", [File "cmd.dat"; File "thumbs.db"])])


&gt; walkdir "/boot" ;;
- : fileTree list =
[Folder ("grub",
  [Folder ("i386-pc",
    [File "cpio_be.mod"; File "reiserfs.mod"; File "disk.mod";
     File "dm_nv.mod"; File "xfs.mod"; File "zfscrypt.mod";
     File "setjmp.mod"; File "boot.img"; File "uhci.mod"; File "hwmatch.mod";
     File "ohci.mod"; File "xzio.mod"; File "btrfs.mod"; File "echo.mod";
     File "efiemu.mod"; File "ufs1_be.mod"; File "romfs.mod";
     File "minix2_be.mod"; File "fs.lst"; File "gdb.mod"; File "search.mod";
     File "part_gpt.mod"; File "halt.mod"; File "setjmp_test.mod";
    ...

&gt;  walkdir "/home/tux/PycharmProjects/Haskell/haskell" ;;
- : fileTree list =
[Folder ("src",
  [File "stack.hs"; File "a.out"; File "OldState.hs";
   File "bisection_state.hs"; File "FPUtils.hs"; File "randomst.hs"]);
 Folder ("images",
  [File "haskellLogo.png"; File "number-system-in-haskell-9-638.jpg";
   File "euler_newton_cooling.png"; File "monadTable.png";
   File "coinflip.gid"; File "coinflip.gif"; File "chartF2table.png";
   File "chartF1table.png"; File "classes.gif"; File "qrcode_url.png"]);
 File "Functions.md"; File "List_Comprehension.md"; File "Haskell.md";
 File "Useful_Custom_Functions__Iterators_and_Operators.md";
 File "Miscellaneous.md"; File "Pattern_Matching.md"; File "Basic_Syntax.md";
 File "Functors__Monads__Applicatives_and_Monoids.md";
 File "Algebraic_Data_Types.md"; File "Libraries.md";
 File "Documentation_and_Learning_Materials.md"; File "Applications.md";
 File "Functional_Programming_Concepts.md"]
</pre>
</div>



<p>
Sources:
</p>

<ul class="org-ul">
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2008fa/lectures/lec04.html">http://www.cs.cornell.edu/courses/cs3110/2008fa/lectures/lec04.html</a>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Lazy Evaluation</h3>
<div class="outline-text-3" id="text-1-7">
<p>
OCaml, which is a ML derived language, uses strict evaluation by default as oppose to Haskell that uses lazy evaluation by default. However lazy evaluation (aka delayed evaluation) is optional in Ocaml. Lazy evaluation delays the computation until the result is needed. In this evaluation approach results that are not needed are never computed. It allows infinite lists.
</p>

<p>
In a strict language the arguments are always evaluated first.
</p>

<p>
OCaml / Strict Evaluation / Call by Value
</p>
<div class="org-src-container">

<pre class="src src-ocaml">&gt; let give_me_a_three _ = 3
val give_me_a_three : 'a -&gt; int = &lt;fun&gt;

&gt; give_me_a_three (1/0);;
Exception: Division_by_zero.

&gt;  List.length [21 ; 23 ; 123 ; 22/0 ] ;;
Exception: Division_by_zero.
</pre>
</div>

<p>
In a lazy language the arguments are only used if the function needs them.
</p>

<p>
Haskell / Lazy Evaluation / Call be Need
</p>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-operator">&gt;</span> <span class="org-haskell-keyword">let</span> give_me_a_three <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> 3
<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">give_me_a_three</span> (1<span class="org-haskell-operator">/</span>0)
3
<span class="org-haskell-operator">&gt;</span>

<span class="org-haskell-operator">&gt;</span> <span class="org-haskell-definition">length</span> [21, 23, 123, 22<span class="org-haskell-operator">/</span>0 ]
4
<span class="org-haskell-operator">&gt;</span>
</pre>
</div>

<p>
Ocaml allows <b>lazy</b> evaluation with the lazy module and explicit lay constructs.
'a Lazy.t is the polymorphic type of promises to return a value of type 'a.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let lazy_expr = lazy (1/0) ;;
val lazy_expr : int lazy_t = &lt;lazy&gt;

&gt; Lazy.force lazy_expr ;;
Exception: Division_by_zero.


let x = lazy (print_endline "hello" ) ;;
val x : unit lazy_t = &lt;lazy&gt;
&gt; Lazy.force x ;;
hello
- : unit = ()

&gt; let expr = lazy (List.length [21, 23, 123, 22/0 ]) ;;
val expr : int lazy_t = &lt;lazy&gt;

&gt; Lazy.force expr
  ;;
Exception: Division_by_zero.
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-1-7-0-0-1" name="sec-1-7-0-0-1"></a>Infinite Lazy Lists<br  /><div class="outline-text-6" id="text-1-7-0-0-1">
<p>
It is possible to define an infinite list, which is pair of head and value and a promise to the rest of the list.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">type 'a inf_list = Cons of 'a * 'a inf_list Lazy.t
</pre>
</div>

<div class="org-src-container">

<pre class="src src-ocaml">type 'a t = Cons of 'a * ('a t lazy_t)

(* n, n+1, n+2, ... *)
let rec from n = Cons (n, lazy (from (n+1)))

let repeat x = Cons (x, lazy (repeat (x)))

let head (Cons (x, _)) = x
let tail (Cons (_, xs)) = Lazy.force xs

let take n s =
let rec take' m (Cons (x, xs)) l =
 if m = 0 then List.rev l
 else take' (m-1) (Lazy.force xs) (x :: l)
in
 take' n s []

let rec nth n (Cons (x, xs)) =
    if n = 1 then x
    else nth (n-1) (Lazy.force xs)



let rec map f (Cons (x, xs)) =
    Cons (f x, lazy (map f (Lazy.force xs)))


let rec filter f (Cons (x, xs)) =
    Cons (f x, lazy (filter f (Lazy.force xs)))
</pre>
</div>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-ocaml">&gt; take 6 (from 5) ;;
- : int list = [5; 6; 7; 8; 9; 10]

&gt; from 5 |&gt; take 6 ;;
- : int list = [5; 6; 7; 8; 9; 10]


&gt; from 5  |&gt; head ;;
- : int = 5
</pre>
</div>

<p>
From:
</p>
<ul class="org-ul">
<li><a href="http://d.hatena.ne.jp/blanketsky/20070221/1172002969">http://d.hatena.ne.jp/blanketsky/20070221/1172002969</a>
</li>
</ul>

<p>
Sources:
</p>

<ul class="org-ul">
<li><a href="https://ocaml.org/learn/tutorials/functional_programming.html">https://ocaml.org/learn/tutorials/functional_programming.html</a>
</li>
<li><a href="http://ocaml.jp/Lazy%20Pattern">http://ocaml.jp/Lazy%20Pattern</a>
</li>
<li><a href="http://c2.com/cgi/wiki?ExplicitLazyProgramming">http://c2.com/cgi/wiki?ExplicitLazyProgramming</a>
</li>
</ul>

<p>
Documentation of Lazy Module:
</p>

<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Lazy.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Lazy.html</a>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Foreign Function Interface FFI</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The OCaml library C Types allows easy and fast access to C libraries, Operating System services, shared libraries and to call functions and libraries written in another languages.
</p>

<p>
<b>Installation</b>
</p>

<pre class="example">
$ opam install ctypes ctypes-foreign
</pre>
</div>



<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> Calling C Standard Library and Unix System Calls</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
<b>Examples</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; #require "ctypes" ;;
&gt; #require "ctypes.foreign" ;;
&gt; open Foreign ;;
&gt; open PosixTypes ;;
&gt; open Ctypes ;;
</pre>
</div>

<p>
<b>Puts</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">puts</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">s</span>);
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let puts = foreign "puts" (string @-&gt; returning int);;
val puts : bytes -&gt; int = &lt;fun&gt;

&gt; puts "hello world" ;;
hello world
- : int = 12
&gt;
</pre>
</div>

<p>
<b>Chdir</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">chdir</span>  (<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">path</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Changes  the current working directory of the calling</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">process to the directory specified  in path.</span>
</pre>
</div>

<p>
OCaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let chdir_ = foreign "chdir" (string @-&gt; returning int) ;;
val chdir_ : bytes -&gt; int = &lt;fun&gt;

chdir_ "/" ;;
- : int = 0

chdir_ "/wrong directory" ;;
- : int = -1

&gt; let chdir path  =
      let _  = chdir_  path in ()
;;
val chdir : bytes -&gt; unit = &lt;fun&gt;

&gt; chdir "/" ;;
- : unit = ()

&gt; chdir "/wrong directory" ;;
- : unit = ()
</pre>
</div>

<p>
<b>Getcwd</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">char</span> *<span class="org-function-name">getcwd</span>(<span class="org-type">char</span> *<span class="org-variable-name">buf</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span>);
<span class="org-comment-delimiter">//  </span><span class="org-comment">getcwd  get current working directory</span>
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let getcwd =  foreign "getcwd" (void @-&gt; returning string);;
val getcwd : unit -&gt; bytes = &lt;fun&gt;

&gt; getcwd () ;;
- : bytes = "/home"
&gt;
</pre>
</div>

<p>
<b>System</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">system</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">command</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">system - execute a shell command</span>
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let system = foreign "system" (string @-&gt; returning int) ;;
val system : bytes -&gt; int = &lt;fun&gt;


&gt; system "uname -a" ;;
Linux tuxhorse 3.19.0-18-generic #18-Ubuntu SMP Tue May 19 18:30:59 UTC 2015 i686 i686 i686 GNU/Linux
- : int = 0

&gt; system "pwd" ;;
/home/tux/PycharmProjects/Haskell/ocaml
- : int = 0
&gt;

&gt; system "wrong command" ;;
sh: 1: wrong: not found
- : int = 32512
&gt;
</pre>
</div>

<p>
<b>Sleep</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-function-name">sleep</span>(<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">seconds</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">sleep - sleep for the specified number of seconds</span>
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let sleep1 = foreign "sleep" (int @-&gt; returning int) ;;
val sleep : int -&gt; int = &lt;fun&gt;

&gt; sleep1 3 ;;
- : int = 0

&gt; let sleep2 = foreign "sleep" (int @-&gt; returning void) ;;
val sleep2 : int -&gt; unit = &lt;fun&gt;
&gt; sleep2 4 ;;
- : unit = ()
</pre>
</div>

<p>
<b>Get host name</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-type">int</span> <span class="org-function-name">gethostname</span>(<span class="org-type">char</span> *<span class="org-variable-name">name</span>, <span class="org-type">size_t</span> <span class="org-variable-name">len</span>);

 <span class="org-comment-delimiter">//  </span><span class="org-comment">returns the null-terminated hostname in the character array name,</span>
 <span class="org-comment-delimiter">//   </span><span class="org-comment">which has a length of len bytes.</span>

 <span class="org-comment-delimiter">//  </span><span class="org-comment">On success, zero is returned.  On error, -1 is returned, and errno</span>
 <span class="org-comment-delimiter">//  </span><span class="org-comment">is set appropriately</span>
 <span class="org-comment-delimiter">// </span><span class="org-comment">On  Linux,  HOST_NAME_MAX is defined with the value 64 (bytes - chars)</span>
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let get_host = foreign "gethostname" (ptr char @-&gt; int @-&gt; returning int) ;;
val get_host : char Ctypes_static.ptr -&gt; int -&gt; int = &lt;fun&gt;

&gt; let host_name_max = 64 ;;
val host_name_max : int = 64

&gt; let s = allocate_n char ~count:host_name_max ;;
val s : char Ctypes.ptr = Ctypes_static.CPointer &lt;abstr&gt;

&gt; get_host s host_name_max ;;
- : int = 0

&gt; string_from_ptr s ~length:host_name_max ;;
- : string =
"tuxhorse\000\000\000\000\.....\000\000\000\000"

&gt; coerce (ptr char) string s ;;
- : string = "tuxhorse"

   (* Everything together      *)
   (* ---------------------------------*)

&gt; let get_host = foreign "gethostname" (ptr char @-&gt; int @-&gt; returning int) ;;
val get_host : char Ctypes_static.ptr -&gt; int -&gt; int = &lt;fun&gt;

&gt; let gethostname () =
       let host_name_max = 64 in
       let s = allocate_n char ~count:host_name_max in
       let _ = get_host s host_name_max in
       coerce (ptr char) string s
    ;;
val gethostname : unit -&gt; string = &lt;fun&gt;

&gt; gethostname () ;;
- : string = "tuxhorse"
</pre>
</div>

<p>
<b>Cube Root Function</b>
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;math.h&gt;</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">The  cbrt()  function  returns the (real) cube root of x.</span>
<span class="org-type">double</span> <span class="org-function-name">cbrt</span>(<span class="org-type">double</span> <span class="org-variable-name">x</span>);
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let cbrt = foreign "cbrt" (double @-&gt; returning double) ;;
val cbrt : float -&gt; float = &lt;fun&gt;

&gt; List.map cbrt [1.; 8.; 64.; 125.; 216.; 1000.] ;;
- : float list = [1.; 2.; 4.; 5.; 6.; 10.]
</pre>
</div>

<p>
<b>Popen</b>
</p>

<p>
Get command output to string.
</p>

<p>
C prototype
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>

<span class="org-type">FILE</span> *<span class="org-function-name">popen</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">command</span>, <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">type</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">popen, pclose - pipe stream to or from a process</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The  popen()  function  opens  a  process  by creating a pipe, forking,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and invoking the shell.  Since a pipe is by definition unidirectional,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the type argument may specify only reading  or  writing,  not  both;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the  resulting stream is correspondingly read-only or write-only</span>
</pre>
</div>

<p>
Ocaml
</p>

<div class="org-src-container">

<pre class="src src-ocaml"> #require "ctypes" ;;
 #require "ctypes.foreign" ;;
open PosixTypes ;;
open Ctypes ;;
open Foreign ;;

let is_null_ptr pointer_type pointer =
 ptr_compare pointer (from_voidp pointer_type null) = 0 ;;

let string_of_ptrchar ptrch =  coerce (ptr char)  string ptrch ;;

let fgets =
 foreign "fgets" (ptr char @-&gt; int @-&gt; ptr int @-&gt; returning (ptr char)) ;;

let popen_ =
 foreign "popen" (string @-&gt; string @-&gt; returning (ptr int)) ;;

let make_null_ptr ptrtype = from_voidp  ptrtype null ;;

exception Exit_loop ;;


let read_fd file_descriptor =
    let buffsize = 4000 in (* Buffer of 4000 bytes *)
    let v = Pervasives.ref (from_voidp  char null) in
    let b = Buffer.create buffsize in
    let s = allocate_n char ~count:buffsize in

    let closure () =
        try while true do
          v :=  fgets s (buffsize - 1) file_descriptor ;
          if is_null_ptr char !v then raise Exit_loop ;
          Buffer.add_string b  (string_of_ptrchar s) ;
        done
        with Exit_loop -&gt; () ;

    in closure () ; Buffer.contents b
;;


let popen command = read_fd (popen_ command "r");;

&gt; popen "ls" ;;
- : bytes = "images\nocamldep-sorter\nREADME.hml\nREADME.html\nREADME.md\nsrc\nTest.html\n" &gt;


&gt; popen "ls" |&gt; print_string ;;
images
ocamldep-sorter
README.hml
README.html
README.md
src
Test.html
- : unit = ()
&gt;

&gt; popen "pwd" |&gt; print_string ;;
/home/tux/PycharmProjects/Haskell/ocaml
- : unit = ()
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> Calling Shared Libraries</h4>
<div class="outline-text-4" id="text-1-8-2">
</div><div id="outline-container-sec-1-8-2-1" class="outline-5">
<h5 id="sec-1-8-2-1"><span class="section-number-5">1.8.2.1</span> Calling GNU Scientific Library</h5>
<div class="outline-text-5" id="text-1-8-2-1">
<ul class="org-ul">
<li>Calling GSL - GNU Scientific Library
</li>

<li><a href="https://www.gnu.org/software/gsl/manual/html_node">GSL Manual</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; #require "ctypes" ;;
&gt; #require "ctypes" ;;
&gt; #require "ctypes.foreign" ;;
&gt; open Foreign ;;
&gt; open PosixTypes ;;
&gt; open Ctypes ;;

&gt; let gsl_lib = Dl.dlopen ~filename:"libgsl.so" ~flags:[Dl.RTLD_LAZY; Dl.RTLD_GLOBAL];;
val gsl_lib : Dl.library = &lt;abstr&gt;
&gt;


(*
 *   double gsl_sf_bessel_J0 (double x)
 *
 *  gsl_sf_bessel_J0(5) = -1.775967713143382920e-01
 *
 *------------------------------------------------------------------
 *)

&gt; let gsl_sf_bessel_J0 = foreign ~from:gsl_lib "gsl_sf_bessel_J0" (double @-&gt; returning double ) ;;
val gsl_sf_bessel_J0 : float -&gt; float = &lt;fun&gt;

&gt; gsl_sf_bessel_J0 5.0 ;;
- : float = -0.177596771314338292

&gt; List.map gsl_sf_bessel_J0 [1.0; 10.0; 100.0; 1000.0 ] ;;
- : float list =
[0.765197686557966494; -0.245935764451348265; 0.0199858503042231184;
 0.024786686152420169]

(*
 *   Polynomial Evaluation
 *
 *  double gsl_poly_eval (const double c[], const int len, const double x)
 *
 *   The functions described here evaluate the polynomial
 *   P(x) = c[0] + c[1] x + c[2] x^2 + ... + c[len-1] x^{len-1}
 *
 *   using Horner’s method for stability. Inline versions of these
 *   functions are used when HAVE_INLINE is defined.
 *
 *   This function evaluates a polynomial with real coefficients for
 *   the real variable x.
 *
 * ------------------------------------------------------------------
 *)

    (*
     *  Let's evaluate  3 * x^2 + 2 * x + 1
     *
     *  so it becomes:  [1. ; 2. ; 3. ]
     *
     *
     *  (3 * x^2 + 2 * x + 1) 5 = 86
     *  (3 * x^2 + 2 * x + 1) 7 = 162
     *  (3 * x^2 + 2 * x + 1) 9 = 262
     *)

&gt; let gsl_poly_eval_ = foreign ~from:gsl_lib "gsl_poly_eval"
(ptr double @-&gt; int @-&gt; double @-&gt; returning double);;
val gsl_poly_eval_ : float Ctypes_static.ptr -&gt; int -&gt; float -&gt; float = &lt;fun&gt;

&gt; let poly =  CArray.of_list double  [1. ; 2. ; 3. ] ;;
val poly : float Ctypes.CArray.t =
  {Ctypes_static.astart = Ctypes_static.CPointer &lt;abstr&gt;; alength = 3}

&gt; CArray.start poly ;;
- : float Ctypes.ptr = Ctypes_static.CPointer &lt;abstr&gt;

&gt; gsl_poly_eval_ (CArray.start poly)  3 5.0 ;;
- : float = 86.
&gt; gsl_poly_eval_ (CArray.start poly)  3 7.0 ;;
- : float = 162.
&gt; gsl_poly_eval_ (CArray.start poly)  3 9.0 ;;
- : float = 262.


    (* Assemblying all pieces of code *)

&gt; let gsl_poly_eval_ = foreign ~from:gsl_lib "gsl_poly_eval"
  (ptr double @-&gt; int @-&gt; double @-&gt; returning double);;
val gsl_poly_eval_ : float Ctypes_static.ptr -&gt; int -&gt; float -&gt; float = &lt;fun&gt;

&gt; let gsl_poly_val poly x =
       let p = CArray.of_list double poly in
       gsl_poly_eval_ (CArray.start p) (List.length poly) x
  ;;
val gsl_poly_val : float list -&gt; float -&gt; float = &lt;fun&gt;


&gt;  List.map (gsl_poly_val [1. ; 2. ; 3. ] ) [5.0 ; 7.0 ; 9.0] ;;
- : float list = [86.; 162.; 262.]

&gt; let mypoly = gsl_poly_val [1. ; 2. ; 3. ]  ;;
val mypoly : float -&gt; float = &lt;fun&gt;

&gt; List.map mypoly [5.0 ; 7.0 ; 9.0] ;;
- : float list = [86.; 162.; 262.]
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-2-2" class="outline-5">
<h5 id="sec-1-8-2-2"><span class="section-number-5">1.8.2.2</span> Calling Python</h5>
<div class="outline-text-5" id="text-1-8-2-2">
<ul class="org-ul">
<li><a href="https://docs.python.org/2/extending/embedding.html">Embedding Python in Another Application</a>
</li>

<li><a href="https://docs.python.org/2/c-api/init.html">Initializing and finalizing the interpreter - Python/C API Reference Manual</a>
</li>

<li><a href="https://docs.python.org/2/c-api/veryhigh.html">The Very High Level Layer - Python/C API Reference Manual</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-ocaml">&gt;
  open Foreign ;;
&gt;  open PosixTypes ;;
&gt; open Ctypes ;;
&gt;

&gt;  let pylib = Dl.dlopen ~filename:"libpython2.7.so" ~flags:[Dl.RTLD_LAZY; Dl.RTLD_GLOBAL];;
val pylib : Dl.library = &lt;abstr&gt;
&gt; let py_init = foreign "Py_Initialize" ~from:pylib (void @-&gt; returning void) ;;
val py_init : unit -&gt; unit = &lt;fun&gt;
&gt; py_init () ;;
- : unit = ()

&gt; let py_getPath = foreign "Py_GetPath" ~from:pylib (void @-&gt; returning string) ;;
val py_getPath : unit -&gt; string = &lt;fun&gt;
&gt; py_getPath () ;;
- : string =
"/home/tux/lib:/usr/lib/python2.7/:/usr/lib/python2.7/plat-i386-linux-gnu:/usr/lib/python2.7/lib-tk:/usr/lib/python2.7/lib-old:/usr/lib/python2.7/lib-dynload"
&gt;

&gt; let py_getVersion = foreign "Py_GetVersion" ~from:pylib (void @-&gt; returning string) ;;
val py_getVersion : unit -&gt; string = &lt;fun&gt;
&gt;
&gt; py_getVersion() ;;
- : string = "2.7.9 (default, Apr  2 2015, 15:39:13) \n[GCC 4.9.2]"
&gt;

  let py_GetPlatform = foreign "Py_GetPlatform" ~from:pylib (void @-&gt; returning string) ;;
val py_GetPlatform : unit -&gt; string = &lt;fun&gt;
&gt; py_GetPlatform () ;;
- : string = "linux2"
&gt;

&gt; let pyRunSimpleString = foreign "PyRun_SimpleString" ~from:pylib (string @-&gt; returning int) ;;
val pyRunSimpleString : string -&gt; int = &lt;fun&gt;
&gt;
  pyRunSimpleString "print 'hello world'" ;;
hello world
- : int = 0

&gt; pyRunSimpleString "f = lambda x: 10.5 * x - 4" ;;
- : int = 0
&gt; pyRunSimpleString "print (map(f, [1, 2, 3, 4, 5, 6, 7])" ;;
  File "&lt;string&gt;", line 1
    print (map(f, [1, 2, 3, 4, 5, 6, 7])
                                       ^
SyntaxError: unexpected EOF while parsing
- : int = -1

&gt; pyRunSimpleString "print (map(f, [1, 2, 3, 4, 5, 6, 7]))" ;;
[6.5, 17.0, 27.5, 38.0, 48.5, 59.0, 69.5]
- : int = 0

&gt; pyRunSimpleString "import sys ; print sys.executable" ;;
/usr/bin/python
- : int = 0
&gt;

&gt; let py_finalize = foreign "Py_Finalize" ~from:pylib (void @-&gt; returning void)
  ;;
val py_finalize : unit -&gt; unit = &lt;fun&gt;
&gt; py_finalize () ;;
- : unit = ()
&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> Finding Shared Libraries</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
Unix Standard system calls on Linux.  You can see the Linux lib-C functions documentation by using the commands:
</p>

<div class="org-src-container">

<pre class="src src-bash">$ man puts
$ man getcwd
</pre>
</div>

<p>
It is possible to find shared libraries used by executables by using the ldd command.
</p>

<div class="org-src-container">

<pre class="src src-bash">$ which rlwrap
/usr/bin/rlwrap

$ ldd $(which rlwrap)
    linux-gate.so.1 =&gt;  (0xb77bf000)
    libutil.so.1 =&gt; /lib/i386-linux-gnu/libutil.so.1 (0xb779f000)
    libreadline.so.6 =&gt; /lib/i386-linux-gnu/libreadline.so.6 (0xb775a000)
    libtinfo.so.5 =&gt; /lib/i386-linux-gnu/libtinfo.so.5 (0xb7736000)
    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb757b000)
    /lib/ld-linux.so.2 (0xb77c0000)

$ ldd $(which ssh)
    linux-gate.so.1 =&gt;  (0xb774a000)
    libselinux.so.1 =&gt; /lib/i386-linux-gnu/libselinux.so.1 (0xb763f000)
    libresolv.so.2 =&gt; /lib/i386-linux-gnu/libresolv.so.2 (0xb7626000)
    libcrypto.so.1.0.0 =&gt; /lib/i386-linux-gnu/libcrypto.so.1.0.0 (0xb7452000)
    libdl.so.2 =&gt; /lib/i386-linux-gnu/libdl.so.2 (0xb744d000)
    libz.so.1 =&gt; /lib/i386-linux-gnu/libz.so.1 (0xb7432000)
    libgssapi_krb5.so.2 =&gt; /usr/lib/i386-linux-gnu/libgssapi_krb5.so.2 (0xb73e2000)
    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7227000)
    libpcre.so.3 =&gt; /lib/i386-linux-gnu/libpcre.so.3 (0xb71b4000)
    /lib/ld-linux.so.2 (0xb774b000)
    libkrb5.so.3 =&gt; /usr/lib/i386-linux-gnu/libkrb5.so.3 (0xb70e1000)
    libk5crypto.so.3 =&gt; /usr/lib/i386-linux-gnu/libk5crypto.so.3 (0xb70af000)
    libcom_err.so.2 =&gt; /lib/i386-linux-gnu/libcom_err.so.2 (0xb70aa000)
    libkrb5support.so.0 =&gt; /usr/lib/i386-linux-gnu/libkrb5support.so.0 (0xb709d000)
    libpthread.so.0 =&gt; /lib/i386-linux-gnu/libpthread.so.0 (0xb707f000)
    libkeyutils.so.1 =&gt; /lib/i386-linux-gnu/libkeyutils.so.1 (0xb707a000)

$ # Trace System Calls

$ strace -c ls
build.sh  codes    haskell  Make      ocaml   README.back.md  README.md  Test.html
clean.sh  dict.sh  LICENSE  Makefile  papers  README.html     tags   tmp
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
  0.00    0.000000           0         9           read
  0.00    0.000000           0         2           write
  0.00    0.000000           0        11           open
  0.00    0.000000           0        14           close
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         9         9 access
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         2           ioctl
  0.00    0.000000           0         3           munmap
  ... ....

$ ######### For Ubuntu / Debian Only Only ###########################
$ #
$ apt-cache search gsl | grep -i dev | grep -i lib
libgsl0-dev - GNU Scientific Library (GSL) -- development package
libghc-hmatrix-dev - Linear algebra and numerical computation in Haskell
libocamlgsl-ocaml-dev - GNU scientific library for OCaml


$ apt-cache search gsl | grep -i dev | grep -i lib
libgsl0-dev - GNU Scientific Library (GSL) -- development package
libghc-hmatrix-dev - Linear algebra and numerical computation in Haskell


$ apt-cache search python lib dev | grep -i dev | grep -i libpython
libpython-all-dev - package depending on all supported Python development packages
libpython-dev - header files and a static library for Python (default)
libpython2.7-dev - Header files and a static library for Python (v2.7)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4"><span class="section-number-4">1.8.4</span> References</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
<b>OCAML Ctypes</b>
</p>


<ul class="org-ul">
<li><a href="https://realworldocaml.org/v1/en/html/foreign-function-interface.html">Book - Real World OCAML - Chapter 19. Foreign Function Interface</a>
</li>

<li><a href="http://ocamllabs.github.io/ocaml-ctypes">OCAML Ctypes Documentation</a>
</li>
<li><a href="https://github.com/ocamllabs/ocaml-ctypes/wiki/FAQ">Ctypes FAQ - OCAML Labs</a>
</li>
<li><a href="https://github.com/ocamllabs/ocaml-ctypes/wiki/ctypes-tutorial">Ctypes tutorial - OCAML Labs</a>
</li>
<li><a href="https://github.com/ocamllabs/ocaml-ctypes">Github - OCAML Labs - Ctypes</a>
</li>
<li><a href="https://sympa.inria.fr/sympa/arc/caml-list/2013-06/msg00046.html">Mail List: ocaml-ctypes, a library for calling C functions directly from OCaml</a>
</li>
<li><a href="https://github.com/ocamllabs/ocaml-ctypes/tree/master/examples">Repository Examples - OCAML Labs</a>
</li>
</ul>

<p>
<b>C Libraries Used in this section</b>
</p>

<ul class="org-ul">
<li><a href="https://www.kernel.org/doc/man-pages/"> Linux kernel and C library interfaces - Kernel.Org</a>
</li>
<li><a href="http://en.wikipedia.org/wiki/System_call">Wikipedia - System call</a>
</li>
<li><a href="http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html">Linux System Call Table</a>
</li>
<li><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">Linux Programmer's Manual SYSCALLS(2)</a>
</li>
<li><a href="http://libflow.com/d/fz1qu63i/LINUX_System_Call_Quick_Reference">Linux System Calls Quick Reference</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="https://www.gnu.org/software/gsl/">GSL - GNU Scientific Library</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Module System</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> Overview</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
The Ocaml module system helps to organize the code, avoid names
collision, provides local namespacing and hide implementation details.
</p>
</div>
</div>

<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> Opening Modules</h4>
<div class="outline-text-4" id="text-1-9-2">
<div class="org-src-container">

<pre class="src src-ocaml">(** Show Module Contents *)

# #show Filename ;;
module Filename :
  sig
    val current_dir_name : string
    val parent_dir_name : string
    val dir_sep : string
    val concat : string -&gt; string -&gt; string
    val is_relative : string -&gt; bool
    val is_implicit : string -&gt; bool
    val check_suffix : string -&gt; string -&gt; bool
    val chop_suffix : string -&gt; string -&gt; string
    val chop_extension : string -&gt; string
    val basename : string -&gt; string
    val dirname : string -&gt; string
    val temp_file : ?temp_dir:string -&gt; string -&gt; string -&gt; string
    val open_temp_file :
      ?mode:open_flag list -&gt;
      ?temp_dir:string -&gt; string -&gt; string -&gt; string * out_channel
    val get_temp_dir_name : unit -&gt; string
    val set_temp_dir_name : string -&gt; unit
    val temp_dir_name : string
    val quote : string -&gt; string
  end
# 


(** Open a module Locally *)

#  let open List in map ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
# 

#  let open List in map (fun x -&gt; x +1) [1; 2; 3; 4; 5] ;;
- : int list = [2; 3; 4; 5; 6]
# 

# map (fun x -&gt; x +1) [1; 2; 3; 4; 5] ;;
Error: Unbound value map
Hint: Did you mean max?
# 

# let open Array in  map ;;
- : ('a -&gt; 'b) -&gt; 'a array -&gt; 'b array = &lt;fun&gt;
# 

#  let open Array in map (fun x -&gt; x +1) [| 1; 2; 3; 4; 5 |] ;;
- : int array = [|2; 3; 4; 5; 6|]
#     

(** Open a module inside parenthesis *)

# List.(map) ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;

# Array.(map) ;;
- : ('a -&gt; 'b) -&gt; 'a array -&gt; 'b array = &lt;fun&gt;
# 

# List.(map (fun x -&gt; x +1) [1; 2; 3; 4; 5]) ;;
- : int list = [2; 3; 4; 5; 6]
# 

# Array.(map (fun x -&gt; x +1) [| 1; 2; 3; 4; 5 |]) ;;
- : int array = [|2; 3; 4; 5; 6|]

(** Module Alias *)

# module L = List ;;
module L = List

# #show L ;;
module L = List
# 

# L.map ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
# 
  L.map ((+) 1)  [1 ; 2; 3; 4; 5; 6] ;;
- : int list = [2; 3; 4; 5; 6; 7]
# 

# let open L in map ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
# 

#  let open L in map (fun x -&gt; x +1) [1; 2; 3; 4; 5] ;;
- : int list = [2; 3; 4; 5; 6]
# 

(** Open a module inside a function *)


# let dummy_function xs ys = 
      let open List in 
      map (fun (x, y) -&gt; 3 * x + 5 * y) (combine xs ys)
  ;;
val dummy_function : int list -&gt; int list -&gt; int list = &lt;fun&gt;
# 

# dummy_function [2; 3; 4; 5] [1; 2; 3; 4] ;;
- : int list = [11; 19; 27; 35]
# 

(** Open a module inside a function *)

# let dummy_function xs ys = 
      let module L = List in 
      L.map (fun (x, y) -&gt; 3 * x + 5 * y) (L.combine xs ys)
  ;;
val dummy_function : int list -&gt; int list -&gt; int list = &lt;fun&gt;
# 

(** Open a module globally in the toplevel or inside another module
    if the module is opened in a file.
 *)

# open List ;;
# 

#  map ;;
- : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;
# find ;;
- : ('a -&gt; bool) -&gt; 'a list -&gt; 'a = &lt;fun&gt;
# filter ;;
- : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list = &lt;fun&gt;
# 

# map (fun x -&gt; x +1) [1; 2; 3; 4; 5] ;;
- : int list = [2; 3; 4; 5; 6]
# 

# map ((+) 1)  [1; 2; 3; 4; 5] ;;
- : int list = [2; 3; 4; 5; 6]

# map ((+) 1)  [1; 2; 3; 4; 5] |&gt; find (fun x -&gt; x &gt; 2) ;;
- : int = 3
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3"><span class="section-number-4">1.9.3</span> Defining a module in the Toplevel</h4>
<div class="outline-text-4" id="text-1-9-3">
<div class="org-src-container">

<pre class="src src-ocaml"># module MyModule = 
         struct 

         let f1 x = 10 * x 
         let f x y = 4 * x + y 

         let const1 = 100.232
         let msg1  = "hello world"

         let (+) x y  = 10 * x + 3 * y

         end 
        ;;
module MyModule :
  sig
    val f1 : int -&gt; int
    val f : int -&gt; int -&gt; int
    val const1 : float
    val msg1 : string
    val ( + ) : int -&gt; int -&gt; int
  end


(** Using the module functions *)

# MyModule.f1 ;;
- : int -&gt; int = &lt;fun&gt;

# MyModule.f ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

# MyModule.(+) ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# 


# MyModule.const1 ;;
- : float = 100.232
# 

# MyModule.f 90 10 ;;
- : int = 370
# 
  List.map (MyModule.f 90) [10; 20; 30; 40; 50] ;;
- : int list = [370; 380; 390; 400; 410]
# 


(** Using a operator defined inside the module 

    16  = 10 * 1 + 3 * 2
*)

# MyModule.( 1 + 2) ;;
- : int = 16


(** Open a module locally *)

# let open MyModule in f1 20 ;;
- : int = 200

# f1 20 ;;
Error: Unbound value f1
# 

# let open MyModule in List.map f1 [10; 20; 30; 40; 50] ;;
- : int list = [100; 200; 300; 400; 500]
# 

# let open MyModule in let open List in map f1 [10; 20; 30; 40; 50] ;;
- : int list = [100; 200; 300; 400; 500]    

# List.map f1 [10; 20; 30; 40; 50] ;;
Error: Unbound value f1

(** Show module signature *)

# #show MyModule ;;
module MyModule :
  sig
    val f1 : int -&gt; int
    val f : int -&gt; int -&gt; int
    val const1 : float
    val msg1 : string
    val ( + ) : int -&gt; int -&gt; int
  end
#    

(** Module Alias, give a short name to a module *)

# module M = MyModule ;;
module M = MyModule
# 

# M.f 20 30 ;;
- : int = 110
# 

# M.f1 50 ;;
- : int = 500
# 

# M.(1 + 2);;
- : int = 16
# 

#  let x = let open M in 1 + 2 ;;
val x : int = 16

# 1 + 2 ;;
- : int = 3
#    

# let open M in List.map f1 [10; 20; 30; 40; 50] ;;
- : int list = [100; 200; 300; 400; 500]

#  let xs = let open M in List.map f1 [10; 20; 30; 40; 50] ;;
val xs : int list = [100; 200; 300; 400; 500]
# xs ;;
- : int list = [100; 200; 300; 400; 500]


(** Open a module inside a function *)

#  let fun1 x = 
      let open MyModule in
      f 3 (f1 4 + f1 x)
  ;;

#  fun1 4 ;;
- : int = 532

# fun1 8 ;;
- : int = 652
# 


(** Module Alias inside a Function *)

# let fun1 x = 
      let module A = MyModule in
      A.(f 3 ((f1 4) + (f1 x)))
  ;;
val fun1 : int -&gt; int = &lt;fun&gt;
# 

# fun1 3 ;;
- : int = 502
# fun1 8 ;;
- : int = 652
# 


(** Open a Module Globally *)

# open MyModule ;;    

# f1 3 ;;
- : int = 30
# f1 10 ;;
- : int = 100
# List.map f1 [10; 20; 30; 40; 50] ;;
- : int list = [100; 200; 300; 400; 500]
# 

# 1 + 2 ;;
- : int = 16
#
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-4" class="outline-4">
<h4 id="sec-1-9-4"><span class="section-number-4">1.9.4</span> Loading file as module in the toplevel</h4>
<div class="outline-text-4" id="text-1-9-4">
<p>
Let the file myModule.ml have the content:
</p>

<div class="org-src-container">

<pre class="src src-ocaml">let f1 x = 10 * x 
let f x y = 4 * x + y 

let const1 = 100.232
let msg1  = "hello world"

let () = Printf.printf "Hello Ocaml FP"
</pre>
</div>

<p>
Load file 
</p>

<pre class="example">
$ rlwrap ocaml

# #use "myModule.ml" ;;
val f1 : int -&gt; int = &lt;fun&gt;
val f : int -&gt; int -&gt; int = &lt;fun&gt;
val const1 : float = 100.232
val msg1 : string = "hello world"
Hello Ocaml FP# 

# f1 4 ;;
- : int = 40
# f1 3 ;;
- : int = 30
# 

# List.map (f 3) [4; 5; 6; 7; 8 ] ;;
- : int list = [16; 17; 18; 19; 20]
#
</pre>

<p>
Load file as module
</p>

<pre class="example">
$ rlwrap ocaml

# #mod_use "myModule.ml" ;;
Hello Ocaml FPmodule MyModule :
  sig
    val f1 : int -&gt; int
    val f : int -&gt; int -&gt; int
    val const1 : float
    val msg1 : string
  end
# 

# MyModule.f1 ;;
- : int -&gt; int = &lt;fun&gt;

# 
  MyModule.f ;;
- : int -&gt; int -&gt; int = &lt;fun&gt;

# MyModule.f 3 4 ;;
- : int = 16

#  List.map (MyModule.f 3) [4; 5; 6; 7; 8 ] ;;
- : int list = [16; 17; 18; 19; 20]
# 

# open MyModule ;;

# List.map (f 3) [4; 5; 6; 7; 8 ] ;;
- : int list = [16; 17; 18; 19; 20]
#
</pre>
</div>
</div>

<div id="outline-container-sec-1-9-5" class="outline-4">
<h4 id="sec-1-9-5"><span class="section-number-4">1.9.5</span> Loading Libraries Modules</h4>
<div class="outline-text-4" id="text-1-9-5">
<p>
It will load the library pcre, that can be installed with $ opam install pcre
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #use "topfind" ;;

# #require "pcre" ;;
/home/tux/.opam/4.02.1/lib/bytes: added to search path
/home/tux/.opam/4.02.1/lib/pcre: added to search path
/home/tux/.opam/4.02.1/lib/pcre/pcre.cma: loaded
# 

# #show Pcre ;;
module Pcre :
  sig
    type error =
        Partial
      | BadPartial
      | BadPattern of string * int
      | BadUTF8
      | BadUTF8Offset
      | MatchLimit
      | RecursionLimit
      | InternalError of string
    exception Error of error
    exception Backtrack
    exception Regexp_or of string * error
    type icflag

#  Pcre.pmatch ~pat:"\\d+,\\d+" "1000,2323" ;;
- : bool = true
# 
# Pcre.pmatch ~pat:"\\d+,\\d+" "sadasdas" ;;
- : bool = false
# 

# let open Pcre in  pmatch ~pat:"\\d+,\\d+" "1000,2323" ;;
- : bool = true
#

# let open Pcre in extract_all ~pat:"(\\d+),(\\d+)" "10023,2323" ;;
- : string array array = [|[|"10023,2323"; "10023"; "2323"|]|]

# let open Pcre in
"23213,132345"
|&gt;  extract_all ~pat:"(\\d+),(\\d+)"
|&gt;  fun c -&gt;  c.(0)
;;
- : string array = [|"23213,132345"; "23213"; "132345"|]

# let open Pcre in
"23213,132345"
|&gt;  extract_all ~pat:"(\\d+),(\\d+)"
|&gt;  fun c -&gt;  c.(0)
|&gt;  fun c -&gt;  int_of_string c.(1), int_of_string c.(2)
;;
- : int * int = (23213, 132345)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-9-6" class="outline-4">
<h4 id="sec-1-9-6"><span class="section-number-4">1.9.6</span> Including Modules</h4>
<div class="outline-text-4" id="text-1-9-6">
<p>
All functions of the native library module List will be included in the new module List that
defines the functions take, drop and range.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">module List =
    struct 

    include List

    let rec take n xs =
            match (n, xs) with
            | (0, _    ) -&gt; []
            | (_, []   ) -&gt; []
            | (k, h::tl) -&gt; k::(take (n-1) tl)

    let rec drop n xs =
            if n &lt; 0 then failwith "n negative"
            else
                match (n, xs) with
                | (0, _ )    -&gt;  xs
                | (_, [])    -&gt;  []
                | (k, h::tl) -&gt;  drop (k-1) tl

    let rec range start stop step =
            if start &gt; stop
            then []
            else start::(range  (start + step) stop step )                

    end 
      ;;        
module List :
  sig
    val length : 'a list -&gt; int
    val hd : 'a list -&gt; 'a
    val tl : 'a list -&gt; 'a list
    val nth : 'a list -&gt; int -&gt; 'a
    val rev : 'a list -&gt; 'a list
    val append : 'a list -&gt; 'a list -&gt; 'a list
    val rev_append : 'a list -&gt; 'a list -&gt; 'a list
    val concat : 'a list list -&gt; 'a list
    val flatten : 'a list list -&gt; 'a list
    val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit
    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit
    val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a
    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b
    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit
    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a
    val fold_right2 :
      ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c
    val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val mem : 'a -&gt; 'a list -&gt; bool
    val memq : 'a -&gt; 'a list -&gt; bool
    val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a
    val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
    val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b
    val assq : 'a -&gt; ('a * 'b) list -&gt; 'b
    val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool
    val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool
    val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val split : ('a * 'b) list -&gt; 'a list * 'b list
    val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list
    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list
    val take : int -&gt; 'a list -&gt; int list
    val drop : int -&gt; 'a list -&gt; 'a list
    val range : int -&gt; int -&gt; int -&gt; int list
  end
# 

# List.range 100 500 10 ;;
- : int list =
[100; 110; 120; 130; 140; 150; 160; 170; 
180; 190; 200; 210; 220; 230; 240;
 250; 260; 270; 280; 290; 300; 310; 
 320; 330; 340; 350; 360; 370; 380; 390;
 400; 410; 420; 430; 440; 450; 460; 470; 
 480; 490; 500]
# 



# List.range 100 500 10 |&gt; List.take 10 ;;
- : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
# 

# List.range 100 500 10 
|&gt; List.filter (fun x -&gt; x mod 5 = 0  &amp;&amp; x mod 3 =  0) ;;
- : int list =
[120; 150; 180; 210; 240; 270; 300; 330; 360; 390; 420; 450; 480]
#
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Compiling</h3>
<div class="outline-text-3" id="text-1-10">
<p>
[Under Construction]
</p>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="https://ocaml.org/learn/tutorials/compiling_ocaml_projects.html">Compiling OCaml projects</a>
</li>
<li><a href="http://www2.lib.uchicago.edu/keith/ocaml-class/compiling.html">OCaml for the Skeptical</a>
</li>
<li><a href="https://nicolaspouillard.fr/ocamlbuild/ocamlbuild-user-guide.html">The ocamlbuild users manua</a>
</li>
<li><a href="http://www.ocamlpro.com/files/ocaml-tools.pdf">OCaml Pro - OCaml Standard Tools Cheat Sheet</a>
</li>
</ul>
</div>

<div id="outline-container-sec-1-10-1" class="outline-4">
<h4 id="sec-1-10-1"><span class="section-number-4">1.10.1</span> Compiling a single file</h4>
<div class="outline-text-4" id="text-1-10-1">
<p>
It requires the packages lwt and cohttp that can be installed with
</p>

<pre class="example">
$ opam instal lwt cohttp 
[NOTE] Package lwt is already installed (current version is 2.4.8).
[NOTE] Package cohttp is already installed (current version is 0.18.1).
</pre>

<p>
Let the file <i>curl.ml</i> have the content 
</p>

<div class="org-src-container">

<pre class="src src-ocaml">#use "topfind" ;;
#require "uri" ;;
#require "cohttp.lwt" ;;

let fetch uri =
    let open Lwt in
    Cohttp_lwt_unix.Client.get uri &gt;&gt;= fun (resp, body) -&gt;
        Cohttp_lwt_body.to_string body &gt;&gt;= fun b -&gt;
            Lwt_io.printl b

let fetch_string uri =
    let open Lwt in
    Cohttp_lwt_unix.Client.get uri &gt;&gt;= fun (resp, body) -&gt;
        Cohttp_lwt_body.to_string body 


let url_content url = 
    let uri = Uri.of_string url 
    in Lwt_main.run (fetch_string uri)

let main () = 
    url_content Sys.argv.(1)
    |&gt; print_endline

let () = 
    if !Sys.interactive 
    then ()
    else main ()
</pre>
</div>

<p>
Running as script
</p>

<div class="org-src-container">

<pre class="src src-ocaml">$ ocaml curl.ml http://httpbin.org/xml
&lt;?xml version='1.0' encoding='us-ascii'?&gt;



&lt;slideshow 
    title="Sample Slide Show"
    date="Date of publication"
    author="Yours Truly"
    &gt;


    &lt;slide type="all"&gt;
      &lt;title&gt;Wake up to WonderWidgets!&lt;/title&gt;
    &lt;/slide&gt;


    &lt;slide type="all"&gt;
        &lt;title&gt;Overview&lt;/title&gt;
        &lt;item&gt;Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great&lt;/item&gt;
        &lt;item/&gt;
        &lt;item&gt;Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets&lt;/item&gt;
    &lt;/slide&gt;

&lt;/slideshow&gt;
</pre>
</div>

<p>
<b>Compiling to bytecode</b>
</p>

<p>
To compile the file the toplevel directives #use, #mod_use, #load must be removed
</p>

<pre class="example">
$ ocamlfind ocamlc -o curl.byte curl.ml -package lwt,cohttp -linkpkg 
File "curl.ml", line 1:
Error: I/O error: curl.ml: No such file or directory
</pre>

<p>
It is possible to remove the directives without change the file by using the -pp option to invoke the preprocessor. To see the byte compiler messages use the option "-verbose".
</p>

<pre class="example">
$ ocamlfind ocamlc -o curl.byte curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'

$ file curl.byte 
curl.byte: a /home/tux/.opam/4.02.1/bin/ocamlrun script executable (binary data)

$ ./curl.byte http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`
</pre>

<p>
<b>Compiling to Native Code</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">$ ocamlfind ocamlopt -o curl.bin curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'

$ file curl.bin
curl.bin: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=6ee2b5087bb4f7e83a87216bd5078eea91c98661, not stripped

$ ./curl.bin http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`
</pre>
</div>

<p>
<b>Simple Makefile</b>
</p>


<p>
File: <i>Makefile</i>
</p>
<div class="org-src-container">

<pre class="src src-Makefile">all: curl.byte curl.bin

curl.byte:
    ocamlfind ocamlc -o curl.byte curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'

curl.bin:
    ocamlfind ocamlopt -o curl.bin curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'

test: test.byte test.bin

test.byte:
    @echo "Testing curl.byte"
    ./curl.byte http://httpbin.org/status/418

test.bin:
    @echo "Testing curl.bin"
    ./curl.byte http://httpbin.org/status/418

clean: 
    rm -rf *.cmo *.cmi *.o *.cmx *.bin *.byte
</pre>
</div>

<p>
Building and Testing 
</p>

<pre class="example">
$ make
ocamlfind ocamlc -o curl.byte curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'
ocamlfind ocamlopt -o curl.bin curl.ml -package uri,lwt,lwt.unix,cohttp.lwt -linkpkg -pp 'sed "s/^#.*;;//"'

$ make test.byte
Testing curl.byte
./curl.byte http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`
$ make test.bin
Testing curl.bin
./curl.byte http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`

$ make test
Testing curl.byte
./curl.byte http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"""`

Testing curl.bin
./curl.byte http://httpbin.org/status/418

    -=[ teapot ]=-

       _...._
     .'  _ _ `.
    | ."` ^ `". _,
    \_;`"---"`|//
      |       ;/
      \_     _/
        `"

$ make clean 
rm -rf *.cmo *.cmi *.o *.cmx *.bin *.byte
</pre>
</div>
</div>

<div id="outline-container-sec-1-10-2" class="outline-4">
<h4 id="sec-1-10-2"><span class="section-number-4">1.10.2</span> Compiling a single File and a single Module</h4>
<div class="outline-text-4" id="text-1-10-2">
<p>
Let the file tools.ml have the content:
</p>

<p>
file: <i>tools.ml</i>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(** 
    To a file be compiled all preprocessor directives like that below
    must be removed or commented like in this file.

    #require "unix" ;;
*)


let read_channel ch =
       let b = Buffer.create 0 in

       let reader chn =
        try Some (input_line chn)
        with End_of_file -&gt; None

       in let rec aux () =
         match reader ch with
          | None -&gt; ()
          | Some line -&gt; Buffer.add_string b (line ^ "\n") ; aux ()
       in aux () ;
       Buffer.contents b 


let popen_in cmd =
          let fd = Unix.open_process_in cmd in
          read_channel fd 

(** Execute a command in a directory and return the command output and 
    finally go back to the start directory
*)
let execute_in_dir dir command = 
    let this = Sys.getcwd () in
    Unix.chdir dir ;
    let out = popen_in command in
    Unix.chdir this ;
    out
</pre>
</div>

<p>
Let the file main.ml be
</p>

<p>
file: <i>main.ml</i>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(*
 #use "topfind" ;;
 #require "unix" ;;
 #load "tools.ml" ;;
*)
let main () =
    Tools.execute_in_dir Sys.argv.(1) "ls"
    |&gt; print_endline

let () = main ()
</pre>
</div>

<p>
Loading in the Toplevel
</p>

<pre class="example">
$ rlwrap ocaml -noinit
</pre>

<div class="org-src-container">

<pre class="src src-ocaml"># #use "tools.ml" ;;
val read_channel : in_channel -&gt; string = &lt;fun&gt;
File "tools.ml", line 1:
Error: Reference to undefined global `Unix'
# 

# #use "topfind" ;;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
# #require "unix" ;;
/home/tux/.opam/4.02.1/lib/ocaml/unix.cma: loaded
# 

# #use "tools.ml" ;;
val read_channel : in_channel -&gt; string = &lt;fun&gt;
val popen_in : string -&gt; string = &lt;fun&gt;
val execute_in_dir : string -&gt; string -&gt; string = &lt;fun&gt;
# 

# popen_in "uname -a" ;;
- : string =
"Linux tuxhorse 3.19.0-21-generic #21-Ubuntu SMP Sun Jun 14 18:34:06 UTC 2015 i686 i686 i686 GNU/Linux\n"
# 

# #mod_use "tools.ml" ;;
module Tools :
  sig
    val read_channel : in_channel -&gt; string
    val popen_in : string -&gt; string
    val execute_in_dir : string -&gt; string -&gt; string
  end
#
</pre>
</div>

<p>
Compiling to bytecode 
</p>

<pre class="example">
$ ocamlfind ocamlc -c tools.ml -package unix -linkpkg

$ file tools.cmi
tools.cmi: OCaml interface file (.cmi) (Version 017)

$ file tools.cmo
tools.cmo: OCaml object file (.cmo) (Version 010)
</pre>

<p>
Loading in the Toplevel
</p>

<div class="org-src-container">

<pre class="src src-ocaml">$ rlwrap ocaml -noinit 

            OCaml version 4.02.1

    # #load "tools.cmo" ;;
    Error: Reference to undefined global `Unix'
    # 
      #use "topfind" ;;
    - : unit = ()
    Findlib has been successfully loaded. Additional directives:
      #require "package";;      to load a package
      #list;;                   to list the available packages
      #camlp4o;;                to load camlp4 (standard syntax)
      #camlp4r;;                to load camlp4 (revised syntax)
      #predicates "p,q,...";;   to set these predicates
      Topfind.reset();;         to force that packages will be reloaded
      #thread;;                 to enable threads

    - : unit = ()


    (** All modules dependencies must be loaded 
        before it is loaded in the REPL 

        Instead of #load "unix.cma" it could be #require "unix" ;;
    *)
    # #load "unix.cma" ;;
    # 

    # #load "tools.cmo" ;;
    # 
      #show Tools ;;
    module Tools :
      sig
        val read_channel : in_channel -&gt; string
        val popen_in : string -&gt; string
        val execute_in_dir : string -&gt; string -&gt; string
      end

    # 
      Tools.execute_in_dir ;;
    - : string -&gt; string -&gt; string = &lt;fun&gt;

    # 
      Sys.getcwd () ;;
    - : string = "/home/tux/PycharmProjects/Haskell/ocaml/src"

    # Tools.execute_in_dir "/etc/boot" "ls" ;;
    Exception: Unix.Unix_error (Unix.ENOENT, "chdir", "/etc/boot").
    # 
      Tools.execute_in_dir "/boot" "ls" ;;
    - : string =
    "abi-3.19.0-15-generic\nabi-3.19.0-18-generic\n..."

    # Sys.getcwd () ;;
    - : string = "/home/tux/PycharmProjects/Haskell/ocaml/src"
    #
</pre>
</div>

<p>
Compiling main.ml to bytecode executable and linking it to unix.cma and tools module
</p>

<pre class="example">
  # It will yield main.cmi and main.cmo

$ ocamlfind ocamlc -o main.byte tools.ml main.ml  -package unix -linkpkg -verbose
Effective set of compiler predicates: pkg_unix,autolink,byte
+ ocamlc.opt -o main.byte -verbose /home/tux/.opam/4.02.1/lib/ocaml/unix.cma tools.ml main.ml

$ file main.byte
main.byte: a /home/tux/.opam/4.02.1/bin/ocamlrun script executable (binary data)

$ ./main.byte /boot
abi-3.19.0-15-generic
abi-3.19.0-18-generic
abi-3.19.0-20-generic
abi-3.19.0-21-generic
config-3.19.0-15-generic
config-3.19.0-18-generic
config-3.19.0-20-generic
config-3.19.0-21-generic
grub
...
</pre>

<p>
Compiling main.ml to main.bin, elf executable (Unix executable)
</p>

<pre class="example">
$ ocamlfind ocamlopt -o main.bin tools.ml main.ml  -package unix -linkpkg -verbose
Effective set of compiler predicates: pkg_unix,autolink,native
+ ocamlopt.opt -o main.bin -verbose /home/tux/.opam/4.02.1/lib/ocaml/unix.cmxa tools.ml main.ml
+ as -o 'tools.o' '/tmp/camlasm78e933.s'
+ as -o 'main.o' '/tmp/camlasmb3767b.s'
+ as -o '/tmp/camlstartup24f721.o' '/tmp/camlstartup77e48a.s'
+ gcc -o 'main.bin'   '-L/home/tux/.opam/4.02.1/lib/ocaml'  '/tmp/camlstartup24f721.o' '/home/tux/.opam/4.02.1/lib/ocaml/std_exit.o' 'main.o' 'tools.o' '/home/tux/.opam/4.02.1/lib/ocaml/unix.a' '/home/tux/.opam/4.02.1/lib/ocaml/stdlib.a' '-lunix' '/home/tux/.opam/4.02.1/lib/ocaml/libasmrun.a' -lm  -ldl

$ du -h main.bin
600K    main.bin
600K    tota

$ file main.bin 
main.bin: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=ab01870292ad80ccb6ec8b74dca2cd2f342bd96d, not stripped

$ ./main.bin /boot
abi-3.19.0-15-generic
abi-3.19.0-18-generic
abi-3.19.0-20-generic
abi-3.19.0-21-generic
config-3.19.0-15-generic
config-3.19.0-18-generic
config-3.19.0-20-generic
config-3.19.0-21-generic
grub
initr
</pre>

<p>
Simple Makefile
</p>

<p>
<i>Makefile</i>
</p>
<div class="org-src-container">

<pre class="src src-Makefile">main.byte:
    ocamlfind ocamlc -o main.byte tools.ml main.ml  -package unix -linkpkg -verbose

main.bin:
    ocamlfind ocamlopt -o main.bin tools.ml main.ml  -package unix -linkpkg -verbose

clean:
    rm -rf *.cmo *.cmi *.o *.cmx *.bin *.byte
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-10-3" class="outline-4">
<h4 id="sec-1-10-3"><span class="section-number-4">1.10.3</span> See also</h4>
<div class="outline-text-4" id="text-1-10-3">
<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/u3-ocaml/ocaml-modules.html">OCaml User Manual - Chapter 4  The module language</a>
</li>
<li><a href="http://lambdafoo.com/blog/2015/05/15/unreliable-guide-to-ocaml-modules/">Unreliable Guide to OCaml Modules</a>
</li>
<li><a href="https://realworldocaml.org/v1/en/html/files-modules-and-programs.html">Real World OCaml - Chapter 4. Files, Modules, and Programs</a>
</li>
<li><a href="https://haifengl.wordpress.com/2014/07/15/ocaml-modules/">Haifeng's Random Walk - OCaml: Modules</a>
</li>
<li><a href="http://okmij.org/ftp/ML/first-class-modules/">First-class modules: hidden power and tantalizing promises</a>
</li>
<li><a href="http://cic.puj.edu.co/wiki/lib/exe/fetch.php?id=materias:leng2&cache=cache&media=materias:leng2:resources:lecture10-ocaml-adv.pdf">The OCaml Module System - Faculty of Engineering Pontificia Universidad Javeriana</a>
</li>
<li><a href="http://www.ocamlpro.com/blog/2011/08/10/ocaml-pack-functors.html">OCaml Pro - Packing and Functors</a>
</li>
<li><a href="http://www2.lib.uchicago.edu/keith/ocaml-class/modules.html">Caml for the Skeptical</a>
</li>
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec09-functors/functors.htm">Lecture 9: Functors — Parameterized Modules</a>
</li>
<li><a href="http://cseweb.ucsd.edu/classes/sp00/cse231/tutorialeng/node3.html">How to use modules with ocaml</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Creating Libraries, Modules and Compiling to Bytecode or Machine Code</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1"><span class="section-number-4">1.11.1</span> Loading Files in Interactive Shell</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
File: example.ml
</p>

<div class="org-src-container">

<pre class="src src-ocaml">let pi = 3.141515
let byte_size = 8
let kbyte_size = 8192


let avg x y = (x +. y) /. 2.0

let print_avg x y = print_float (avg x y)

let say_hello = print_string "Hello world OCaml"

let inc_int (x: int) : int = x+ 1 ;;

let is_zero x =
    match x with
    | 0 -&gt; true
    | _ -&gt; false


let is_one = function
    | 1 -&gt; true
    | _ -&gt; false

(* Recursive Function *)
let rec factorial n =
    if n = 0
        then 1
        else n*factorial (n-1)

module Week = struct

    type weekday = Mon | Tues | Wed | Thurs | Fri | Sun  ;;

    let from_weekday_to_string week =
        match week with
              Mon   -&gt; "Monday"
            | Tues  -&gt; "Tuesday"
            | Wed   -&gt; "Wednesday"
            | Thurs -&gt; "Thursday"
            | Fri   -&gt; "Friday"
            | Sun   -&gt; "Sunday"
end

module PhysicalConstants = struct
    let g = 9.81
    let gravity = 6.67384e-11
end
</pre>
</div>

<p>
Loading File From interpreter/ toplevel.
</p>

<pre class="example">
$ ocaml # or $utop

# #use "example.ml" ;;
val pi : float = 3.141515
val byte_size : int = 8
val kbyte_size : int = 8192
val avg : float -&gt; float -&gt; float = &lt;fun&gt;
val print_avg : float -&gt; float -&gt; unit = &lt;fun&gt;
Hello world OCamlval say_hello : unit = ()
val inc_int : int -&gt; int = &lt;fun&gt;
val is_zero : int -&gt; bool = &lt;fun&gt;
val is_one : int -&gt; bool = &lt;fun&gt;
val factorial : int -&gt; int = &lt;fun&gt;
module Week :
  sig
    type weekday = Mon | Tues | Wed | Thurs | Fri | Sun
    val from_weekday_to_string : weekday -&gt; string
  end
module PhysicalConstants : sig val g : float val gravity : float end
#

# pi ;;
- : float = 3.141515
# is_zero 10 ;;
- : bool = false
# is_zero 0 ;;
- : bool = true
# factorial 5 ;;
- : int = 120
#


# PhysicalConstants.gravity ;;
- : float = 6.67384e-11
# PhysicalConstants.g ;;
- : float = 9.81
#


# Week.Mon ;;
- : Week.weekday = Week.Mon
# Week.Tues ;;
- : Week.weekday = Week.Tues

# Week.from_weekday_to_string ;;
- : Week.weekday -&gt; string = &lt;fun&gt;

# Week.from_weekday_to_string Week.Tues ;;
- : string = "Tuesday"
# Week.from_weekday_to_string Week.Mon ;;
- : string = "Monday"
#

# open Week ;;
# Mon ;;
- : Week.weekday = Mon

# Tues ;;
- : Week.weekday = Tues
#

# List.map from_weekday_to_string [Mon ; Sun; Tues ] ;;
- : string list = ["Monday"; "Sunday"; "Tuesday"]
#

# open PhysicalConstants ;;
#
# g ;;
- : float = 9.81
# gravity ;;
- : float = 6.67384e-11
#
</pre>
</div>
</div>

<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2"><span class="section-number-4">1.11.2</span> Compile Module to Bytecode</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
After the compiling example.ml files: example.cmi and example.cmo will be created. The module "Example" can be loaded without the source code after compiled into the toplevel shell.
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ocamlc -c  example.ml

$ # Test file types

$ file example.cmi
example.cmi: OCaml interface file (.cmi) (Version 015)

$ file example.cmo
example.cmo: OCaml object file (.cmo) (Version 007)

$ # Check Module Type signature
$ ocamlc -i -c example.ml
val pi : float
val byte_size : int
val kbyte_size : int
val avg : float -&gt; float -&gt; float
val print_avg : float -&gt; float -&gt; unit
val say_hello : unit
val inc_int : int -&gt; int
val is_zero : int -&gt; bool
val is_one : int -&gt; bool
val factorial : int -&gt; int
module Week :
  sig
    type weekday = Mon | Tues | Wed | Thurs | Fri | Sun
    val from_weekday_to_string : weekday -&gt; string
  end
module PhysicalConstants : sig val g : float val gravity : float end

$ Export Module signature
$ ocamlc -i -c example.ml &gt; example.mli
</pre>
</div>

<p>
Loading compiled bytecode into toplevel: $ ocaml
</p>

<pre class="example">
$ mv example.ml example2.ml
$ utop
utop # #load "example.cmo";;

utop # Example.avg 23.2 232.32
;;
- : float = 127.759999999999991

utop # Example.Week.from_weekday_to_string Example.Week.Sun ;;
- : string = "Sunday"

utop # Sun ;;
- : weekday = Sun

utop # Mon ;;
- : weekday = Mon

utop # List.map from_weekday_to_string [Mon ; Sun; Tues ] ;;
- : string list = ["Monday"; "Sunday"; "Tuesday"]

utop # Example.PhysicalConstants.g;;
- : float = 9.81

utop # Example.PhysicalConstants.gravity ;;
- : float = 6.67384e-11

utop # Example.factorial 5 ;;
- : int = 120

utop # Example.factorial 10 ;;
- : int = 3628800

utop # open Example ;;

utop # PhysicalConstants.g ;;
- : float = 9.81

utop # PhysicalConstants.gravity ;;
- : float = 6.67384e-11
</pre>

<p>
Compile to Library
</p>

<pre class="example">
$ ocamlc -c example.ml
$ ocamlc -a example.cmo -o example.cma

$ file example.cma
example.cma: OCaml library file (.cma) (Version 008)
</pre>

<p>
Loading example.cma
</p>

<pre class="example">
$ utop
utop # #load "example.cma" ;;
utop # Example.PhysicalConstants.g ;;
- : float = 9.81



$ file example.cmx
example.cmx: OCaml native object file (.cmx) (Version 011)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> Batteries Standard Library</h3>
<div class="outline-text-3" id="text-1-12">
<p>
<a href="http://ocaml-batteries-team.github.io/batteries-included/hdoc2/">Batteries Documentation Reference</a>
</p>


<p>
See also: 
</p>

<ul class="org-ul">
<li><a href="https://github.com/ocaml-batteries-team/batteries-included/wiki/Introduction-to-batEnum">Introduction to batEnum</a>
</li>
</ul>

<p>
Install
</p>

<pre class="example">
$ opam install batteries

$ utop
&gt; #require "batteries";;
&gt; open Batteries ;;
&gt;
</pre>
</div>

<div id="outline-container-sec-1-12-1" class="outline-4">
<h4 id="sec-1-12-1"><span class="section-number-4">1.12.1</span> Batteries Modules</h4>
<div class="outline-text-4" id="text-1-12-1">
</div><div id="outline-container-sec-1-12-1-1" class="outline-5">
<h5 id="sec-1-12-1-1"><span class="section-number-5">1.12.1.1</span> Batteries List</h5>
<div class="outline-text-5" id="text-1-12-1-1">
<p>
<a href="http://ocaml-batteries-team.github.io/batteries-included/hdoc2/BatList.html">Documentation</a>
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #require "batteries" ;;

#  open Batteries ;;

# #show List ;;
module List = BatList

(** Function Signatures *)
#show BatList ;;
  module BatList :
    sig
      type 'a t = 'a list
      type 'a enumerable = 'a t
      type 'a mappable = 'a t
      val is_empty : 'a list -&gt; bool
      val cons : 'a -&gt; 'a list -&gt; 'a list
      val first : 'a list -&gt; 'a
      val hd : 'a list -&gt; 'a
      val tl : 'a list -&gt; 'a list
      val last : 'a list -&gt; 'a
      val length : 'a list -&gt; int
      val at : 'a list -&gt; int -&gt; 'a
      val rev : 'a list -&gt; 'a list
      val append : 'a list -&gt; 'a list -&gt; 'a list
      val rev_append : 'a list -&gt; 'a list -&gt; 'a list
      val concat : 'a list list -&gt; 'a list
      val flatten : 'a list list -&gt; 'a list
      val singleton : 'a -&gt; 'a list
      val make : int -&gt; 'a -&gt; 'a list
      val range : int -&gt; [&lt; `Downto | `To ] -&gt; int -&gt; int list
      val init : int -&gt; (int -&gt; 'a) -&gt; 'a list
      val unfold : 'b -&gt; ('b -&gt; ('a * 'b) option) -&gt; 'a list
      val unfold_exc : (unit -&gt; 'a) -&gt; 'a list * exn
      val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit
      val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit
      val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
      val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
      val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list
      val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a
      val fold_lefti : ('a -&gt; int -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a
      val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b
      val fold_righti : (int -&gt; 'b -&gt; 'a -&gt; 'a) -&gt; 'b list -&gt; 'a -&gt; 'a
      val reduce : ('a -&gt; 'a -&gt; 'a) -&gt; 'a list -&gt; 'a
      val max : 'a list -&gt; 'a
      val min : 'a list -&gt; 'a
      val sum : int list -&gt; int
      val fsum : float list -&gt; float
      val kahan_sum : float list -&gt; float
      val min_max : ?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a * 'a
      val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit
      val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
      val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
      val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a
      val fold_right2 :
        ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c
      val mem : 'a -&gt; 'a list -&gt; bool
      val mem_cmp : ('a -&gt; 'a -&gt; int) -&gt; 'a -&gt; 'a list -&gt; bool
      val memq : 'a -&gt; 'a list -&gt; bool
      val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool
      val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool
      val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
      val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
      val subset : ('a -&gt; 'b -&gt; int) -&gt; 'a list -&gt; 'b list -&gt; bool
      val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a
      val find_exn : ('a -&gt; bool) -&gt; exn -&gt; 'a list -&gt; 'a
      val findi : (int -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; int * 'a
      val find_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b
      val rfind : ('a -&gt; bool) -&gt; 'a list -&gt; 'a
      val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val filteri : (int -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val filter_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list
      val filteri_map : (int -&gt; 'a -&gt; 'b option) -&gt; 'a list -&gt; 'b list
      val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
      val index_of : 'a -&gt; 'a list -&gt; int option
      val index_ofq : 'a -&gt; 'a list -&gt; int option
      val rindex_of : 'a -&gt; 'a list -&gt; int option
      val rindex_ofq : 'a -&gt; 'a list -&gt; int option
      val unique : ?eq:('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val unique_cmp : ?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val unique_hash :
        ?hash:('a -&gt; int) -&gt; ?eq:('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b
      val assoc_inv : 'b -&gt; ('a * 'b) list -&gt; 'a
      val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
      val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool
      val assq : 'a -&gt; ('a * 'b) list -&gt; 'b
      val assq_inv : 'b -&gt; ('a * 'b) list -&gt; 'a
      val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
      val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool
      val modify : 'a -&gt; ('b -&gt; 'b) -&gt; ('a * 'b) list -&gt; ('a * 'b) list
      val modify_def :
        'b -&gt; 'a -&gt; ('b -&gt; 'b) -&gt; ('a * 'b) list -&gt; ('a * 'b) list
      val modify_opt :
        'a -&gt; ('b option -&gt; 'b option) -&gt; ('a * 'b) list -&gt; ('a * 'b) list
      val modify_at : int -&gt; ('a -&gt; 'a) -&gt; 'a list -&gt; 'a list
      val modify_opt_at : int -&gt; ('a -&gt; 'a option) -&gt; 'a list -&gt; 'a list
      val split_at : int -&gt; 'a list -&gt; 'a list * 'a list
      val split_nth : int -&gt; 'a list -&gt; 'a list * 'a list
      val remove : 'a list -&gt; 'a -&gt; 'a list
      val remove_if : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val remove_at : int -&gt; 'a list -&gt; 'a list
      val remove_all : 'a list -&gt; 'a -&gt; 'a list
      val take : int -&gt; 'a list -&gt; 'a list
      val ntake : int -&gt; 'a list -&gt; 'a list list
      val drop : int -&gt; 'a list -&gt; 'a list
      val takedrop : int -&gt; 'a list -&gt; 'a list * 'a list
      val take_while : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val drop_while : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val span : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
      val nsplit : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list list
      val group_consecutive : ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list list
      val interleave : ?first:'a -&gt; ?last:'a -&gt; 'a -&gt; 'a list -&gt; 'a list
      val enum : 'a list -&gt; 'a BatEnum.t
      val of_enum : 'a BatEnum.t -&gt; 'a list
      val backwards : 'a list -&gt; 'a BatEnum.t
      val of_backwards : 'a BatEnum.t -&gt; 'a list
      val split : ('a * 'b) list -&gt; 'a list * 'b list
      val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list
      val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list
      val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val sort_unique : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
      val group : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list list
      val cartesian_product : 'a list -&gt; 'b list -&gt; ('a * 'b) list
      val n_cartesian_product : 'a list list -&gt; 'a list list
      val transpose : 'a list list -&gt; 'a list list
      val print :
        ?first:string -&gt;
        ?last:string -&gt;
        ?sep:string -&gt;
        ('a BatInnerIO.output -&gt; 'b -&gt; unit) -&gt;
        'a BatInnerIO.output -&gt; 'b list -&gt; unit
      val eq : 'a BatOrd.eq -&gt; 'a list BatOrd.eq
      val ord : 'a BatOrd.ord -&gt; 'a list BatOrd.ord
      val compare : 'a BatOrd.comp -&gt; 'a list BatOrd.comp
      module Eq : functor (T : BatOrd.Eq) -&gt; sig  end
      module Ord : functor (T : BatOrd.Ord) -&gt; sig  end
      module Comp : functor (T : BatOrd.Comp) -&gt; sig  end
      val nth : 'a list -&gt; int -&gt; 'a
      val takewhile : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      val dropwhile : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
      module Exceptionless : sig  end
      module Infix : sig  end
      module Labels : sig  end
      val ( @ ) : 'a list -&gt; 'a list -&gt; 'a list
    end
  # 


  (* Head, Tail and Last *)

  # List.hd [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int = 1
  # List.tl [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int list = [2; 3; 4; 5; 6; 7; 8; 9; 10]
  # 

  # List.first [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int = 1
  # List.last [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int = 10
  # 

  (* Nth Element *)

  # List.at [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 0;;
  - : int = 1
  # List.at [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 1;;
  - : int = 2
  # List.map (List.at [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]) [0; 5; 2] ;;
  - : int list = [1; 6; 3]
  # 

  (* Min and Max *)
  # List.max  [1; 2; 3; 4; 5 ;6] ;;
  - : int = 6
  # List.min  [1; 2; 3; 4; 5 ;6] ;;
  - : int = 1
  # 

  (* Remove an element *)

  #  List.remove  ['x'; 'd'; 'a'; 'i'; 'o'; 'a'] 'a' ;;
  - : char list = ['x'; 'd'; 'i'; 'o'; 'a']
  # 

  #  List.remove_all  ['x'; 'd'; 'a'; 'i'; 'o'; 'a'] 'a' ;;
  - : char list = ['x'; 'd'; 'i'; 'o']
  # 

  #  List.remove_at  0 ['x'; 'd'; 'a'; 'i'; 'o'; 'a']  ;;
  - : char list = ['d'; 'a'; 'i'; 'o'; 'a']
  # List.remove_at  2 ['x'; 'd'; 'a'; 'i'; 'o'; 'a']  ;;
  - : char list = ['x'; 'd'; 'i'; 'o'; 'a']

     (* Removes the first element that satisfies the predicate *)
  #  List.remove_if (fun x -&gt; x mod 2 = 0) [1; 2; 4; 5; 10; 11] ;;
  - : int list = [1; 4; 5; 10; 11]
  # 


  (* Sum *)

  # List.sum ;;
  - : int list -&gt; int = &lt;fun&gt;
  # 

  # List.sum  [1; 2; 3; 4; 5 ;6] ;;
  - : int = 21
  # 

  (* Sum of floats *)

  # List.fsum ;;
  - : float list -&gt; float = &lt;fun&gt;
  # 

  # List.fsum [1. ; 2.3323; 3.1415; 10.] ;;
  - : float = 16.4738
  # 


  (* Map / Iter *)
  #  List.map ;;
  - : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = &lt;fun&gt;


  #  List.map (fun x -&gt; 10 * x + 3) [1; 2; 3; 4; 5] ;;
  - : int list = [13; 23; 33; 43; 53]
  #    

  #  List.iter ;;
  - : ('a -&gt; unit) -&gt; 'a list -&gt; unit = &lt;fun&gt;
  # 

  #  List.iter (Printf.printf "= %d\n") [1; 2; 3; 4] ;;
  = 1
  = 2
  = 3
  = 4
  - : unit = ()
  # 


  (* Take and Drop *)

  # List.take 3 [1; 3; 4; 5; 6; 7] ;;
  - : int list = [1; 3; 4]
  # List.take 13 [1; 3; 4; 5; 6; 7] ;;
  - : int list = [1; 3; 4; 5; 6; 7]
  # 

  # List.drop 4 [1; 3; 4; 5; 6; 7] ;;
  - : int list = [6; 7]
  # List.drop 14 [1; 3; 4; 5; 6; 7] ;;
  - : int list = []
  # 


  (* Take While *)

  #  List.takewhile (fun x -&gt; x &lt; 5) [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int list = [1; 2; 3; 4]
  # 

  (** Drop While *)

  # List.dropwhile (fun x -&gt; x &lt; 5) [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int list = [5; 6; 7; 8; 9; 10]
  # 

  (* Partition *)

  #  List.partition (fun x -&gt; x &lt; 5) [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int list * int list = ([1; 2; 3; 4], [5; 6; 7; 8; 9; 10])
  # 

  #  List.split_nth 3 [0; 1; 2; 3; 4; 5; 6] ;;
  - : int list * int list = ([0; 1; 2], [3; 4; 5; 6])
  # List.split_nth 4 [0; 1; 2; 3; 4; 5; 6] ;;
  - : int list * int list = ([0; 1; 2; 3], [4; 5; 6])

  (* Combine/ Split Lists *)

  #  List.combine [1; 2; 3] ['a'; 'b'; 'c'] ;;
  - : (int * char) list = [(1, 'a'); (2, 'b'); (3, 'c')]
  # 
    List.combine [1; 2; 3] ['a'; 'b'; 'c'; 'd'] ;;
  Exception: Invalid_argument "combine: Different_list_size".
  # 


  #  List.split [(1, 'a'); (2, 'b'); (3, 'c')] ;;
  - : int list * char list = ([1; 2; 3], ['a'; 'b'; 'c'])
  # 


  (* Range *)

  #  List.range ;;
  - : int -&gt; [&lt; `Downto | `To ] -&gt; int -&gt; int list = &lt;fun&gt;
  # 

  #  List.range 1 `To 10 ;;
  - : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
  # 

  #  List.range 100 `Downto 90 ;;
  - : int list = [100; 99; 98; 97; 96; 95; 94; 93; 92; 91; 90]
  # 


  (* Reverse a List *)
  #  List.rev [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int list = [10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
  # 

  (* Lenght *)
  # List.length [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] ;;
  - : int = 10
  # 

  (** Wrap a Value to a list *)
  # List.singleton 10 ;;
  - : int list = [10]
  # 

  (* Append Two Lists *)
  # List.append [1; 2; 3; 4; 5 ;6] [100; 32] ;;
  - : int list = [1; 2; 3; 4; 5; 6; 100; 32]
  # 

  (* Concat Lists *)

  # List.concat [[1]; [2; 3; 4; 5]; [13]; []] ;;
  - : int list = [1; 2; 3; 4; 5; 13]
  # 

  # List.flatten [[1]; [2; 3; 4; 5]; [13]; []] ;;
  - : int list = [1; 2; 3; 4; 5; 13]
  # 


  (* Index of ELement *)

  # List.index_of ;;
  - : 'a -&gt; 'a list -&gt; int option = &lt;fun&gt;
  # 

  #  List.index_of "a" ["i"; "o"; "b"; "a"; "d" ] ;;
  - : int option = Some 3
  # List.index_of "x" ["i"; "o"; "b"; "a"; "d" ] ;;
  - : int option = None
  # 

  (* Cartesian Product *)

  #  List.cartesian_product [10; 20; 30] ['a'; 'b'; 'c'; 'd'] ;;
  - : (int * char) list =
  [(10, 'a'); (10, 'b'); (10, 'c'); (10, 'd'); (20, 'a'); (20, 'b'); (20, 'c');
   (20, 'd'); (30, 'a'); (30, 'b'); (30, 'c'); (30, 'd')]
  # 

  (** Transpose, similar to transpose a matrix *)
  #  List.transpose [[1; 2; 3; 4]; [10; 20; 30; 100]];;
  - : int list list = [[1; 10]; [2; 20]; [3; 30]; [4; 100]]
  # 

  #  List.group_consecutive ;;
  - : ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list list = &lt;fun&gt;
  #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12-1-2" class="outline-5">
<h5 id="sec-1-12-1-2"><span class="section-number-5">1.12.1.2</span> Lazy List</h5>
<div class="outline-text-5" id="text-1-12-1-2">
<p>
<a href="http://ocaml-batteries-team.github.io/batteries-included/hdoc2/BatLazyList.html">Documentation</a>
</p>

<p>
Lazy lists are similar to Haskell Lists that uses lazy evaluation.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">    #require "batteries" ;;

    # module Lz = BatLazyList ;;
    module Lz = BatLazyList
    # 

    (** List to Lazy List*)

    #  Lz.of_list ;;
    - : 'a list -&gt; 'a Lz.t = &lt;fun&gt;
    # 
    #  Lz.of_list [1; 2; 3; 4; 5] ;;
    - : int Lz.t = &lt;lazy&gt;
    # 

    # let s = Lz.of_list [1; 2; 3; 4; 5] ;;
    val s : int Lz.t = &lt;lazy&gt;
    # 


    (** Lazy list to List *)

    # Lz.to_list s ;;
    - : int list = [1; 2; 3; 4; 5]
    # 


    (* Range  *)

    # let st = Lz.range 2 15 ;;
    val st : int Lz.t = &lt;lazy&gt;
    # 

    # Lz.to_list st ;;
    - : int list = [2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15]
    # 

(* Lazy Operations *)

    (* Take *)
    # Lz.range 2 15000 |&gt; Lz.take 5 ;;
    - : int Lz.t = lazy &lt;cycle&gt;
    #   

    # Lz.range 2 15000 |&gt; Lz.take 5 |&gt; Lz.to_list ;;
    - : int list = [2; 3; 4; 5; 6]



    (** Hd - Head, Tl tail and last *)

    # Lz.range 2 15000 |&gt; Lz.hd ;;
    - : int = 2
    # 

    # Lz.range 2 15000 |&gt; Lz.tl ;;
    - : int Lz.t = &lt;lazy&gt;
    # 

    # Lz.range 2 15000 |&gt; Lz.tl |&gt; Lz.take 4 |&gt; Lz.to_list ;;
    - : int list = [3; 4; 5; 6]
    #     

    #  Lz.range 2 15000 |&gt; Lz.tl |&gt; Lz.take 4 |&gt; Lz.last ;;
    - : int = 6
    # 


    (* Take While *)

    # Lz.take_while ;;
    - : ('a -&gt; bool) -&gt; 'a Lz.t -&gt; 'a Lz.t = &lt;fun&gt;
    # 

    # Lz.range 2 15000 |&gt; Lz.take_while (fun x -&gt; x &lt; 10) ;;
    - : int Lz.t = lazy &lt;cycle&gt;
    # 
      Lz.range 2 15000 |&gt; Lz.take_while (fun x -&gt; x &lt; 10) |&gt; Lz.to_list ;;
    - : int list = [2; 3; 4; 5; 6; 7; 8; 9]
    # 


    (** Drop While *)

    Lz.of_list [2 ; 5; 9; 8; 10; 230; 100] 
    |&gt; Lz.drop_while (fun x -&gt; x &lt; 10) 
    |&gt; Lz.to_list ;;
    - : int list = [10; 230; 100]
    #     

    # [2 ; 5; 9; 8; 10; 230; 100] 
      |&gt; Lz.of_list
      |&gt; Lz.drop_while (fun x -&gt; x &lt; 10)
      |&gt; Lz.to_list ;;
    - : int list = [10; 230; 100]
    # 


    (* Map *)

    # Lz.range 2 15000 |&gt; Lz.map (fun x -&gt; 3 * x - 5) |&gt; Lz.take 10 |&gt; Lz.to_list ;;
    - : int list = [1; 4; 7; 10; 13; 16; 19; 22; 25; 28]
    # 

    (* Iter *)

    #  let z = Lz.range 2 15000 |&gt; Lz.map (fun x -&gt; 3 * x - 5) |&gt; Lz.take 10 ;;
    val z : int Lz.t = lazy &lt;cycle&gt;
    # 
      Lz.iter (fun x -&gt; Printf.printf "x = %d\n" x) z ;;
    x = 1
    x = 4
    x = 7
    x = 10
    x = 13
    x = 16
    x = 19
    x = 22
    x = 25
    x = 28
    - : unit = ()
    # 

    (* Filter *)

    #  Lz.range 2 15000 |&gt; Lz.filter (fun x -&gt; x &lt; 15) |&gt; Lz.to_list ;;
    - : int list = [2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14]
    # 

    #  Lz.range 2 15000 
      |&gt; Lz.filter (fun x -&gt; x mod 2 = 0 ) 
      |&gt; Lz.take 10 
      |&gt; Lz.to_list ;;
    - : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]
    #     

    (** checks if at least one element of the list satisfies the predicate p.  *)
    # Lz.range 2 15000 |&gt; Lz.exists (fun x -&gt; x = 10) ;;
    - : bool = true
    # 

    (** for_all p [^ a0; a1; ... ^] checks if all elements of the 
        list satisfy the predicate p. 
        That is, it returns (p a0) &amp;&amp; (p a1) &amp;&amp; ... .
    *)

    #  Lz.range 2 15000 
      |&gt; Lz.take 10 
      |&gt; Lz.for_all (fun x -&gt; x mod 2  = 0) ;;
    - : bool = false

    # let xs = Lz.range 2 15000 |&gt; Lz.take 10 |&gt; Lz.filter (fun x -&gt; x mod 2 = 0) ;;
    val xs : int Lz.t = &lt;lazy&gt;

    # Lz.to_list xs ;;
    - : int list = [2; 4; 6; 8; 10]
    # 

      xs |&gt; Lz.for_all (fun x -&gt; x mod 2  = 0) ;;
    - : bool = true
    # 


    (** Filter Map 

    Lazily eliminate some elements and transform others.
    filter_map f [^ a0; a1; ... ^] applies lazily f to each a0, a1... 
    If f ai evaluates to None, the element is not included in the result. 
    Otherwise, if f ai evaluates to Some x, element x is included 
    in the result.

    **)

    # let f x = 
        if x &gt; 10 then None else Some x 
      ;;
    val f : int -&gt; int option = &lt;fun&gt;
    #   

    #  Lz.filter_map f (Lz.of_list [-20; -10; 0; 2; 10; 20; 30; 60; 3]) ;;
    - : int Lz.t = &lt;lazy&gt;

    # Lz.filter_map f (Lz.of_list [-20; -10; 0; 2; 10; 20; 30; 60; 3]) 
    |&gt; Lz.to_list ;;
    - : int list = [-20; -10; 0; 2; 10; 3]
    # 

    (* Combine/ Zip *)

    #  Lz.combine (Lz.of_list [1; 2; 3]) (Lz.of_list ['a'; 'b'; 'c']) |&gt; Lz.to_list;;
    - : (int * char) list = [(1, 'a'); (2, 'b'); (3, 'c')]
    # 

    # Lz.of_list [(1, 'a'); (2, 'b'); (3, 'c')] |&gt; Lz.uncombine ;;
    - : int Lz.t * char Lz.t = (&lt;lazy&gt;, &lt;lazy&gt;)
    # 

    # Lz.of_list [(1, 'a'); (2, 'b'); (3, 'c')] |&gt; Lz.uncombine 
      |&gt; fun (a, b) -&gt; (Lz.to_list a, Lz.to_list b) ;;
    - : int list * char list = ([1; 2; 3], ['a'; 'b'; 'c'])
    # 


(** Cons and Nils / Creating Lazy Lists *)

    #  let empty_lazy_list = let open Lz in Lazy.from_val Nil ;;
    val empty_lazy_list : 'a Lz.node_t Lazy.t = lazy Lz.Nil
    # 

    # Lz.to_list empty_lazy_list ;;
    - : 'a list = []
    # 

    # let open Lz in  lazy (Cons (2, lazy Nil)) ;;
    - : int Lz.node_t lazy_t = &lt;lazy&gt;
    # 


    #  let open Lz in  lazy (Cons (2, lazy Nil)) |&gt; to_list ;;
    - : int list = [2]
    # 


    # Lz.to_list xs ;;
    - : int list = [2]
    # 

    #  let xs2 = let open Lz in Lazy.from_val 
        (Cons (2, Lazy.from_val (Cons (3, Lazy.from_val (Cons (5, Lazy.from_val Nil))))))  ;;
    val xs2 : int Lz.node_t Lazy.t = lazy &lt;cycle&gt;
    # 

    #  Lz.to_list xs2 ;;
    - : int list = [2; 3; 5]
    #


    (** Generating Infinite Lists *)

    #  let rec ones () =
          let open Lz in 
          lazy (Cons (1,  ones ()))
      ;;
    val ones : unit -&gt; int Lz.t = &lt;fun&gt;
    # 

    #  ones () ;;
    - : int Lz.t = &lt;lazy&gt;
    #     

    #  ones () |&gt; Lz.take 5 |&gt; Lz.to_list ;;
    - : int list = [1; 1; 1; 1; 1]

    # ones () |&gt; Lz.take 10 |&gt; Lz.to_list ;;
    - : int list = [1; 1; 1; 1; 1; 1; 1; 1; 1; 1]
    # 


    #  let rec naturals n () =
          let open Lz in 
          lazy (Cons (n, (naturals  (n+1) ()) ))
      ;;    

    #  naturals 0 () |&gt; Lz.take 10 |&gt; Lz.to_list ;;
    - : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]

    #  naturals 0 () |&gt; Lz.take 6 |&gt; Lz.to_list ;;
    - : int list = [0; 1; 2; 3; 4; 5]
    #
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-1-12-1-3" class="outline-5">
<h5 id="sec-1-12-1-3"><span class="section-number-5">1.12.1.3</span> Bat Enum</h5>
<div class="outline-text-5" id="text-1-12-1-3">
<p>
<a href="http://ocaml-batteries-team.github.io/batteries-included/hdoc2/BatEnum.html">Documentation</a>
</p>


<p>
Enumeration over abstract collection of elements. Enumerations are a representation of finite or infinite sequences of elements. In Batteries Included, enumerations are used pervasively, both as a uniform manner of reading and manipulating the contents of a data structure, or as a simple manner of reading or writing sequences of characters, numbers, strings, etc. from/to files, network connections or other inputs/outputs.
</p>

<p>
Note Enumerations are not thread-safe. You should not attempt to access one enumeration from different threads.
Author(s): Nicolas Cannasse, David Rajchenbach-Teller
</p>


<div class="org-src-container">

<pre class="src src-ocaml">    #require "batteries" ;;
    module Enum = BatEnum ;;
    # 

    (** List to Enum *)

    # List.enum [1; 2; 30; 40; 50; 60] ;;
    - : int BatEnum.t = &lt;abstr&gt;

    #  let en = List.enum [1; 2; 30; 40; 50; 60] ;;
    val en : int BatEnum.t = &lt;abstr&gt;
    # 

    (** Enum to List *)

    #  List.of_enum en ;;
    - : int list = [1; 2; 30; 40; 50; 60]
    # 


    (** 
        init n f creates a new enumeration over elements 
        f 0, f 1, ..., f (n-1)
    *)
      Enum.init 10 (fun x -&gt; 5 * x - 4 );;
    - : int Enum.t = &lt;abstr&gt;

    # Enum.init 10 (fun x -&gt; 5 * x - 4 ) |&gt; List.of_enum ;;
    - : int list = [-4; 1; 6; 11; 16; 21; 26; 31; 36; 41]
    # 

    (** repeat ~times:n x 
        creates a enum sequence filled with n times 
        of x. It return infinite enum when ~times is absent. 
        It returns empty enum when times &lt;= 0
    *)

    #  Enum.repeat ;;
    - : ?times:int -&gt; 'a -&gt; 'a Enum.t = &lt;fun&gt;
    # 

    #  Enum.repeat 10 |&gt; Enum.take 10 ;;
    - : int Enum.t = &lt;abstr&gt;
    # 

    # Enum.repeat 10 |&gt; Enum.take 10 |&gt; List.of_enum ;;
    - : int list = [10; 10; 10; 10; 10; 10; 10; 10; 10; 10]
    # 

    (** Count the number of elements in the enum *)

    #  Enum.repeat 10 |&gt; Enum.take 10 |&gt; Enum.count ;;
    - : int = 10
    # 


    (** val seq : 'a -&gt; ('a -&gt; 'a) -&gt; ('a -&gt; bool) -&gt; 'a t
        seq init step cond 

        creates a sequence of data, which starts 
        from init, extends by step, until the condition cond fails. 
        E.g. seq 1 ((+) 1) ((&gt;) 100) returns 1, 2, ... 99. 
        If cond init is false, the result is empty.
    *)

    # Enum.seq ;;
    - : 'a -&gt; ('a -&gt; 'a) -&gt; ('a -&gt; bool) -&gt; 'a Enum.t = &lt;fun&gt;
    # 

    #  let en = Enum.seq 2.3 (fun x -&gt; 10.0 *. x ) (fun x -&gt; x &lt; 100.) ;;
    val en : float Enum.t = &lt;abstr&gt;

    #  List.of_enum en ;;
    - : float list = [2.3; 23.]

    # let en = Enum.seq 2.3 (fun x -&gt; 10.0 *. x ) (fun x -&gt; true) 
    |&gt; Enum.take 10 
    |&gt; List.of_enum ;;
    val en : float list =
      [2.3; 23.; 230.; 2300.; 23000.; 230000.; 2300000.; 
      23000000.; 230000000.; 2300000000.]


    (* Cycle *)

    #  Enum.cycle (List.enum ['a'; 'b'; 'c']) |&gt; Enum.take 3 |&gt;  List.of_enum ;;
    - : char list = ['a'; 'b'; 'c']
    # Enum.cycle (List.enum ['a'; 'b'; 'c']) |&gt; Enum.take 5 |&gt;  List.of_enum ;;
    - : char list = ['a'; 'b'; 'c'; 'a'; 'b']
    # Enum.cycle (List.enum ['a'; 'b'; 'c']) |&gt; Enum.take 7 |&gt;  List.of_enum ;;
    - : char list = ['a'; 'b'; 'c'; 'a'; 'b'; 'c'; 'a']
    # 

    (* Combine *)

    #  Enum.combine ;;
    - : 'a Enum.t * 'b Enum.t -&gt; ('a * 'b) Enum.t = &lt;fun&gt;
    # 

    #  Enum.combine ((List.enum ['a'; 'b'; 'c']), (List.enum [10; 20; 30; 40; 50])) 
    |&gt; List.of_enum ;;
    - : (char * int) list = [('a', 10); ('b', 20); ('c', 30)]
    # 

    #  Enum.uncombine ;;
    - : ('a * 'b) Enum.t -&gt; 'a Enum.t * 'b Enum.t = &lt;fun&gt;
    # 

    # List.enum [('a', 10); ('b', 20); ('c', 30)] 
    |&gt; Enum.uncombine ;;
    - : char Enum.t * int Enum.t = (&lt;abstr&gt;, &lt;abstr&gt;)
    # 


    # List.enum [('a', 10); ('b', 20); ('c', 30)] |&gt; Enum.uncombine 
      |&gt; fun (a, b) -&gt; (List.of_enum a, List.of_enum b) ;;
    - : char list * int list = (['a'; 'b'; 'c'], [10; 20; 30])
    # 


    (** From While 

        val from_while : (unit -&gt; 'a option) -&gt; 'a t

        from_while next creates an enumeration from the next function. 
        next shall return Some x where x is the next element of the 
        enumeration or None when no more elements can be enumerated. 
        Since the enumeration definition is incomplete, a call to clone 
        or count will result in a call to force that will enumerate all 
        elements in order to return a correct value.        
    **)

    #  Enum.from_while ;;
    - : (unit -&gt; 'a option) -&gt; 'a Enum.t = &lt;fun&gt;
    # 

    let generator start step stop =
      let x = ref start in
      fun () -&gt;
        x := !x + step ;
        if !x &lt; stop
        then  Some (!x)
        else  None
      ;;        
    val generator : int -&gt; int -&gt; int -&gt; unit -&gt; int option = &lt;fun&gt;
    #       

    # let g = generator 2 3 20  ;;
    val g : unit -&gt; int option = &lt;fun&gt;
    # 
      g () ;;
    - : int option = Some 5
    # g () ;;
    - : int option = Some 8
    # g () ;;
    - : int option = Some 11
    # g () ;;
    - : int option = Some 14
    # g () ;;
    - : int option = Some 17
    # g () ;;
    - : int option = None
    # g () ;;
    - : int option = None
    # 

    # Enum.from_while (generator 2 3 20) |&gt; List.of_enum ;;
    - : int list = [5; 8; 11; 14; 17]
    # 

    # let read_line_gen chin () = 
          try Some ( input_line chin)
              with End_of_file -&gt; None ;;
    val read_line_gen : in_channel -&gt; unit -&gt; string option = &lt;fun&gt;
    # 

    #  let g = read_line_gen (open_in "/etc/fstab") ;;
    val g : unit -&gt; string option = &lt;fun&gt;
    # 

    # let g = read_line_gen (open_in "/tmp/data.txt") ;;
    val g : unit -&gt; string option = &lt;fun&gt;
    # 

    # Enum.from_while g |&gt; List.of_enum  ;;
    - : string list =
    ["character \\n as a line break, instead of recognizing 
    all line break characters from the Unicode standard. Whether they 
    match or don't match (at) line breaks depends on (?s) and (?m).";
     "(?b) makes Tcl interpret the regex as a POSIX BRE.";
     "(?e) makes Tcl interpret the regex as a POSIX ERE."]
    # 

    (** 
    val unfold : 'b -&gt; ('b -&gt; ('a * 'b) option) -&gt; 'a t

    unfold : state -&gt; (state -&gt; (output, state) option) -&gt; output enum 
               |       ------------------------         |
               |                |                       |
               |                |--- State Function     Output 
               |                                        of every state
               |
               |----&gt; Start state


    As from_loop, except uses option type to signal the end of 
    the enumeration. The enumeration ends whenever the function 
    returns None

    State Function:          
          state -&gt; (output, state) option

        &gt; (output, new_sate) option = state_function current_state

    ---------------------------------------------------------------
    *)


    #  let state_iterator a = Some (2 * a, a + 1) ;;
    val state_iterator : int -&gt; (int * int) option = &lt;fun&gt;

    (*
        state_iterator a = Some (2 * a, a + 1)
        state_iterator 3 = (Some (2 * a, a + 1)) 3 = Some (6, 4)
                                                              |
                                                           Next State

        state_iterator 4 = (Some (2 * a, a + 1)) 4 = Some (8, 5)

        state_iterator 5 = (Some (2 * a, a + 1)) 5 = Some (10, 6)

        state_iterator 5 = (Some (2 * a, a + 1)) 5 = Some (14, 7)

        output:  [6; 8; 10; 14; ...]
    *)
    # Enum.unfold 3 state_iterator |&gt; Enum.take 10 |&gt; List.of_enum ;;
    - : int list = [6; 8; 10; 12; 14; 16; 18; 20; 22; 24]
    # 

    #  let state_iter x = 
          if x &lt; 30 then Some (x * 3, x + 3) else None ;;
    val state_iter : int -&gt; (int * int) option = &lt;fun&gt;
    #     

    # Enum.unfold 3 state_iter |&gt; List.of_enum ;;
    - : int list = [9; 18; 27; 36; 45; 54; 63; 72; 81]
    # 

    #  Enum.while_do;;
    - : ('a -&gt; bool) -&gt; ('a Enum.t -&gt; 'a Enum.t) -&gt; 'a Enum.t -&gt; 'a Enum.t = &lt;fun&gt;
    # 

  # Enum.while_do 
    (fun x -&gt; x &lt; 10) 
    (Enum.map (fun x -&gt; 3 * x + 2)) 
    (List.enum [1; 2; 4; 7; 9; 10; 20; 30]) 
    |&gt; List.of_enum;;
    - : int list = [5; 8; 14; 23; 29; 10; 20; 30]

    # 
      Enum.while_do (fun x -&gt; x &lt; 20) 
      (Enum.map (fun x -&gt; 3 * x + 2)) 
      (List.enum [1; 2; 4; 7; 9; 10; 20; 30]) 
      |&gt; List.of_enum;;
    - : int list = [5; 8; 14; 23; 29; 32; 20; 30]
    # 


(** Infix Operators *)

      #show Enum.Infix ;;
    module Infix :
      sig
        val ( -- ) : int -&gt; int -&gt; int Enum.t
        val ( --^ ) : int -&gt; int -&gt; int Enum.t
        val ( --. ) : float * float -&gt; float -&gt; float Enum.t
        val ( --- ) : int -&gt; int -&gt; int Enum.t
        val ( --~ ) : char -&gt; char -&gt; char Enum.t
        val ( // ) : 'a Enum.t -&gt; ('a -&gt; bool) -&gt; 'a Enum.t
        val ( /@ ) : 'a Enum.t -&gt; ('a -&gt; 'b) -&gt; 'b Enum.t
        val ( @/ ) : ('a -&gt; 'b) -&gt; 'a Enum.t -&gt; 'b Enum.t
        val ( //@ ) : 'a Enum.t -&gt; ('a -&gt; 'b option) -&gt; 'b Enum.t
        val ( @// ) : ('a -&gt; 'b option) -&gt; 'a Enum.t -&gt; 'b Enum.t
      end
    # 

    (** Range Operator *)
    #  4 -- 10 ;;
    - : int Enum.t = &lt;abstr&gt;
    # 
    #  4 -- 10 |&gt; List.of_enum ;;
    - : int list = [4; 5; 6; 7; 8; 9; 10]
    # 

    (** Range Operator without the end *)
    #  4 --^ 10  ;;
    - : int Enum.t = &lt;abstr&gt;
    # 

    #  4 --^ 10 |&gt; List.of_enum ;;
    - : int list = [4; 5; 6; 7; 8; 9]
    #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12-1-4" class="outline-5">
<h5 id="sec-1-12-1-4"><span class="section-number-5">1.12.1.4</span> String</h5>
<div class="outline-text-5" id="text-1-12-1-4">
<p>
<a href="http://ocaml-batteries-team.github.io/batteries-included/hdoc2/BatString.html">Documentation</a>
</p>

<div class="org-src-container">

<pre class="src src-ocaml"># #require "batteries" ;;


#  module String = BatString ;;
module String = BatString
# 


    #show BatString ;;
module BatString :
  sig
    val init : int -&gt; (int -&gt; char) -&gt; string
    val is_empty : string -&gt; bool
    external length : string -&gt; int = "%string_length"
    external get : string -&gt; int -&gt; char = "%string_safe_get"
    external set : string -&gt; int -&gt; char -&gt; unit = "%string_safe_set"
    external create : int -&gt; string = "caml_create_string"
    val make : int -&gt; char -&gt; string
    val copy : string -&gt; string
    val sub : string -&gt; int -&gt; int -&gt; string
    val fill : string -&gt; int -&gt; int -&gt; char -&gt; unit
    val blit : string -&gt; int -&gt; string -&gt; int -&gt; int -&gt; unit
    val concat : string -&gt; string list -&gt; string
    val iter : (char -&gt; unit) -&gt; string -&gt; unit
    val mapi : (int -&gt; char -&gt; char) -&gt; string -&gt; string
    val escaped : string -&gt; string
    val index : string -&gt; char -&gt; int
    val rindex : string -&gt; char -&gt; int
    val index_from : string -&gt; int -&gt; char -&gt; int
    val rindex_from : string -&gt; int -&gt; char -&gt; int
    val contains : string -&gt; char -&gt; bool
    val contains_from : string -&gt; int -&gt; char -&gt; bool
    val rcontains_from : string -&gt; int -&gt; char -&gt; bool
    val uppercase : string -&gt; string
    val lowercase : string -&gt; string
    val capitalize : string -&gt; string
    val uncapitalize : string -&gt; string
    type t = string
    val enum : string -&gt; char BatEnum.t
    val of_enum : char BatEnum.t -&gt; string
    val backwards : string -&gt; char BatEnum.t
    val of_backwards : char BatEnum.t -&gt; string
    val of_list : char list -&gt; string
    val to_list : string -&gt; char list
    val of_int : int -&gt; string
    val of_float : float -&gt; string
    val of_char : char -&gt; string
    val to_int : string -&gt; int
    val to_float : string -&gt; float
    val map : (char -&gt; char) -&gt; string -&gt; string
    val fold_left : ('a -&gt; char -&gt; 'a) -&gt; 'a -&gt; string -&gt; 'a
    val fold_lefti : ('a -&gt; int -&gt; char -&gt; 'a) -&gt; 'a -&gt; string -&gt; 'a
    val fold_right : (char -&gt; 'a -&gt; 'a) -&gt; string -&gt; 'a -&gt; 'a
    val fold_righti : (int -&gt; char -&gt; 'a -&gt; 'a) -&gt; string -&gt; 'a -&gt; 'a
    val filter : (char -&gt; bool) -&gt; string -&gt; string
    val filter_map : (char -&gt; char option) -&gt; string -&gt; string
    val iteri : (int -&gt; char -&gt; unit) -&gt; string -&gt; unit
    val find : string -&gt; string -&gt; int
    val find_from : string -&gt; int -&gt; string -&gt; int
    val rfind : string -&gt; string -&gt; int
    val rfind_from : string -&gt; int -&gt; string -&gt; int
    val find_all : string -&gt; string -&gt; int BatEnum.t
    val ends_with : string -&gt; string -&gt; bool
    val starts_with : string -&gt; string -&gt; bool
    val exists : string -&gt; string -&gt; bool
    val lchop : ?n:int -&gt; string -&gt; string
    val rchop : ?n:int -&gt; string -&gt; string
    val trim : string -&gt; string
    val quote : string -&gt; string
    val left : string -&gt; int -&gt; string
    val right : string -&gt; int -&gt; string
    val head : string -&gt; int -&gt; string
    val tail : string -&gt; int -&gt; string
    val strip : ?chars:string -&gt; string -&gt; string
    val replace_chars : (char -&gt; string) -&gt; string -&gt; string
    val replace : str:string -&gt; sub:string -&gt; by:string -&gt; bool * string
    val nreplace : str:string -&gt; sub:string -&gt; by:string -&gt; string
    val repeat : string -&gt; int -&gt; string
    val rev : string -&gt; string
    val rev_in_place : string -&gt; unit
    val in_place_mirror : string -&gt; unit
    val split : string -&gt; by:string -&gt; string * string
    val rsplit : string -&gt; by:string -&gt; string * string
    val nsplit : string -&gt; by:string -&gt; string list
    val join : string -&gt; string list -&gt; string
    val slice : ?first:int -&gt; ?last:int -&gt; string -&gt; string
    val splice : string -&gt; int -&gt; int -&gt; string -&gt; string
    val explode : string -&gt; char list
    val implode : char list -&gt; string
    val equal : t -&gt; t -&gt; bool
    val ord : t -&gt; t -&gt; BatOrd.order
    val compare : t -&gt; t -&gt; int
    val icompare : t -&gt; t -&gt; int
    module IString : sig  end
    val numeric_compare : t -&gt; t -&gt; int
    module NumString : sig  end
    val edit_distance : t -&gt; t -&gt; int
    val print : 'a BatInnerIO.output -&gt; string -&gt; unit
    val println : 'a BatInnerIO.output -&gt; string -&gt; unit
    val print_quoted : 'a BatInnerIO.output -&gt; string -&gt; unit
    module Exceptionless : sig  end
    module Cap : sig  end
    external unsafe_get : string -&gt; int -&gt; char = "%string_unsafe_get"
    external unsafe_set : string -&gt; int -&gt; char -&gt; unit
      = "%string_unsafe_set"
    external unsafe_blit : string -&gt; int -&gt; string -&gt; int -&gt; int -&gt; unit
      = "caml_blit_string" "noalloc"
    external unsafe_fill : string -&gt; int -&gt; int -&gt; char -&gt; unit
      = "caml_fill_string" "noalloc"
  end
# 

(** Strip and Chop *)

#  String.rchop ~n:3 "hello world ocaml ml F#" ;;
- : string = "hello world ocaml ml"
#
# String.rchop ~n:13 "hello world ocaml ml F#" ;;
- : string = "hello worl"
#

# String.lchop ~n:3 "hello world ocaml ml F#" ;;
- : string = "lo world ocaml ml F#"
# 
# String.lchop ~n:13 "hello world ocaml ml F#" ;;
- : string = "caml ml F#"    


# String.right "hello world ocaml ml F#" 0 ;;
- : string = ""
# String.right "hello world ocaml ml F#" 1 ;;
- : string = "#"
# String.right "hello world ocaml ml F#" 5 ;;
- : string = "ml F#"
# String.right "hello world ocaml ml F#" 10 ;;
- : string = "caml ml F#"
#       

# String.left "hello world ocaml ml F#" 0 ;;
- : string = ""
# String.left "hello world ocaml ml F#" 1 ;;
- : string = "h"
# String.left "hello world ocaml ml F#" 10 ;;
- : string = "hello worl"
#       

#  String.trim "    helllo world     " ;;
- : string = "helllo world"
# 

# String.strip ~chars:".-?; "  " .-....helllo world   ...;;;???  " ;;
- : string = "helllo world"
# 


(** Join, Concat, Repeat *)
(******************************)          

#  String.join ", " ["Mexico" ; "Honduras"; "Guatemala"; "Colombia"] ;;
- : string = "Mexico, Honduras, Guatemala, Colombia"
# 

#  String.concat ", " ["Mexico" ; "Honduras"; "Guatemala"; "Colombia"] ;;
- : string = "Mexico, Honduras, Guatemala, Colombia"
# 

# String.repeat "foobar" 4 ;;
- : string = "foobarfoobarfoobarfoobar"
# 

# String.repeat "foobar" 4 |&gt; String.rev ;;
- : string = "raboofraboofraboofraboof"
# 


#  String.split  "hello????world???ocaml" ~by:"?" ;;
- : string * string = ("hello", "???world???ocaml")

#  String.nsplit  "hello????world???ocaml" ~by:"?" ;;
- : string list = ["hello"; ""; ""; ""; "world"; ""; ""; "ocaml"]

# 

(** String X Characters         *)
(******************************)    

# String.explode "foobar" ;;
- : char list = ['f'; 'o'; 'o'; 'b'; 'a'; 'r']
# 
  String.implode ['P'; 'o'; 'r'; 't'; 'u'; 'g'; 'a'; 'l' ] ;;
- : string = "Portugal"
#     


(** Lowercase / Uppercase  conversion *)
(************************************)        

# String.uppercase "mexico" ;;
- : string = "MEXICO"
# 

# String.lowercase "MEXICO" ;;
- : string = "mexico"
# 

#  String.capitalize "mexico" ;;
- : string = "Mexico"
# String.capitalize "MEXICO" ;;
- : string = "MEXICO"
# 

# String.uncapitalize "MEXICO" ;;
- : string = "mEXICO"
# 
  String.uncapitalize "Mexico" ;;
- : string = "mexico"
# 

(** Replace string              *)
(******************************)   

# String.nreplace ~str:"On the long highway to Mexico" ~sub:"Mexico" ~by:"Guatemala" ;; 
- : string = "On the long highway to Guatemala"
# 


(** Predicates                  *)
(******************************)


#  String.starts_with  "prefix something else" "prefix" ;;
- : bool = true
# 
  String.starts_with "prefix" "prefix something else" ;;
- : bool = false


#  String.ends_with  "something else suffix" "suffix" ;;
- : bool = true
# 

# String.ends_with  "something else suff" "suffix" ;;
- : bool = false
#   

(** Type Casting *)
(******************************)

#  String.of_char 'x' ;;
- : string = "x"
#     
# String.of_int 10023 ;;
- : string = "10023"
# 
  String.of_float 203.23 ;;
- : string = "203.23"
# 

#  String.of_list ['T'; 'e'; 'x'; 'a'; 's'] ;;
- : string = "Texas"
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12-1-5" class="outline-5">
<h5 id="sec-1-12-1-5"><span class="section-number-5">1.12.1.5</span> BatOption</h5>
<div class="outline-text-5" id="text-1-12-1-5">
<div class="org-src-container">

<pre class="src src-ocaml">&gt; #require "batteries";;
&gt; module Option = BatOption ;;
module Option = BatOption                                                         &gt; 
Option.some 100 ;;
- : int option = Some 100                                                         &gt; 

&gt; Option.map ;;
- : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option = &lt;fun&gt;                                  &gt; 

&gt; Option.map (fun x -&gt; 2 * x) (Some 20) ;;
- : int option = Some 40                                                          &gt; 

&gt; Option.map (fun x -&gt; 2 * x) None ;;
- : int option = None                                                             &gt; 

(** Similar to Maybe from Haskell Maybe monad *)

&gt; Option.bind ;;
- : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;  

&gt; List.find (fun x -&gt; x &gt; 10) [1; 2; 3; 4] ;;
Exception: Not_found.                                                             &gt; 

&gt; List.find (fun x -&gt; x &gt; 3) [1; 2; 3; 4] ;;
- : int = 4                                                                       &gt;                         

&gt; let safe_find p xs  = 
    try Some (List.find p xs)
    with Not_found -&gt; None
;;
val safe_find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = &lt;fun&gt; 


&gt; safe_find (fun x -&gt; x &gt; 3) [1; 2; 3; 4] ;;
- : int option = Some 4                                                           &gt; 

&gt; safe_find (fun x -&gt; x &gt; 30) [1; 2; 3; 4] ;;
- : int option = None                                                             &gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12-1-6" class="outline-5">
<h5 id="sec-1-12-1-6"><span class="section-number-5">1.12.1.6</span> BatRef</h5>
<div class="outline-text-5" id="text-1-12-1-6">
<p>
It provide combinators to manipulate mutable references.
</p>

<div class="org-src-container">

<pre class="src src-ocaml"> # #require "batteries" ;;
 # open Batteries ;;

 # #show BatRef ;;
 module BatRef :
   sig
     type 'a t = 'a ref
     external ref : 'a -&gt; 'a ref = "%makemutable"
     external ( ! ) : 'a ref -&gt; 'a = "%field0"
     external ( := ) : 'a ref -&gt; 'a -&gt; unit = "%setfield0"
     external set : 'a ref -&gt; 'a -&gt; unit = "%setfield0"
     external get : 'a ref -&gt; 'a = "%field0"
     val copy : 'a ref -&gt; 'a ref
     val pre : 'a ref -&gt; ('a -&gt; 'a) -&gt; 'a
     val post : 'a ref -&gt; ('a -&gt; 'a) -&gt; 'a
     val swap : 'a ref -&gt; 'a ref -&gt; unit
     val post_incr : int ref -&gt; int
     val post_decr : int ref -&gt; int
     val pre_incr : int ref -&gt; int
     val pre_decr : int ref -&gt; int
     val protect : 'a ref -&gt; 'a -&gt; (unit -&gt; 'b) -&gt; 'b
     val toggle : bool ref -&gt; unit
     val oset : 'a option ref -&gt; 'a -&gt; unit
     val oget_exn : 'a option ref -&gt; 'a
     val print :
       ('b BatInnerIO.output -&gt; 'a -&gt; unit) -&gt;
       'b BatInnerIO.output -&gt; 'a t -&gt; unit
     val compare : 'a BatOrd.comp -&gt; 'a ref BatOrd.comp
     val ord : 'a BatOrd.ord -&gt; 'a ref BatOrd.ord
     val eq : 'a BatOrd.eq -&gt; 'a ref BatOrd.eq
   end
 # 

 #  let x = ref 10.223 ;;
 val x : float Batteries.ref = {contents = 10.223}
 # 

 #  Ref.set x 100.23 ;;
 - : unit = ()

 # x ;;
 - : float Batteries.ref = {contents = 100.23}
 # 

 # Ref.get x ;;
 - : float = 100.23
 # 

 (**************************************)

 # let a = ref 1000 ;;
 val a : int Batteries.ref = {contents = 1000}
 # let b = ref 200 ;;
 val b : int Batteries.ref = {contents = 200}
 # 
   Ref.swap a b ;;
 - : unit = ()
 # a ;;
 - : int Batteries.ref = {contents = 200}
 # b ;;
 - : int Batteries.ref = {contents = 1000}
 # 

(**************************************)    

 # let myflag = ref false ;;
 val myflag : bool Batteries.ref = {contents = false}
 # 
   Ref.toggle myflag ;;
 - : unit = ()

 # myflag ;;
 - : bool Batteries.ref = {contents = true}
 # 

 # Ref.toggle myflag ;;
 - : unit = ()
 # myflag ;;
 - : bool Batteries.ref = {contents = false}
 # 


 (***************************************)

 # let x = ref  100 ;;
 val x : int Batteries.ref = {contents = 100}
 # 

 # Ref.pre ;;
 - : 'a ref -&gt; ('a -&gt; 'a) -&gt; 'a = &lt;fun&gt;
 # 

 #  Ref.pre x (fun x -&gt; x + 30)  ;;
 - : int = 130

 # x ;;
 - : int Batteries.ref = {contents = 130}
 # 


 (***************************************)

 #  let x = ref 100 ;;
 val x : int Batteries.ref = {contents = 100}
 # 
   Ref.post x (fun x -&gt; x + 30) ;;
 - : int = 100
 # x ;;
 - : int Batteries.ref = {contents = 130}
 # 

 (***************************************)

 # let idx = ref 0 ;;
 val idx : int Batteries.ref = {contents = 0}
 # 

 #  Ref.post_incr idx ;;
 - : int = 0

 # idx ;;
 - : int Batteries.ref = {contents = 1}
 # 

 (***************************************)

 # let idx = ref 0 ;;
 val idx : int Batteries.ref = {contents = 0}
 # 

 #  Ref.pre_incr idx ;;
 - : int = 1
 # !idx ;;
 - : int = 1
 # Ref.pre_incr idx ;;
 - : int = 2
 # !idx ;;
 - : int = 2
 # Ref.pre_incr idx ;;
 - : int = 3
 # !idx ;;
 - : int = 3
 #
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-12-1-7" class="outline-5">
<h5 id="sec-1-12-1-7"><span class="section-number-5">1.12.1.7</span> BatFiles</h5>
<div class="outline-text-5" id="text-1-12-1-7">
<p>
The module BatFile defines combinators for file manipulation.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(** Documentation: line_of name reads the contents of file name as 
an enumeration of lines. The file is automatically closed once the 
last line has been reached or the enumeration is garbage-collected.
*)
#  BatFile.lines_of ;;
- : string -&gt; string BatEnum.t = &lt;fun&gt;
# 

# BatFile.lines_of "/etc/protocols" ;;
- : string BatEnum.t = &lt;abstr&gt;
# 

#  let lines_enum = BatFile.lines_of "/etc/protocols" ;;
val lines_enum : string BatEnum.t = &lt;abstr&gt;
# 


# lines_enum |&gt; BatEnum.take 5 
  |&gt; BatList.of_enum 
  ;;
- : string list =
["# Internet (IP) protocols"; "#";
 "# Updated from http://www.iana.org/assignments/protocol-numbers and other";
 "# sources.";
 "# New protocols will be added on request if they have been officially"]
# 

# lines_enum |&gt; BatEnum.take 5 |&gt; BatList.of_enum ;;
- : string list =
["icmp\t1\tICMP\t\t# internet control message protocol";
 "igmp\t2\tIGMP\t\t# Internet Group Management";
 "ggp\t3\tGGP\t\t# gateway-gateway protocol";
 "ipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP'')";
 "st\t5\tST\t\t# ST datagram mode"]
# 

# lines_enum |&gt; BatEnum.take 4 |&gt; BatEnum.iter print_endline ;;
tcp 6   TCP     # transmission control protocol
egp 8   EGP     # exterior gateway protocol
igp 9   IGP     # any private interior gateway (Cisco)
pup 12  PUP     # PARC universal packet protocol
- : unit = ()
# 


(** size_of name returns the size of file name in bytes. *)
#  BatFile.size_of "/etc/magic" ;;
- : int = 111
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> Miscellaneous</h3>
<div class="outline-text-3" id="text-1-13">
</div><div id="outline-container-sec-1-13-1" class="outline-4">
<h4 id="sec-1-13-1"><span class="section-number-4">1.13.1</span> Changing Toploop Prompt</h4>
<div class="outline-text-4" id="text-1-13-1">
<p>
It is possible to change the Toploop default prompt # to &gt; for example:
</p>

<p>
From: <a href="http://stackoverflow.com/questions/6158596/setting-the-prompt-in-an-ocaml-custom-toplevel">Setting the prompt in an OCaml custom toplevel</a>
</p>

<pre class="example">
# Toploop.read_interactive_input := 
        let old = !Toploop.read_interactive_input 
          in fun prompt buffer len -&gt; old "&gt; " buffer len ;;
- : unit = ()
&gt; 
&gt; 
&gt; 
&gt; let f x = 10.23 *. x ;;
val f : float -&gt; float = &lt;fun&gt;
&gt;
</pre>
</div>
</div>

<div id="outline-container-sec-1-13-2" class="outline-4">
<h4 id="sec-1-13-2"><span class="section-number-4">1.13.2</span> Adding Directives to Toploop Shell</h4>
<div class="outline-text-4" id="text-1-13-2">
<p>
The toploop, interpreter directives can be defined by the user to create customized commands. The code below can be put in thhe Ocaml startup file: ~/.ocamlinit.
</p>

<div class="org-src-container">

<pre class="src src-ocaml">    (** [use_file mlfile]

        Equivalent to the directive:  

        # #use "myfile.ml"  ;;

        or

        # use_file "myfile.ml" ;;

        It can programatically load a file.

    *)
    #let use_file mlfile =
        Topdirs.dir_use Format.std_formatter  mlfile
    ;;
    val use_file : string -&gt; unit = &lt;fun&gt;


    (** [use_module mlfile]

        Equivalent to directive 

        # #mod_use "afile.ml" ;;

        # use_module "afile.ml" ;; 

        Load the file as module, it will load the file as a module named,
        Afile
     *)                  
    # let use_module mlfile =
            Toploop.mod_use_file Format.std_formatter mlfile ;;
    val use_module : string -&gt; bool = &lt;fun&gt;    

    (**  Example, let the file dummy.ml have the content:


        let f x = 10 * x 

        let add_functions f1 f2 x =
            (f1 x) + (f2 x) 


        let listdir path = 
            path
            |&gt; Sys.readdir
            |&gt; Array.to_list        
    *)

    # use_file "dummy.ml" ;;
    val f : int -&gt; int = &lt;fun&gt;
    val add_functions : ('a -&gt; int) -&gt; ('a -&gt; int) -&gt; 'a -&gt; int = &lt;fun&gt;
    val listdir : string -&gt; string list = &lt;fun&gt;
    - : unit = ()

    # f 3 ;;
    - : int = 30

    # let g = add_functions (fun x -&gt; x * 3) (fun x -&gt; x + 5) ;;
    val g : int -&gt; int = &lt;fun&gt;

    # List.map g [1; 3; 5 ] ;;
    - : int list = [9; 17; 25]
    # 


    #  use_module "dummy.ml" ;;
    module Dummy :
      sig
        val f : int -&gt; int
        val add_functions : ('a -&gt; int) -&gt; ('a -&gt; int) -&gt; 'a -&gt; int
        val listdir : string -&gt; string list
      end
    - : bool = true
    #     

    # Dummy.f 3 ;;
    - : int = 30

    # let f = Dummy.add_functions (fun x -&gt; x * 3) (fun x -&gt; x + 5) ;;
    val f : int -&gt; int = &lt;fun&gt;

    # List.map f [1; 3; 5 ] ;;
    - : int list = [9; 17; 25]
    # 


    (*******************************************************)

    (** Execute System Commands  *)
    # let run_cmd cmd =
        let _ = Sys.command cmd in ()
      ;;
    val run_cmd : string -&gt; unit = &lt;fun&gt;
    #

    #  run_cmd "uname -r" ;;
    3.19.0-21-generic
    - : unit = ()
    # 

    (** Add directive that doesn't require argument, like
        #pwd ;;
        #version ;;
    *)   
    # let add_directive_none command_name func =
      Hashtbl.add
        Toploop.directive_table
        command_name
          (Toploop.Directive_none func)  ;;
    val add_directive_none : string -&gt; (unit -&gt; unit) -&gt; unit = &lt;fun&gt;



    (** Add directive that requires a string argument, like

      #cat "string_utils.ml" ;;
      #use "something.ml" ;;

    *) 
    # let add_directive_str command_name func = 
          Hashtbl.add
            Toploop.directive_table
            command_name
              (Toploop.Directive_string  func) ;;  
    val add_directive_str : string -&gt; (string -&gt; unit) -&gt; unit = &lt;fun&gt;


    (** Show Current Directories *) 
    add_directive_none "pwd"
          (fun () -&gt; print_endline  (Sys.getcwd ()) );;
    - : unit = ()

    # #pwd ;;
    /home/tux
    # 


    (** List all files in current directory *)
    # add_directive_none "ls"
          (fun () -&gt; Sys.readdir "." |&gt; Array.iter print_endline );;
    - : unit = ()
    # 

    # #ls ;;
    connect.sh~
    .utop-history
    .davfs2
    .emacs.d
    hsk.hs~
    .atftp_history
    ...

    (** Execute Shell Command *)

    # add_directive_str  "sh"
       (fun command -&gt; run_cmd command  ) ;;
    - : unit = ()

    #sh "pwd" ;;
    /home/tux

    # #sh "cat /etc/protocols" ;;
    # Internet (IP) protocols
    #
    # Updated from http://www.iana.org/assignments/protocol-numbers and other
    # sources.
    # New protocols will be added on request if they have been officially
    # assigned by IANA and are not historical.    
    ...

    (** Open Current Directory in File Manager

        It uses the pcmanfm file manager in Linux, but it can be customized
        to run any file manager.
    *)
    add_directive_none "open_dir"
         (fun () -&gt; run_cmd "pcmanfm") ;;
    - : unit = ()

    # #open_dir ;;


    (** 
       &gt;&gt; Summary run the code in the clipboard.

       Write the content of clipboard to the file /tmp/tmp.ml and execute
       it. It uses the Linux app xclip to get content of clipboard.

       The advantage of this directive is that the user doesn't need to
       paste the code manually clicking.

       It only needs a simple paste: #paste ;; to run the code 
       from clipboard.    

    *)

    # add_directive_none "paste"
        (fun () -&gt;
          run_cmd "xclip -o -clipboard &gt; /tmp/tmp.ml" ;
          use_file "/tmp/tmp.ml"         
          ) ;;
- : unit = ()

    # #paste ;;
    val f : int -&gt; int = &lt;fun&gt;
    val add_functions : ('a -&gt; int) -&gt; ('a -&gt; int) -&gt; 'a -&gt; int = &lt;fun&gt;
    val listdir : string -&gt; string list = &lt;fun&gt;
    # 


    (** Load the file _local.ml in current directory 
        that can install pretty printers, load projects files ...

        It can be executed with the command: #local ;;
    *)

    # add_directive_none "local"
      (fun () -&gt; use_file "_local.ml" );;
    - : unit = ()
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-3" class="outline-4">
<h4 id="sec-1-13-3"><span class="section-number-4">1.13.3</span> Shell Script in Ocaml</h4>
<div class="outline-text-4" id="text-1-13-3">
<p>
Ocaml can be a great script language with a high level composability, modularity and composability thanks to first class functions, currying (partial application of a function), higher order functions and the module system. Ocaml scripts can be executed in batch mode, be compiled to bytecode or machine code and also cross compiled.   
</p>

<p>
Script Template:
</p>

<p>
File: <i>script.ml</i>
</p>

<div class="org-src-container">

<pre class="src src-ocaml"> #!/usr/bin/env ocaml 
(**

    Note that: there is no main function, entry point in Ocaml lang, 
    a function can run at any point of a program.
*)

 #load "unix.cma" ;;
 #load "str.cma" ;;

let main () =        
    if (Array.length Sys.argv) = 1 
    then print_endline "No arguments given"
    else (
        print_endline ("The argument is : " ^ Sys.argv.(1)) ;
        print_endline ("All parameter : " ^ String.concat " " (Array.to_list Sys.argv))
    )


let () =
    if not !Sys.interactive 
    then main ()   (** If it is being run in batch mode, run main *)
    else ()        (** If ocaml is being run in interactive mode, It doesn't run main *)
</pre>
</div>

<p>
Running the script:
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ocaml script.ml 
No arguments given

$ ocaml script.ml run
The argument is : run
All parameter : script.ml run

$ ocaml script.ml run make install
The argument is : run
All parameter : script.ml run make install

 ## Or

$ chmod +x script.ml 

$ ./script.ml run
The argument is : run
All parameter : ./script.ml run

$ ./script.ml make
The argument is : make
All parameter : ./script.ml make
</pre>
</div>

<p>
Loading the Script in the Toplevel for debugging, testing and interactively development:
</p>

<pre class="example">
$ rlwrap ocaml
        OCaml version 4.02.1

# #use "script.ml" ;;
val main : unit -&gt; unit = &lt;fun&gt;

# main () ;;
No arguments given
- : unit = ()
# 

#  Sys.argv ;;
- : string array = [|"/home/tux/.opam/4.02.1/bin/ocaml"|]
#
</pre>

<p>
See also:
</p>

<ul class="org-ul">
<li><a href="https://blogs.janestreet.com/ocaml-as-a-scripting-language/">OCaml as a scripting language - by Yaron Minsky</a>
</li>

<li><a href="https://github.com/realworldocaml/scripts">Command-line utilities for Real World OCaml</a>
</li>

<li><a href="http://blog.enfranchisedmind.com/2006/05/ocaml-the-scripting-language/">Ocaml the scripting language - blog Enfranchised Mind</a>
</li>

<li><a href="https://www.youtube.com/watch?v=hXiz2_VlwMU">Video  - OCAML Tutorial 32/33: OCAML Scripting (OCAML Shell Scripts) by Dr Noureddin Sadawi</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-13-4" class="outline-4">
<h4 id="sec-1-13-4"><span class="section-number-4">1.13.4</span> Debugging</h4>
<div class="outline-text-4" id="text-1-13-4">
<p>
Ocaml has many features that makes debugging easier like:
</p>

<ul class="org-ul">
<li>Toplevel debugging: Just type the functions in the toplevel and see what they return.
</li>
<li>Print inside functions
</li>
<li>Trace function calls
</li>
</ul>

<p>
<b>Print Inside Function</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">&gt; let rec fibonacci = 
      function
      | 0 -&gt; 1
      | 1 -&gt; 1
      | n -&gt; fibonacci (n-1) + fibonacci (n-2)
    ;;
val fibonacci : int -&gt; int = &lt;fun&gt;

&gt; fibonacci 0 ;;
- : int = 1
&gt; 
  fibonacci 3 ;;
- : int = 3
&gt; fibonacci 13 ;;
- : int = 377
&gt; 

&gt; let rec fibonacci = 
      function
      | 0 -&gt; 1
      | 1 -&gt; 1
      | n -&gt; let fibn1 = fibonacci (n-1) in
             let fibn2  = fibonacci (n-2) in
             let fibn = fibn1 + fibn2 in
             let () = Printf.printf "n = %d ; fib(n - 1) = %d ; fib (n - 2) = %d ; fib n = %d \n" n fibn1 fibn2 fibn in
             fibn

  ;;
val fibonacci : int -&gt; int = &lt;fun&gt;


&gt; fibonacci 0 ;;
- : int = 1
&gt; 
  fibonacci 1 ;;
- : int = 1


&gt; fibonacci 3 ;;
n = 2 ; fib(n - 1) = 1 ; fib (n - 2) = 1 ; fib n = 2 
n = 3 ; fib(n - 1) = 2 ; fib (n - 2) = 1 ; fib n = 3 
- : int = 3
&gt;    

&gt; fibonacci 5 ;;
n = 2 ; fib(n - 1) = 1 ; fib (n - 2) = 1 ; fib n = 2 
n = 3 ; fib(n - 1) = 2 ; fib (n - 2) = 1 ; fib n = 3 
n = 2 ; fib(n - 1) = 1 ; fib (n - 2) = 1 ; fib n = 2 
n = 4 ; fib(n - 1) = 3 ; fib (n - 2) = 2 ; fib n = 5 
n = 2 ; fib(n - 1) = 1 ; fib (n - 2) = 1 ; fib n = 2 
n = 3 ; fib(n - 1) = 2 ; fib (n - 2) = 1 ; fib n = 3 
n = 5 ; fib(n - 1) = 5 ; fib (n - 2) = 3 ; fib n = 8 
- : int = 8
&gt;
</pre>
</div>

<p>
<b>Tracing function calls</b>
</p>

<div class="org-src-container">

<pre class="src src-ocaml">(* Generates the nth term of fibonnaci sequence *)
&gt; let rec fibonacci = 
      function
      | 0 -&gt; 1
      | 1 -&gt; 1
      | n -&gt; fibonacci (n-1) + fibonacci (n-2)
    ;;
val fibonacci : int -&gt; int = &lt;fun&gt;

&gt; #trace fibonacci ;;
fibonacci is now traced.
&gt; 

&gt; fibonacci 0 ;;
fibonacci &lt;-- 0
fibonacci --&gt; 1
- : int = 1

&gt; fibonacci 2 ;;
fibonacci &lt;-- 2
fibonacci &lt;-- 0
fibonacci --&gt; 1
fibonacci &lt;-- 1
fibonacci --&gt; 1
fibonacci --&gt; 2
- : int = 2

&gt; fibonacci 3 ;;
fibonacci &lt;-- 3
fibonacci &lt;-- 1
fibonacci --&gt; 1
fibonacci &lt;-- 2
fibonacci &lt;-- 0
fibonacci --&gt; 1
fibonacci &lt;-- 1
fibonacci --&gt; 1
fibonacci --&gt; 2
fibonacci --&gt; 3
- : int = 3
&gt; 

&gt; #untrace fibonacci ;;
fibonacci is no longer traced.
&gt; 

&gt; fibonacci 3 ;;
- : int = 3
&gt; fibonacci 13 ;;
- : int = 377
&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-13-5" class="outline-4">
<h4 id="sec-1-13-5"><span class="section-number-4">1.13.5</span> Generating OCaml html API Doc</h4>
<div class="outline-text-4" id="text-1-13-5">
<p>
It is very handy to have the documentation of installed packages locally available. The script provided here, that is written in Ocaml has only one dependency the PCRE library. It is a wrapper to ocamldoc that builds the html documentation of almost any package installed.
</p>

<p>
<a href="[[src/docgen.ml][docgen.ml">[[src/docgen.ml][docgen.ml</a>]]
</p>


<p>
List Installed Packages
</p>

<div class="org-src-container">

<pre class="src src-bash"> # List installed packages
 #  
$ opam list
 # Installed packages for 4.02.1:
async                  112.24.00  Monadic concurrency library
async_extra            112.24.00  Monadic concurrency library
async_kernel           112.24.00  Monadic concurrency library
async_unix             112.24.00  Monadic concurrency library
atd                        1.1.2  Parser for the ATD data format description langu
atdgen                     1.6.1  Generates efficient JSON serializers, deserializ
base-bigarray               base  Bigarray library distributed with the OCaml comp
base-bytes                  base  Bytes library distributed with the OCaml compile
base-threads                base  Threads library distributed with the OCaml compi
base-unix                   base  Unix library distributed with the OCaml compiler
base64                     2.0.0  Base64 encoding and decoding library
...


 ## Or

$ ocamlfind list
async               (version: 112.24.00)
async_extra         (version: 112.24.00)
async_kernel        (version: 112.24.00)
async_unix          (version: 112.24.00)
atd                 (version: 1.1.2)
atdgen              (version: 1.6.1)
base64              (version: 2.0.0)
batteries           (version: 2.3)
...
</pre>
</div>

<p>
Installation and Usage:
</p>

<pre class="example">
$ opam install pcre # or install pcre manually 

 # Put the script at any directory you want
$ mkdir ocamlapidoc
$ cd ocamlapidoc

 # Download the script
$ https://raw.githubusercontent.com/caiorss/Functional-Programming/master/ocaml/src/docgen.ml
$ chmod +x docgen.ml


$ ./docgen.ml 

Ocaml docgen wrapper to ocamlfind 
                  
        Usage:                                   
                                                 
        List all packages               
        $ ./docgen.ml -list                      
                                                 
        Generate package documentation           
        $ ./docgen.ml -doc &lt;name of package&gt;    

        Generate the documentation of all packages
        $ ./docgen.ml -doc all

        Get Package Directory
        $ ./docgen.ml -dir &lt;name of package&gt; 

        Generate package documentation and open index.html in the browser.
        $ ./docgen.ml -browser &lt;name of package&gt;
</pre>

<p>
Generating html documentation of Batteries package:
</p>

<pre class="example">
 ## Get the directory of the package batteries

$ ./docgen.ml -dir batteries
/home/tux/.opam/4.02.1/lib/batteries

 ## Generate the docs

$ pwd
/home/tux/windows/ocamlapidoc
 
$ ./docgen.ml -doc batteries

 # It will put the documentation inside the directory
 # ./batteries  

$ ls
batteries/  docgen.ml*

$ ls batteries/

BatInterfaces.Monad.html
BatInterfaces.OrderedType.html
BatInt.html
BatInt.Infix.html
BatInt.Safe_int.Compare.html
BatInt.Safe_int.html
BatInt.Safe_int.Infix.ht
...

 ## Open the documentation in the browser

$ chromium-browser batteries/index.html 

 ### Or use
 #
 #  Docgen uses chromium-browser hardcoded, but you can 
 #  change to whatever browser you wish
 $ ./docgen.ml -browser batteries
</pre>

<p>
<b>Generated Documentation Screenshots</b>
</p>

<p>
Documentation Directory
</p>


<div class="figure">
<p><img src="images/apidoc_directory.png" alt="apidoc_directory.png" />
</p>
</div>

<p>
Batteries modules:
</p>


<div class="figure">
<p><img src="images/apidoc1.png" alt="apidoc1.png" />
</p>
</div>

<p>
Batteries BattList module:
</p>


<div class="figure">
<p><img src="images/apidoc2.png" alt="apidoc2.png" />
</p>
</div>

<p>
Batteries BattList Functions Signatures and Descriptions:
</p>


<div class="figure">
<p><img src="images/apidoc3.png" alt="apidoc3.png" />
</p>
</div>

<p>
Generated Files
</p>


<div class="figure">
<p><img src="images/apidoc_generated_files.png" alt="apidoc_generated_files.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> Resources</h3>
<div class="outline-text-3" id="text-1-14">
</div><div id="outline-container-sec-1-14-1" class="outline-4">
<h4 id="sec-1-14-1"><span class="section-number-4">1.14.1</span> Articles</h4>
<div class="outline-text-4" id="text-1-14-1">
<ul class="org-ul">
<li><a href="http://cacm.acm.org/magazines/2011/11/138203-ocaml-for-the-masses/fulltext">Ocaml for the masses - by Yaron Minks, Jane Stree Capital</a>
</li>

<li>[ocamlscript: natively-compiled OCaml scripts]
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-1-14-2" class="outline-4">
<h4 id="sec-1-14-2"><span class="section-number-4">1.14.2</span> Links</h4>
<div class="outline-text-4" id="text-1-14-2">
<ul class="org-ul">
<li><a href="http://wiki.xen.org/wiki/OCaml_Best_Practices_for_Developers#OCaml_Best_Practices_Guide">OCaml Best Practices for Developers / Xen</a>
</li>

<li><a href="http://pleac.sourceforge.net/pleac_ocaml/packagesetc.html">http://pleac.sourceforge.net/pleac_ocaml/packagesetc.html</a>
</li>

<li><a href="http://projects.camlcity.org/projects/dl/findlib-1.2.6/doc/guide-html/quickstart.html">http://projects.camlcity.org/projects/dl/findlib-1.2.6/doc/guide-html/quickstart.html</a>
</li>

<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html">http://caml.inria.fr/pub/docs/manual-ocaml/extn.html</a>
</li>

<li><a href="http://www.loria.fr/~shornus/ocaml/slides-ocaml-3.pdf">http://www.loria.fr/~shornus/ocaml/slides-ocaml-3.pdf</a>
</li>

<li><a href="http://blog.enfranchisedmind.com/2007/01/ocaml-lazy-lists-an-introduction/">http://blog.enfranchisedmind.com/2007/01/ocaml-lazy-lists-an-introduction/</a>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-1-14-3" class="outline-4">
<h4 id="sec-1-14-3"><span class="section-number-4">1.14.3</span> Books</h4>
<div class="outline-text-4" id="text-1-14-3">
</div><div id="outline-container-sec-1-14-3-1" class="outline-5">
<h5 id="sec-1-14-3-1"><span class="section-number-5">1.14.3.1</span> Online Books</h5>
<div class="outline-text-5" id="text-1-14-3-1">
<p>
<b>Real World OCaml: Functional Programming for the Masses</b>
</p>
<ul class="org-ul">
<li><a href="https://realworldocaml.org/v1/en/html/index.html">Link</a>
<ul class="org-ul">
<li>Authors: Jason Hickey, Anil Madhavapeddy and Yaron Minsky
</li>
<li>Publisher: O'Reilly
</li>
</ul>
</li>
</ul>

<p>
<b>Developing Applications With Objective OCaml</b>
</p>
<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/oreilly-book/">Link</a>
<ul class="org-ul">
<li>Authors: Emmanuel Chailloux, Pascal Manoury and Bruno Pagano
</li>
<li>Publisher: O'Reilly France.
</li>
<li><a href="http://caml.inria.fr/pub/docs/oreilly-book/html/index.html">http://caml.inria.fr/pub/docs/oreilly-book/html/index.html</a>
</li>
</ul>
</li>
</ul>

<p>
<b>Introduction to Objective Caml</b>
</p>
<ul class="org-ul">
<li><a href="http://files.metaprl.org/doc/ocaml-book.pdf">Link</a>
<ul class="org-ul">
<li>Authors: Jason Hickey
</li>
<li>Url2: <a href="http://main.metaprl.org/jyh/classes/cs134/cs134b/2007/public_html/assets/hickey.pdf">Introduction to the Objective Caml Programming Language</a>
</li>
</ul>
</li>
</ul>

<p>
<b>Unix system programming in OCaml</b>
</p>
<ul class="org-ul">
<li><a href="http://ocaml.github.io/ocamlunix/">Link</a>
<ul class="org-ul">
<li>Authors: Xavier Leroy and Didier Rémy
</li>
</ul>
</li>
</ul>

<p>
<b>Using, Understanding, and Unraveling - The OCaml Language From Practice to Theory and vice versa</b>
</p>
<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/u3-ocaml/index.html">Link</a>, Didier Rémy
</li>
</ul>


<p>
<b>Think Ocaml - How to Think Like a (Functional) Programmer</b>
</p>
<ul class="org-ul">
<li><a href="http://www.greenteapress.com/thinkocaml/index.html">Link</a>
<ul class="org-ul">
<li>Authors: Allen Downey, Nicholas Monje 
</li>
<li>Pùblisher: Green Tea Press
</li>
</ul>
</li>
</ul>

<p>
<b>OCaml Inria Manual v4.02</b>
</p>
<ul class="org-ul">
<li><a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.02-1/">Link</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-14-4" class="outline-4">
<h4 id="sec-1-14-4"><span class="section-number-4">1.14.4</span> Community</h4>
<div class="outline-text-4" id="text-1-14-4">
</div><div id="outline-container-sec-1-14-4-1" class="outline-5">
<h5 id="sec-1-14-4-1"><span class="section-number-5">1.14.4.1</span> Online Resources</h5>
<div class="outline-text-5" id="text-1-14-4-1">
<ul class="org-ul">
<li>Reddit:           <a href="http://reddit.com/r/ocaml">http://reddit.com/r/ocaml</a>
</li>
<li>Usenet:           comp.lang.ocaml
</li>
<li>StackOverflow
<ul class="org-ul">
<li><a href="http://stackoverflow.com/tags/ocaml/info">http://stackoverflow.com/tags/ocaml/info</a>
</li>
<li><a href="http://stackoverflow.com/questions/tagged/ocaml">http://stackoverflow.com/questions/tagged/ocaml</a>
</li>
</ul>
</li>
<li>Email List (lists.ocaml.org): <a href="http://lists.ocaml.org/listinfo">http://lists.ocaml.org/listinfo</a>
</li>

<li><a href="https://ocaml.org/learn/">https://ocaml.org/learn/</a>
</li>

<li><a href="http://caml.inria.fr/resources/index.en.html">Resources for Caml users - Inria</a>
</li>

<li><a href="http://langref.org/ocaml">Lang Ref / Ocaml</a>
</li>

<li><a href="http://rosettacode.org/wiki/Category:OCaml">Rosetta Wiki Code Ocaml</a>
</li>

<li><a href="http://pleac.sourceforge.net/pleac_ocaml/">PLEAC-Objective CAML</a>
</li>

<li id="[[<a href="http://www.cs.cornell.edu/Courses/cs3110/2011sp/lecturenotes.asp][Cornell">http://www.cs.cornell.edu/Courses/cs3110/2011sp/lecturenotes.asp][Cornell</a> University - CS3110 Spring 11">Data Structures and Functional Programming]]
</li>
</ul>


<ul class="org-ul">
<li>[Universytet Wroclawiski | Lukaz Stafiniak / Functional Lectures] (<a href="http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional">http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional</a>)
</li>

<li><a href="http://www.southampton.ac.uk/~fangohr/software/ocamltutorial/">University of Southampton | Tutorial: OCaml for scientific computation - Dr. Thomas Fischbacher, Hans Fangohr</a>
</li>

<li><a href="https://github.com/jimenezrick/ocaml-backpack/blob/master/src/backpackString.ml">String Pattern Matching Examples</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://www.martani.net/2009/04/ocaml-exceptions-small-tutorial.html">OCAML exceptions, a small tutorial</a>
</li>

<li><a href="http://www.crmarsh.com/intro_to_ocaml/">First Thoughts on OCaml</a>
</li>

<li><a href="http://www2.lib.uchicago.edu/keith/ocaml-class/compiling.html">OCaml for the Skeptical - Compiling and Running Programs</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-2" class="outline-5">
<h5 id="sec-1-14-4-2"><span class="section-number-5">1.14.4.2</span> Blogs</h5>
<div class="outline-text-5" id="text-1-14-4-2">
<ul class="org-ul">
<li><a href="https://blogs.janestreet.com">Jane Street Capital - Blog</a>
</li>

<li><a href="http://www.ocamlpro.com/blog">Ocamlpro Blog</a>
</li>

<li><i>The MirageOS Blog on building functional operating systems</i>
</li>

<li><a href="https://www.lexifi.com/blogs/ocaml">OCaml at LexiFi | LexiFi</a>
</li>

<li><a href="http://roscidus.com/blog/">Rosciuds Blog</a>
</li>

<li><i>Alaska Ataca a Kamtchatka</i>
</li>

<li><a href="http://okmij.org/ftp/ML/">Oleg Kiselyov</a>
</li>

<li><a href="http://ambassadortothecomputers.blogspot.com/2009/05/lwt-and-concurrent-ml.html">Ambassador to the Computers Mostly OCaml.</a>
</li>

<li><a href="http://functional-orbitz.blogspot.com">Functional Orbitz</a>
</li>

<li><a href="http://simongrondin.name/?p=330#more-330">An Overview of Ocaml - Simon Grondin - An Adventure in Software Industry</a>
</li>

<li><a href="http://www.mega-nerd.com/erikd/Blog/CodeHacking/Ocaml/index.html">Mega Nerd blog / Ocaml</a>
</li>

<li><a href="http://www.matt-mcdonnell.com/blog/blog_ocaml/blog_ocaml.html">Matt Mcdonnel - Ocaml</a>
</li>

<li><a href="http://aubedesheros.blogspot.com/search/label/ocaml">http://aubedesheros.blogspot.com/search/label/ocaml</a>  (In French)
</li>

<li><a href="http://takeisamemo.blogspot.com.br/search/label/OCaml">Ruby,Lisp,Emacs,Clojure.OCaml,Haskell,Raspberry Piのメモ</a> (In Japanese)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-3" class="outline-5">
<h5 id="sec-1-14-4-3"><span class="section-number-5">1.14.4.3</span> Hacker News Threads</h5>
<div class="outline-text-5" id="text-1-14-4-3">
<ul class="org-ul">
<li><a href="https://news.ycombinator.com/item?id=8002188">OCaml for the Masses (2011)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=7858276">Python to OCaml: Retrospective (roscidus.com)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=7416203">Why OCaml, Why Now? (spyder.wordpress.com)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=112129">Ask Hackers: Opinions on OCaml?</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=9582980">OCaml 4.03 will, “if all goes well”, support multicore (inria.fr)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=3740173">Code iOS Apps in OCaml</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=8653207">OCaml Briefly (mads379.github.io)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=8226139">The fundamental problem of programming language package management</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=9463254">Four MLs (and a Python) (thebreakfastpost.com)</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=3438084">Jane Street releases open source alternative to OCaml's stdlib</a>
</li>

<li><a href="https://news.ycombinator.com/item?id=1883679">Why did Microsoft invest so much in F#?</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-4" class="outline-5">
<h5 id="sec-1-14-4-4"><span class="section-number-5">1.14.4.4</span> Slides and Presentations</h5>
<div class="outline-text-5" id="text-1-14-4-4">
<ul class="org-ul">
<li><a href="http://www.cs.columbia.edu/~sedwards/classes/2012/w4115-spring/ocaml.pdf">An Introduction to Objective Caml - Stephen A. Edwards - Columbia University</a>
</li>

<li><a href="http://www.slideshare.net/pramode_ce/fp-29715231?next_slideshow=1">Slideshare - Introduction to functional programming using Ocaml</a>
</li>

<li><a href="http://www.slideshare.net/yoriyuki/camomile-a-unicode-library-for-ocaml?related=4">Camomile : A Unicode library for OCaml</a>
</li>

<li><a href="http://www.slideshare.net/AnilMadhavapeddy/ocaml-labs-introduction-at-ocaml-consortium-2012?related=1">OCaml Labs introduction at OCaml Consortium 2012</a>
</li>
</ul>


<ul class="org-ul">
<li>[Abstractions and Types for Concurrent Programming - Yaron Minsky
</li>
</ul>
<p>
Jane Street](<a href="http://www.cs.princeton.edu/~dpw/courses/cos326-12/lec/asynch-and-rpc.pdf">http://www.cs.princeton.edu/~dpw/courses/cos326-12/lec/asynch-and-rpc.pdf</a>)
</p>

<ul class="org-ul">
<li><a href="http://www.slideshare.net/cyber_jso/ocaml-13036522?related=3">Ocaml - Objective Caml</a>
</li>

<li><a href="http://www.slideshare.net/dsyme/fp-successv4redist?related=5s">Succeeding with Functional-first Programming in Enterprise - by Dr. Don Syme - Microsoft Research</a>
</li>

<li><a href="https://ocaml.org/meetings/ocaml/2014/ocaml2014_13.pdf">LibreS3: design, challenges, and steps toward reusable libraries</a>
</li>

<li><a href="http://files.meetup.com/1887771/2013-07-11%20Js_of_ocaml%20The%20OCaml%20to%20Javascript%20Compiler.pdf">NYC OCaml Meetup: Js_of_ocaml</a>
</li>

<li><a href="http://ashishagarwal.org/wp-content/uploads/2012/06/IBM_PL_Day_2012.pdf">Managing and Analyzing Big-Data in Genomics</a>
</li>

<li><a href="http://www.loria.fr/~shornus/ocaml/slides-ocaml-3.pdf">Programmation fonctionnelle avec OCaml</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-5" class="outline-5">
<h5 id="sec-1-14-4-5"><span class="section-number-5">1.14.4.5</span> Stack Overflow Highlighted Questions</h5>
<div class="outline-text-5" id="text-1-14-4-5">
<p>
<b>Syntax / Implementation</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/7524487/what-does-let-mean-in-ocaml">What does “let () = ” mean in Ocaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/1604270/what-is-the-different-between-fun-and-function-keywords">What is the different between `fun` and `function` keywords?</a>
</li>

<li><a href="http://stackoverflow.com/questions/8017172/why-is-ocamls-not-polymorphic">Why is OCaml's (+) not polymorphic?</a>
</li>

<li><a href="http://stackoverflow.com/questions/19498928/what-are-in-ocaml">What are “`” in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/199918/explaining-pattern-matching-vs-switch">Explaining pattern matching vs switch</a>
</li>

<li><a href="http://stackoverflow.com/questions/4777744/ocaml-variant-types">Ocaml Variant Types</a>
</li>

<li><a href="http://stackoverflow.com/questions/3773985/why-is-an-int-in-ocaml-only-31-bits">Why is an int in OCaml only 31 bits?</a>
</li>

<li><a href="http://stackoverflow.com/questions/9498746/ocaml-insert-an-element-in-list">OCaml insert an element in list</a>
</li>

<li><a href="http://stackoverflow.com/questions/14001569/ocaml-accessing-components-in-an-array-of-records">Ocaml - Accessing components in an array of records</a>
</li>

<li><a href="http://stackoverflow.com/questions/13590307/whats-the-difference-between-equal-and-identical-in-ocaml/13590433#13590433">What's the difference between “equal (<code>)” and “identical (=</code>)” in ocaml?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/25878382/why-is-1-0-1-0-false-in-ocaml">Why is “1.0 == 1.0” false in Ocaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/9647307/how-to-curry-a-function-w-r-t-its-optional-arguments-in-ocaml">How to curry a function w.r.t. its optional arguments in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/11515240/whats-the-difference-between-let-and-let">What's the difference between “let ()=” and “let _=” ;</a>
</li>

<li><a href="http://stackoverflow.com/questions/23323032/in-ocaml-what-type-definition-is-this-a-unit-a?rq=1">In OCaml, what type definition is this: 'a. unit -&gt; 'a</a>
</li>

<li><a href="http://stackoverflow.com/questions/8962895/hashtables-in-ocaml/8963057#8963057">Hashtables in ocaml - Is it possible to store different types in the same hashtable (Hashtbl) in Ocaml? Are hashtables really restricted to just one type?</a>
</li>

<li><a href="http://stackoverflow.com/questions/8326926/how-do-you-append-a-char-to-a-string-in-ocaml/8329852#8329852">How do you append a char to a string in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/9776245/ocaml-int-to-binary-string-conversion">Ocaml int to binary string conversion</a>
</li>

<li><a href="http://stackoverflow.com/questions/14425762/ocaml-regex-specify-a-number-of-occurrences">OCaml regex: specify a number of occurrences</a>
</li>

<li><a href="http://stackoverflow.com/questions/10459363/side-effects-and-top-level-expressions-in-ocaml">Side-effects and top-level expressions in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/20931144/ocaml-passing-labeled-function-as-parameter-labeled-function-type-equivalence">OCaml passing labeled function as parameter / labeled function type equivalence</a>
</li>

<li><a href="http://stackoverflow.com/questions/21225701/ocaml-bitstring-within-a-script">ocaml bitstring within a script</a>
</li>

<li><a href="http://stackoverflow.com/questions/22067339/whats-the-most-used-data-structure-in-ocaml-to-represent-a-graph">What's the most-used data structure in OCaml to represent a Graph?</a>
</li>
</ul>


<p>
<b>Functional Programming</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/5843773/state-monad-in-ocaml">State monad in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/24943140/the-reverse-state-monad-in-ocaml">The reverse state monad in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/29851449/what-is-the-use-of-monads-in-ocaml">What is the use of monads in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/25790177/monadic-buffers-in-ocaml">Monadic buffers in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/21031920/does-ocaml-have-fusion-laws">Does OCaml have fusion laws</a>
</li>

<li><a href="http://stackoverflow.com/questions/4997661/composite-functions-in-ocaml">Composite functions in ocaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/30493644/ocaml-operator">OCaml |&gt; operator</a>
</li>

<li><a href="http://stackoverflow.com/questions/8986010/is-it-possible-to-use-pipes-in-ocaml">Is it possible to use pipes in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/16637015/is-there-an-infix-function-composition-operator-in-ocaml/16637073#16637073">Is there an infix function composition operator in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/832569/list-of-functional-code-snippets-for-procedural-programmers">List of Functional code snippets for Procedural Programmers?</a>
</li>

<li><a href="http://stackoverflow.com/questions/19771283/application-of-tail-recursion-in-ocaml">Application of Tail-Recursion in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor">In Functional Programming, what is a functor?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/13404208/in-pure-functional-languages-is-there-an-algorithm-to-get-the-inverse-function">In pure functional languages, is there an algorithm to get the inverse function?</a>
</li>

<li><a href="http://stackoverflow.com/questions/4399837/what-is-the-benefit-of-purely-functional-data-structure">What is the benefit of purely functional data structure?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/14934242/whats-the-closest-thing-to-haskells-typeclasses-in-ocaml">What's the closest thing to Haskell's typeclasses in OCaml?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/7367655/defining-functions-pointfree-style-in-functional-programming-what-are-the-cons">Defining functions pointfree-style in functional programming. What are the cons/pros?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/28177263/what-is-lenses-in-ocamls-world"> What is <b>lenses</b> in OCaml's world </a>
</li>

<li><a href="http://stackoverflow.com/questions/1738758/linked-list-ocaml">Linked List Ocaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/3660957/functional-programming-languages-introspection">Functional programming languages introspection</a>
</li>

<li><a href="http://stackoverflow.com/questions/10779283/when-should-objects-be-used-in-ocaml">When should objects be used in OCaml?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/5131954/open-and-closed-union-types-in-ocaml">Open and closed union types in Ocaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/14781875/choosing-between-continuation-passing-style-and-memoization">Choosing between continuation passing style and memoization</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/27864200/an-concrete-simple-example-to-demonstrate-gadt-in-ocaml">An concrete simple example to demonstrate GADT in OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/18213973/generating-primes-without-blowing-the-stack">Generating primes without blowing the stack</a>
</li>

<li><a href="http://stackoverflow.com/questions/9054613/executing-a-list-of-functions">Executing a list of functions</a>
</li>

<li><a href="http://stackoverflow.com/questions/30241118/best-way-to-represent-a-file-folder-structure">Best way to represent a file/folder structure</a>
</li>

<li><a href="http://stackoverflow.com/questions/27285170/how-would-you-implement-a-grid-in-a-functional-language">How would you implement a Grid in a functional language?</a>
</li>

<li><a href="http://stackoverflow.com/questions/15285386/ocaml-recursive-function-to-apply-a-function-n-times">OCaml recursive function to apply a function n times</a>
</li>

<li><a href="http://stackoverflow.com/questions/28732351/ocaml-read-csv-file-into-array">OCaml - Read csv file into array</a>
</li>
</ul>


<p>
<b>Lazy Evaluation/ Delayed Evaluation/ Generators / Yield</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/30197961/are-streams-in-ocaml-really-used">Are streams in ocaml really used?</a>
</li>

<li><a href="http://stackoverflow.com/questions/1631968/ocaml-lazy-lists">Ocaml: Lazy Lists - How can I make a lazy list representing a sequence of doubling numbers?</a>
</li>

<li><a href="http://stackoverflow.com/questions/18401178/ocaml-lazy-force">Ocaml - Lazy.force</a>
</li>

<li><a href="http://stackoverflow.com/questions/13146128/simple-generators">Simple Generators</a>
</li>

<li>[[<a href="http://stackoverflow.com/questions/16150173/what-does-mean-in-ocaml][What">http://stackoverflow.com/questions/16150173/what-does-mean-in-ocaml][What</a> does `[&lt; &gt;]` mean in OCaml?]]
</li>

<li><a href="http://stackoverflow.com/questions/9760580/what-is-the-purpose-of-ocamls-lazy-lazy-from-val">What is the purpose of OCaml's Lazy.lazy_from_val?</a>
</li>

<li><a href="http://stackoverflow.com/questions/16027627/converting-ocaml-function-to-stream">converting ocaml function to stream</a>
</li>

<li><a href="http://stackoverflow.com/questions/3969321/lazy-n-choose-k-in-ocaml">Lazy “n choose k” in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/24123294/thread-safe-lazy-in-ocaml">Thread safe lazy in OCaml</a>
</li>
</ul>

<p>
<b>SML Dialects</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/699689/what-are-the-differences-between-sml-and-ocaml">What are the differences between SML and Ocaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/179492/f-changes-to-ocaml">F# changes to OCaml</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/14428420/converting-f-seq-expressions-to-ocaml">Converting F# seq expressions to OCaml</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/6589959/ienumerablet-in-ocaml">IEnumerable&lt;T&gt; in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/4239121/code-compatibility-between-ocaml-and-f">code compatibility between OCaml and F#</a>
</li>

<li><a href="http://stackoverflow.com/questions/14777522/if-sml-net-had-functors-why-cant-f">If SML.NET had functors why can't F#?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/27045225/streams-aka-lazy-lists-and-tail-recursion">Streams (aka “lazy lists”) and tail recursion</a>
</li>
</ul>

<p>
<b>Standard Library</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/3307936/how-stable-and-widespread-is-ocaml-batteries-included-and-is-it-recommended">How stable and widespread is “OCaml Batteries Included” and is it recommended?</a>
</li>

<li><a href="http://stackoverflow.com/questions/15751851/cygwin-ocaml-opam-batteries">Cygwin &amp; OCaml: OPAM + Batteries</a>
</li>

<li><a href="http://stackoverflow.com/questions/10667329/using-ocaml-batteries-included-as-a-vanilla-cma?rq=1">using OCaml Batteries Included as a vanilla cma</a>
</li>

<li><a href="http://stackoverflow.com/questions/3889117/what-are-the-pros-and-cons-of-batteries-and-core?rq=1">What are the pros and cons of Batteries and Core?</a>
</li>
</ul>


<p>
<b>Build / Compile</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/27771452/building-library-with-ocamlbuild-installing-it-with-ocamlfind-whats-the-best">Building library with ocamlbuild, installing it with ocamlfind - what's the best practice?</a>
</li>

<li><a href="http://stackoverflow.com/questions/5956317/what-is-the-preferred-way-to-structure-and-build-ocaml-projects?rq=1">What is the preferred way to structure and build OCaml projects?</a>
</li>

<li><a href="http://stackoverflow.com/questions/17315402/how-to-make-ocaml-bytecode-that-works-on-windows-and-linux">How to make OCaml bytecode that works on Windows and Linux</a>
</li>
</ul>

<p>
<b>Tool Chain</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/14747939/ide-for-ocaml-language">IDE for OCaml language</a>
</li>

<li><a href="http://stackoverflow.com/questions/3966925/saving-my-running-toplevel-for-later">Saving my running toplevel for later</a>
</li>

<li><a href="http://stackoverflow.com/questions/1849245/is-there-an-enhanced-interpreter-toploop-for-ocaml">Is there an enhanced interpreter toploop for OCaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/13225070/is-it-possible-to-use-arrow-keys-in-ocaml-interpreter/13225113#13225113">Is it possible to use arrow keys in OCaml interpreter?</a>
</li>

<li><a href="http://stackoverflow.com/questions/27640897/is-it-possible-to-make-an-opam-sandbox">Is it possible to make an opam “sandbox”?</a>
</li>

<li><a href="http://stackoverflow.com/questions/24824849/for-ocaml-is-there-a-tool-to-quickly-access-function-or-library-documentation-f">For OCaml, is there a tool to quickly access function or library documentation from the command line?</a>
</li>

<li><a href="http://stackoverflow.com/questions/4063039/annotations-in-ocaml">Annotations in OCaml</a>
</li>

<li><a href="http://stackoverflow.com/questions/8059657/about-the-topfind">About the “topfind”?</a>
</li>

<li><a href="http://stackoverflow.com/questions/21132371/get-ocamlmerlin-autocomplete-in-vim">Get ocamlmerlin autocomplete in vim</a>
</li>

<li><a href="http://stackoverflow.com/questions/8630599/is-there-a-reason-to-retain-cmo-or-only-cma">Is there a reason to retain .cmo or only .cma?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/20927592/ocaml-utop-library-paths-core-module?rq=1">Ocaml utop library paths, Core module</a>
</li>

<li><a href="http://stackoverflow.com/questions/9426560/how-to-trace-a-program-for-debugging-in-ocaml">How to trace a program for debugging in OCaml ?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/15514908/which-is-the-current-setup-to-use-ocaml-in-vim">Which is the current setup to use OCaml in Vim?</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/26032055/how-can-i-use-ocamlbrowser-with-opam-packages">How can I use ocamlbrowser with opam packages?</a>
</li>
</ul>

<p>
<b>Misc</b>
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/1094866/how-do-i-inteface-ocaml-with-iphone-api">How do I inteface OCaml with iPhone API?</a>
</li>

<li><a href="http://stackoverflow.com/questions/13535149/accessing-libraries-written-in-ocaml-and-c-from-ruby-code">Accessing libraries written in OCaml and C++ from Ruby code</a>
</li>
</ul>


<ul class="org-ul">
<li>[Code generation for mathematical
</li>
</ul>
<p>
problems](<a href="http://stackoverflow.com/questions/13203089/code-generation-for-mathematical-problems">http://stackoverflow.com/questions/13203089/code-generation-for-mathematical-problems</a>)
</p>

<ul class="org-ul">
<li><a href="http://stackoverflow.com/questions/27061506/ocaml-for-arm-cortex-m4">Ocaml for ARM cortex M4?</a>
</li>

<li><a href="http://stackoverflow.com/questions/9472371/cross-compiling-ocaml-apps-for-arm">Cross-compiling ocaml apps for ARM</a>
</li>

<li><a href="http://stackoverflow.com/questions/9434050/how-to-represent-a-simple-finite-state-machine-in-ocaml">How to represent a simple finite state machine in Ocaml?</a>
</li>

<li><a href="http://stackoverflow.com/questions/15524450/how-to-convert-numbers-among-hex-oct-decimal-and-binary-in-ocaml">How to convert numbers among hex, oct, decimal and binary in OCaml?</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-6" class="outline-5">
<h5 id="sec-1-14-4-6"><span class="section-number-5">1.14.4.6</span> See Also</h5>
<div class="outline-text-5" id="text-1-14-4-6">
<ul class="org-ul">
<li><a href="http://science.raphael.poss.name/haskell-for-ocaml-programmers.html">Haskell for OCaml programmers</a>
</li>
<li><a href="http://blog.ezyang.com/2010/10/ocaml-for-haskellers/">OCaml for Haskellers</a>
</li>
<li><a href="http://hyperpolyglot.org/ml">ML Dialects and Haskell: SML, OCaml, F#, Haskell</a>
</li>
<li><a href="http://www.csc.villanova.edu/~dmatusze/resources/ocaml/ocaml.html">A Concise Introduction to Objective Caml</a>
</li>
<li><a href="http://keleshev.com/namespacing-variants-in-ml">Namespacing Variants in ML</a>
</li>

<li><a href="https://haifengl.wordpress.com/2014/07/07/ocaml-algebraic-data-types/">Haifeng's Random Walk - OCaml: Algebraic Data Types</a>
</li>

<li><a href="http://caml.inria.fr/pub/docs/u3-ocaml/ocaml051.html">Appendix B  Variant types and labeled arguments</a>
</li>

<li><a href="http://roscidus.com/blog/blog/2013/10/13/ocaml-tips/">Thomas Leonard's blog - OCaml Tips</a>
</li>
<li><a href="http://roscidus.com/blog/blog/2013/09/28/ocaml-objects/">Thomas Leonard's blog - Experiences With OCaml Objects</a>
</li>

<li><a href="http://lambdafoo.com/blog/2015/05/15/unreliable-guide-to-ocaml-modules/">Unreliable Guide to OCaml Modules</a>
</li>
</ul>


<ul class="org-ul">
<li><a href="http://blog.bentobako.org/index.php?post/2011/12/02/A-draft-of-library-to-handle-physical-units-in-OCaml">A draft of library to handle physical units in OCaml</a>
</li>

<li><a href="http://javiermunhoz.com/blog/2014/04/19/detecting-and-removing-computer-virus-with-ocaml.html">Detecting and removing computer virus with OCaml</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-14-4-7" class="outline-5">
<h5 id="sec-1-14-4-7"><span class="section-number-5">1.14.4.7</span> Quick Reference Sheets</h5>
<div class="outline-text-5" id="text-1-14-4-7">
<ul class="org-ul">
<li><a href="https://github.com/OCamlPro/ocaml-cheat-sheets">https://github.com/OCamlPro/ocaml-cheat-sheets</a>
</li>

<li><a href="http://www.ocamlpro.com/blog/2011/06/03/cheatsheets.html">OCaml Cheat Sheets</a>
</li>

<li><a href="https://www.lri.fr/~conchon/IPF/fiches/ocaml-lang.pdf">https://www.lri.fr/~conchon/IPF/fiches/ocaml-lang.pdf</a>
</li>

<li><a href="http://cl-informatik.uibk.ac.at/teaching/ss06/ocaml/content/w1-2x2.pdf">http://cl-informatik.uibk.ac.at/teaching/ss06/ocaml/content/w1-2x2.pdf</a>
</li>

<li><a href="https://www.lri.fr/~conchon/IPF/fiches/tuareg-mode.pdf">https://www.lri.fr/~conchon/IPF/fiches/tuareg-mode.pdf</a>
</li>

<li><a href="http://blog.eatonphil.com/2015/03/28/the-ocaml-build-process/">The OCaml Build Process by Example</a>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-14-5" class="outline-4">
<h4 id="sec-1-14-5"><span class="section-number-4">1.14.5</span> References By Subject</h4>
<div class="outline-text-4" id="text-1-14-5">
<p>
<b>Lazy Evaluation</b>
</p>

<ul class="org-ul">
<li><a href="http://cl-informatik.uibk.ac.at/teaching/ws09/fp/ohp/week12-1x2.pdf">http://cl-informatik.uibk.ac.at/teaching/ws09/fp/ohp/week12-1x2.pdf</a>
</li>
<li><a href="http://typeocaml.com/2014/11/13/magic-of-thunk-lazy/">http://typeocaml.com/2014/11/13/magic-of-thunk-lazy/</a>
</li>
<li><a href="http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/uploads/Functional/functional-lecture07.pdf">http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/uploads/Functional/functional-lecture07.pdf</a>
</li>

<li><a href="http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/uploads/Functional/functional-lecture07.pdf">Lazy Evaluation and Stream Processing</a>
<ul class="org-ul">
<li><a href="http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional">http://www.ii.uni.wroc.pl/~lukstafi/pmwiki/index.php?n=Functional.Functional</a>
</li>
</ul>
</li>

<li>Lazy Expression Evaluation with Demand Paging / In Virtual Memory
Managementhttp://www.ijeat.org/attachments/File/v2i1/A0690092112.pdf
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Caio Rodrigues</p>
<p class="date">Created: 2016-11-01 ter 01:18</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
